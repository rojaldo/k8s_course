<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.26">
<title>Curso de Rancher: Gestión Avanzada de Kubernetes</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock pre>code{display:block}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Curso de Rancher: Gestión Avanzada de Kubernetes</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_módulo_1_introducción_a_rancher">Módulo 1: Introducción a Rancher</a>
<ul class="sectlevel2">
<li><a href="#_1_1_qué_es_rancher">1.1 ¿Qué es Rancher?</a>
<ul class="sectlevel3">
<li><a href="#_historia_y_evolución_de_rancher">Historia y evolución de Rancher</a></li>
<li><a href="#_arquitectura_y_componentes_principales">Arquitectura y componentes principales</a></li>
<li><a href="#_comparación_con_otras_plataformas_de_gestión_kubernetes">Comparación con otras plataformas de gestión Kubernetes</a></li>
<li><a href="#_casos_de_uso_y_beneficios_empresariales">Casos de uso y beneficios empresariales</a></li>
</ul>
</li>
<li><a href="#_1_2_arquitectura_de_rancher">1.2 Arquitectura de Rancher</a>
<ul class="sectlevel3">
<li><a href="#_componentes_del_plano_de_control">Componentes del plano de control</a></li>
<li><a href="#_arquitectura_multi_clúster">Arquitectura multi-clúster</a></li>
<li><a href="#_comunicación_entre_componentes">Comunicación entre componentes</a></li>
<li><a href="#_alta_disponibilidad_y_escalabilidad">Alta disponibilidad y escalabilidad</a></li>
</ul>
</li>
<li><a href="#_1_3_versiones_y_ediciones_de_rancher">1.3 Versiones y ediciones de Rancher</a>
<ul class="sectlevel3">
<li><a href="#_rancher_prime_vs_community_edition">Rancher Prime vs Community Edition</a></li>
<li><a href="#_matriz_de_soporte_y_versiones_compatibles">Matriz de soporte y versiones compatibles</a></li>
<li><a href="#_políticas_de_actualización_y_soporte">Políticas de actualización y soporte</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_2_instalación_y_configuración">Módulo 2: Instalación y Configuración</a>
<ul class="sectlevel2">
<li><a href="#_2_1_requisitos_del_sistema">2.1 Requisitos del sistema</a>
<ul class="sectlevel3">
<li><a href="#_requisitos_de_hardware_y_software">Requisitos de hardware y software</a></li>
<li><a href="#_configuraciones_de_red_necesarias">Configuraciones de red necesarias</a></li>
<li><a href="#_compatibilidad_con_proveedores_cloud">Compatibilidad con proveedores cloud</a></li>
<li><a href="#_requisitos_para_entornos_air_gapped">Requisitos para entornos air-gapped</a></li>
</ul>
</li>
<li><a href="#_2_2_instalación_de_rancher">2.2 Instalación de Rancher</a>
<ul class="sectlevel3">
<li><a href="#_instalación_con_helm">Instalación con Helm</a></li>
<li><a href="#_instalación_con_docker_desarrollo">Instalación con Docker (desarrollo)</a></li>
<li><a href="#_configuración_de_certificados_ssl">Configuración de certificados SSL</a></li>
<li><a href="#_configuración_inicial_del_servidor">Configuración inicial del servidor</a></li>
</ul>
</li>
<li><a href="#_2_3_configuración_del_entorno">2.3 Configuración del entorno</a>
<ul class="sectlevel3">
<li><a href="#_configuración_de_autenticación">Configuración de autenticación</a></li>
<li><a href="#_integración_con_proveedores_de_identidad_ldap_saml_oidc">Integración con proveedores de identidad (LDAP, SAML, OIDC)</a></li>
<li><a href="#_configuración_de_notificaciones">Configuración de notificaciones</a></li>
<li><a href="#_backup_y_restauración_del_servidor_rancher">Backup y restauración del servidor Rancher</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_3_gestión_de_clústeres_kubernetes">Módulo 3: Gestión de Clústeres Kubernetes</a>
<ul class="sectlevel2">
<li><a href="#_3_1_creación_de_nuevos_clústeres">3.1 Creación de nuevos clústeres</a>
<ul class="sectlevel3">
<li><a href="#_creación_de_clústeres_rke_rancher_kubernetes_engine">Creación de clústeres RKE (Rancher Kubernetes Engine)</a></li>
<li><a href="#_configuración_de_nodos_y_roles">Configuración de nodos y roles</a></li>
<li><a href="#_personalización_de_versiones_de_kubernetes">Personalización de versiones de Kubernetes</a></li>
<li><a href="#_configuración_de_networking_y_cni">Configuración de networking y CNI</a></li>
<li><a href="#_backup_y_restauración_de_clústeres">Backup y restauración de clústeres</a></li>
<li><a href="#_monitoreo_del_estado_de_salud">Monitoreo del estado de salud</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_4_seguridad_y_gobernanza">Módulo 4: Seguridad y Gobernanza</a>
<ul class="sectlevel2">
<li><a href="#_4_1_gestión_de_usuarios_y_roles">4.1 Gestión de usuarios y roles</a>
<ul class="sectlevel3">
<li><a href="#_sistema_de_autenticación_y_autorización">Sistema de autenticación y autorización</a></li>
<li><a href="#_roles_globales_vs_roles_de_clúster">Roles globales vs roles de clúster</a></li>
<li><a href="#_políticas_de_rbac_avanzadas">Políticas de RBAC avanzadas</a></li>
<li><a href="#_gestión_de_proyectos_y_namespaces">Gestión de proyectos y namespaces</a></li>
</ul>
</li>
<li><a href="#_4_2_políticas_de_seguridad">4.2 Políticas de seguridad</a>
<ul class="sectlevel3">
<li><a href="#_pod_security_standards">Pod Security Standards</a></li>
<li><a href="#_network_policies">Network Policies</a></li>
<li><a href="#_gestión_de_secrets_y_certificados">Gestión de secrets y certificados</a></li>
<li><a href="#_configuración_de_opa_gatekeeper">Configuración de OPA Gatekeeper</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_5_gestión_de_aplicaciones">Módulo 5: Gestión de Aplicaciones</a>
<ul class="sectlevel2">
<li><a href="#_5_1_rancher_apps_marketplace">5.1 Rancher Apps &amp; Marketplace</a>
<ul class="sectlevel3">
<li><a href="#_catálogo_de_aplicaciones_integrado">Catálogo de aplicaciones integrado</a></li>
<li><a href="#_instalación_de_aplicaciones_desde_helm_charts">Instalación de aplicaciones desde Helm charts</a></li>
<li><a href="#_gestión_de_versiones_y_actualizaciones">Gestión de versiones y actualizaciones</a></li>
<li><a href="#_creación_de_repositorios_personalizados">Creación de repositorios personalizados</a></li>
</ul>
</li>
<li><a href="#_5_2_workloads_y_servicios">5.2 Workloads y servicios</a>
<ul class="sectlevel3">
<li><a href="#_gestión_de_deployments_statefulsets_y_daemonsets">Gestión de Deployments, StatefulSets y DaemonSets</a></li>
<li><a href="#_configuración_de_services_e_ingress">Configuración de Services e Ingress</a></li>
<li><a href="#_gestión_de_configmaps_y_secrets">Gestión de ConfigMaps y Secrets</a></li>
<li><a href="#_health_checks_y_probes">Health checks y probes</a></li>
</ul>
</li>
<li><a href="#_5_3_almacenamiento_y_networking">5.3 Almacenamiento y networking</a>
<ul class="sectlevel3">
<li><a href="#_configuración_de_storage_classes">Configuración de Storage Classes</a></li>
<li><a href="#_gestión_de_persistent_volumes">Gestión de Persistent Volumes</a></li>
<li><a href="#_configuración_de_networking_avanzada">Configuración de networking avanzada</a></li>
<li><a href="#_configuración_avanzada_de_networking">Configuración avanzada de networking</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_6_monitoreo_y_observabilidad">Módulo 6: Monitoreo y Observabilidad</a>
<ul class="sectlevel2">
<li><a href="#_6_1_rancher_monitoring">6.1 Rancher Monitoring</a>
<ul class="sectlevel3">
<li><a href="#_instalación_y_configuración_de_monitoring_stack">Instalación y configuración de monitoring stack</a></li>
<li><a href="#_métricas_de_clúster_y_aplicaciones">Métricas de clúster y aplicaciones</a></li>
<li><a href="#_alertas_y_notificaciones">Alertas y notificaciones</a></li>
<li><a href="#_dashboards_personalizados">Dashboards personalizados</a></li>
</ul>
</li>
<li><a href="#_6_2_logging">6.2 Logging</a>
<ul class="sectlevel3">
<li><a href="#_configuración_de_logging_centralizado">Configuración de logging centralizado</a></li>
<li><a href="#_integración_con_elasticsearch_y_fluentd">Integración con Elasticsearch y Fluentd</a></li>
<li><a href="#_búsqueda_y_análisis_de_logs">Búsqueda y análisis de logs</a></li>
<li><a href="#_políticas_de_retención">Políticas de retención</a></li>
</ul>
</li>
<li><a href="#_6_3_troubleshooting">6.3 Troubleshooting</a>
<ul class="sectlevel3">
<li><a href="#_diagnóstico_de_problemas_comunes">Diagnóstico de problemas comunes</a></li>
<li><a href="#_herramientas_de_debugging">Herramientas de debugging</a></li>
<li><a href="#_análisis_de_rendimiento">Análisis de rendimiento</a></li>
<li><a href="#_estrategias_de_resolución_de_incidentes">Estrategias de resolución de incidentes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_rke2_cluster_con_rolling_update">RKE2 Cluster con Rolling Update</a></li>
<li><a href="#_estrategia_blue_green_con_rancher">Estrategia Blue-Green con Rancher</a></li>
<li><a href="#_blue_environment_actual">Blue Environment (actual)</a></li>
<li><a href="#_green_environment_new_version_standby">Green Environment (new version - standby)</a></li>
<li><a href="#_service_que_apunta_a_blue_inicialmente">Service que apunta a Blue inicialmente</a></li>
<li><a href="#_canary_deployment_con_istio_recomendado">Canary Deployment con Istio (recomendado)</a></li>
<li><a href="#_pre_upgrade_validation">Pre-upgrade validation</a></li>
<li><a href="#_snapshot_actual_para_rollback">Snapshot actual para rollback</a></li>
<li><a href="#_esperar_a_que_se_complete_el_backup">Esperar a que se complete el backup</a></li>
<li><a href="#_drain_nodos_worker_no_control_plane">Drain nodos worker (NO control plane)</a></li>
<li><a href="#_actualizar_rancher_via_helm">Actualizar Rancher via Helm</a></li>
<li><a href="#_verificar_rollout">Verificar rollout</a></li>
<li><a href="#_verificar_health_de_rancher">Verificar health de Rancher</a></li>
<li><a href="#_uncordon_worker_nodes">Uncordon worker nodes</a></li>
<li><a href="#_validación_post_upgrade">Validación post-upgrade</a></li>
<li><a href="#_ver_histórico_de_releases">Ver histórico de releases</a></li>
<li><a href="#_rollback_a_la_release_anterior">Rollback a la release anterior</a></li>
<li><a href="#_verificar_rollback">Verificar rollback</a></li>
<li><a href="#_validación_post_rollback">Validación post-rollback</a></li>
<li><a href="#_test_connectivity">Test connectivity</a></li>
<li><a href="#_listar_backups_disponibles">Listar backups disponibles</a></li>
<li><a href="#_seleccionar_backup_pre_upgrade">Seleccionar backup pre-upgrade</a></li>
<li><a href="#_crear_restore_job">Crear restore job</a></li>
<li><a href="#_monitorear_restore">Monitorear restore</a></li>
<li><a href="#_verificar_estado">Verificar estado</a></li>
<li><a href="#_version_management_planning_document">Version management planning document</a></li>
<li><a href="#_rancher_deployment_con_resource_requestslimits_optimizados">Rancher Deployment con resource requests/limits optimizados</a></li>
<li><a href="#_resourcequota_para_limitar_uso_en_namespaces">ResourceQuota para limitar uso en namespaces</a></li>
<li><a href="#_limitrange_para_defaults_en_pods">LimitRange para defaults en pods</a></li>
<li><a href="#_hpa_basado_en_cpu_y_memoria">HPA basado en CPU y memoria</a>
<ul class="sectlevel2">
<li><a href="#_7_3_1_troubleshooting_de_performance">7.3.1 Troubleshooting de performance</a></li>
<li><a href="#_7_3_2_capacity_planning">7.3.2 Capacity planning</a></li>
<li><a href="#_7_3_3_cost_monitoring">7.3.3 Cost monitoring</a></li>
</ul>
</li>
<li><a href="#_recursos_adicionales">Recursos Adicionales</a>
<ul class="sectlevel2">
<li><a href="#_documentación_oficial">Documentación oficial</a></li>
<li><a href="#_comunidades_y_soporte">Comunidades y soporte</a></li>
<li><a href="#_certificaciones">Certificaciones</a></li>
<li><a href="#_herramientas_recomendadas">Herramientas recomendadas</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_módulo_1_introducción_a_rancher">Módulo 1: Introducción a Rancher</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_1_1_qué_es_rancher">1.1 ¿Qué es Rancher?</h3>
<div class="paragraph">
<p>Rancher es una plataforma completa de gestión de contenedores y Kubernetes que simplifica la implementación, gestión y operación de clústeres Kubernetes en cualquier infraestructura. Desarrollada por Rancher Labs (adquirida por SUSE en 2020), Rancher se ha convertido en una de las soluciones más populares para organizaciones que buscan adoptar y escalar Kubernetes de manera efectiva.</p>
</div>
<div class="sect3">
<h4 id="_historia_y_evolución_de_rancher">Historia y evolución de Rancher</h4>
<div class="paragraph">
<p>La evolución de Rancher ha marcado hitos importantes en la gestión de contenedores:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Cronología de Rancher:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Año</th>
<th class="tableblock halign-left valign-top">Evento</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2014</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fundación de Rancher Labs por Sheng Liang, Shannon Williams y Darren Shepherd</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2015</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lanzamiento de Rancher 1.0, enfocado en orquestación multi-plataforma (Swarm, Mesos, Kubernetes)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2016</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Introducción de Rancher Compose y soporte mejorado para múltiples orquestadores</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2018</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lanzamiento de Rancher 2.0, rediseñado completamente para centrarse 100% en Kubernetes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2019</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Introducción de RKE (Rancher Kubernetes Engine) y K3s (Kubernetes ligero)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2020</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Adquisición de Rancher Labs por SUSE por $600-700 millones</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2021</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lanzamiento de Rancher Desktop y mejoras en multi-clúster</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2022</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Introducción de Rancher Prime (versión empresarial con soporte extendido)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2023-2024</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integración profunda con el ecosistema SUSE, mejoras en seguridad y compliance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2025</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rancher Manager 2.9 con características avanzadas de IA/ML y edge computing</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<div class="title">Evolución arquitectónica:</div>
<ul>
<li>
<p><strong>Rancher 1.x</strong>: Soportaba múltiples orquestadores (Cattle, Kubernetes, Swarm, Mesos)</p>
</li>
<li>
<p><strong>Rancher 2.x</strong>: Rediseño completo centrado exclusivamente en Kubernetes</p>
</li>
<li>
<p><strong>Rancher Prime</strong>: Versión empresarial con soporte comercial y características adicionales</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_arquitectura_y_componentes_principales">Arquitectura y componentes principales</h4>
<div class="paragraph">
<p>Rancher está diseñado con una arquitectura modular que permite gestionar múltiples clústeres Kubernetes desde una única interfaz.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="rancher-architecture.png" alt="rancher architecture" width="1137" height="674">
</div>
<div class="title">Figure 1. Diagrama de arquitectura de Rancher</div>
</div>
<div class="paragraph">
<div class="title">Componentes principales del servidor Rancher:</div>
<p><strong>1. Rancher API Server</strong>
* Punto de entrada para todas las operaciones de gestión
* Interfaz web y API RESTful
* Gestión de autenticación y autorización
* Proxy para acceso a clústeres downstream</p>
</div>
<div class="paragraph">
<p><strong>2. Authentication Provider</strong>
* Integración con proveedores de identidad externos
* Soporte para LDAP, Active Directory, SAML, OAuth
* Gestión de tokens y sesiones
* RBAC (Role-Based Access Control)</p>
</div>
<div class="paragraph">
<p><strong>3. Cluster Controllers</strong>
* Gestión del ciclo de vida de clústeres
* Sincronización de estado
* Health checking
* Comunicación con cluster agents</p>
</div>
<div class="paragraph">
<p><strong>4. etcd</strong>
* Almacenamiento de estado del servidor Rancher
* Configuración de clústeres
* Datos de usuarios y permisos
* Metadatos de aplicaciones</p>
</div>
<div class="paragraph">
<div class="title">Componentes en clústeres downstream:</div>
<p><strong>1. Cluster Agent</strong>
* Comunicación bidireccional con el servidor Rancher
* Sincronización de recursos
* Ejecución de comandos
* Reporte de métricas</p>
</div>
<div class="paragraph">
<p><strong>2. Node Agent</strong>
* Desplegado en cada nodo del clúster
* Gestión de recursos del nodo
* Monitoreo de estado
* Ejecución de tareas de mantenimiento</p>
</div>
<div class="paragraph">
<p><strong>3. Fleet Agent (opcional)</strong>
* Gestión de despliegues GitOps
* Sincronización de repositorios Git
* Multi-cluster deployments</p>
</div>
</div>
<div class="sect3">
<h4 id="_comparación_con_otras_plataformas_de_gestión_kubernetes">Comparación con otras plataformas de gestión Kubernetes</h4>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Comparativa de plataformas de gestión Kubernetes</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Característica</th>
<th class="tableblock halign-left valign-top">Rancher</th>
<th class="tableblock halign-left valign-top">OpenShift</th>
<th class="tableblock halign-left valign-top">Tanzu</th>
<th class="tableblock halign-left valign-top">Lens</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tipo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Plataforma completa</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PaaS completa</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Suite empresarial</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Desktop IDE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Código abierto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí (Community)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí (OKD)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí (Parcial)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi-clúster</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Excelente</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Bueno</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Bueno</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Básico</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi-cloud</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Nativo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Bueno</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Limitado</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Básico</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Curva de aprendizaje</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Media</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alta</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alta</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Baja</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cost</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gratuito/Suscripción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Suscripción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Suscripción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gratuito/Pro</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integración CI/CD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fleet, Pipelines</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jenkins, Tekton</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Concourse</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limitado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Marketplace</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Helm Charts</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Operators</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tanzu Solutions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Helm Charts</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Edge Computing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">K3s integrado</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Microshift</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limitado</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Soporte comercial</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SUSE Rancher Prime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Red Hat</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VMware</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mirantis</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Ventajas de Rancher:</strong>
* Interfaz intuitiva y fácil de usar
* Soporte para cualquier distribución de Kubernetes (EKS, AKS, GKE, RKE, K3s)
* Gestión multi-clúster desde una única consola
* Amplio ecosistema y comunidad activa
* Flexibilidad para entornos híbridos y multi-cloud
* K3s para edge computing y IoT</p>
</div>
<div class="paragraph">
<p><strong>Desventajas comparativas:</strong>
* Menos características enterprise que OpenShift
* Requiere gestión del servidor Rancher adicional
* Menor integración con CI/CD nativo comparado con OpenShift</p>
</div>
</div>
<div class="sect3">
<h4 id="_casos_de_uso_y_beneficios_empresariales">Casos de uso y beneficios empresariales</h4>
<div class="paragraph">
<div class="title">Casos de uso principales:</div>
<p><strong>1. Gestión Multi-Clúster</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Escenario: Empresa con clústeres en AWS, Azure y on-premises
Beneficio: Gestión unificada desde una única interfaz
Resultado: Reducción del 60% en tiempo de operaciones</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. Migración a Kubernetes</strong>
* Importación gradual de clústeres existentes
* Estandarización de operaciones
* Formación de equipos con interfaz unificada
* Reducción de curva de aprendizaje</p>
</div>
<div class="paragraph">
<p><strong>3. Edge Computing e IoT</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">Arquitectura típica:
- Datacenter central: Rancher Management Server
- Edge locations: K3s clusters (50-100 sites)
- Gestión centralizada con Fleet
- Despliegues automatizados vía GitOps</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>4. Entornos de desarrollo y testing</strong>
* Aprovisionamiento rápido de clústeres
* Catálogo de aplicaciones pre-configuradas
* Ambientes efímeros y reproducibles
* Integración con pipelines CI/CD</p>
</div>
<div class="paragraph">
<p><strong>5. Cumplimiento normativo y seguridad</strong>
* Políticas de seguridad centralizadas
* Auditoría y logging centralizado
* Escaneo de vulnerabilidades
* Compliance automatizado (CIS benchmarks)</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Beneficios empresariales cuantificables:</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 50%;">
<col style="width: 16.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Beneficio</th>
<th class="tableblock halign-left valign-top">Descripción</th>
<th class="tableblock halign-left valign-top">Impacto</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reducción de costos operativos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gestión centralizada reduce personal necesario</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30-50%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Time to market</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Despliegue más rápido de aplicaciones</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">40-60%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reducción de errores</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Automatización y estandarización</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">70%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Utilización de recursos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mejor scheduling y optimización</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">25-35%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Seguridad mejorada</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Políticas centralizadas y auditoría</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Ejemplo real de implementación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Empresa: Retailer global con 500 tiendas
Desafío: Gestionar aplicaciones en cada ubicación
Solución: Rancher + K3s + Fleet
Resultados:
- 500 clústeres K3s gestionados desde un Rancher central
- Despliegues automatizados en &lt; 5 minutos
- Reducción de 80% en incidentes por configuración
- ROI positivo en 8 meses</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Industrias que se benefician especialmente:</strong>
* Retail y comercio electrónico
* Manufactura e industria 4.0
* Telecomunicaciones
* Servicios financieros
* Gobierno y sector público
* Educación e investigación</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_1_2_arquitectura_de_rancher">1.2 Arquitectura de Rancher</h3>
<div class="paragraph">
<p>La arquitectura de Rancher está diseñada para proporcionar una gestión centralizada y escalable de múltiples clústeres Kubernetes. Comprender esta arquitectura es fundamental para implementar y operar Rancher de manera efectiva.</p>
</div>
<div class="sect3">
<h4 id="_componentes_del_plano_de_control">Componentes del plano de control</h4>
<div class="paragraph">
<p>El plano de control de Rancher consiste en varios componentes que trabajan juntos para gestionar la infraestructura de Kubernetes.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="rancher-control-plane.png" alt="rancher control plane" width="934" height="781">
</div>
<div class="title">Figure 2. Arquitectura detallada del plano de control</div>
</div>
<div class="paragraph">
<p><strong>1. Rancher API Server</strong></p>
</div>
<div class="paragraph">
<p>El API Server es el núcleo del plano de control y maneja todas las interacciones con Rancher.</p>
</div>
<div class="ulist">
<div class="title">Funciones principales:</div>
<ul>
<li>
<p><strong>REST API</strong>: Interfaz principal para operaciones CRUD</p>
</li>
<li>
<p><strong>WebSocket</strong>: Comunicación en tiempo real con la UI y cluster agents</p>
</li>
<li>
<p><strong>Proxy</strong>: Redirige peticiones a clústeres downstream</p>
</li>
<li>
<p><strong>Validación</strong>: Valida todas las peticiones entrantes</p>
</li>
<li>
<p><strong>Autenticación</strong>: Integra con proveedores de identidad</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Endpoints principales:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">/v3/clusters              - Gestión de clústeres
/v3/projects              - Gestión de proyectos
/v3/users                 - Gestión de usuarios
/v3/catalogs              - Catálogos de aplicaciones
/k8s/clusters/&lt;id&gt;        - Proxy a Kubernetes API</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>2. Management Controllers</strong></p>
</div>
<div class="paragraph">
<p>Los controladores gestionan el estado deseado vs el estado actual de los recursos.</p>
</div>
<div class="listingblock">
<div class="title">Cluster Controller:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">Responsabilidades:
  - Provisioning de nuevos clústeres
  - Sincronización de estado
  - Health checking
  - Actualización de versiones
  - Gestión de nodos</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">User &amp; RBAC Controller:</div>
<ul>
<li>
<p>Sincroniza usuarios y permisos</p>
</li>
<li>
<p>Gestiona roles globales y de clúster</p>
</li>
<li>
<p>Propaga cambios de RBAC a clústeres downstream</p>
</li>
<li>
<p>Mantiene consistencia de permisos</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Project Controller:</div>
<ul>
<li>
<p>Gestiona el concepto de "Project" (agrupación de namespaces)</p>
</li>
<li>
<p>Aplica políticas a nivel de proyecto</p>
</li>
<li>
<p>Gestiona cuotas de recursos por proyecto</p>
</li>
<li>
<p>Controla el acceso multiusuario</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>3. Authentication &amp; Authorization</strong></p>
</div>
<div class="paragraph">
<p>Sistema de autenticación modular que soporta múltiples proveedores.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="rancher-auth-flow.png" alt="rancher auth flow" width="629" height="362">
</div>
<div class="title">Figure 3. Flujo de autenticación:</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Proveedores soportados:</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 42.8571%;">
<col style="width: 28.5715%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Provider</th>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Uso común</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Username/Password</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dev/Testing</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active Directory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enterprise Windows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenLDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enterprise Linux</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Azure AD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SAML 2.0 / OAuth</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Microsoft cloud</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Okta</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SAML 2.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Identity management</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keycloak</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OIDC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Open source SSO</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GitHub</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OAuth 2.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Developer teams</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Google</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OAuth 2.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">G Suite orgs</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>4. etcd Cluster</strong></p>
</div>
<div class="paragraph">
<p>Base de datos distribuida que almacena todo el estado de Rancher.</p>
</div>
<div class="listingblock">
<div class="title">Datos almacenados:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Clusters:
  - Configuración de clústeres downstream
  - Estado de conexión
  - Credenciales de acceso

Users &amp; Auth:
  - Usuarios y tokens
  - Configuración de auth providers
  - Políticas RBAC

Catalogs:
  - Repositorios Helm
  - Apps instaladas
  - Versiones disponibles

Settings:
  - Configuración global
  - Feature flags
  - Telemetría</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Requisitos de etcd:</div>
<ul>
<li>
<p>Mínimo 3 nodos para HA</p>
</li>
<li>
<p>SSD storage recomendado</p>
</li>
<li>
<p>Backup automático cada 12 horas</p>
</li>
<li>
<p>Snapshots antes de upgrades</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_arquitectura_multi_clúster">Arquitectura multi-clúster</h4>
<div class="paragraph">
<p>Rancher gestiona múltiples clústeres Kubernetes mediante una arquitectura hub-and-spoke.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="rancher-hub-spoke.png" alt="rancher hub spoke" width="1328" height="426">
</div>
<div class="title">Figure 4. Modelo hub-and-spoke</div>
</div>
<div class="paragraph">
<p><strong>Tipos de clústeres en Rancher:</strong></p>
</div>
<div class="paragraph">
<p><strong>1. Local Cluster (Management Cluster)</strong>
* Clúster donde corre Rancher Server
* No debería usarse para workloads de aplicaciones
* Solo para componentes de gestión de Rancher
* Alta disponibilidad crítica</p>
</div>
<div class="paragraph">
<p><strong>2. Downstream Clusters (Managed Clusters)</strong>
* Clústeres gestionados por Rancher
* Pueden ser importados o creados por Rancher
* Ejecutan workloads de aplicaciones
* Tipos:
  <strong> </strong>RKE Clusters<strong>: Creados por Rancher Kubernetes Engine
  </strong> <strong>Imported Clusters</strong>: EKS, AKS, GKE, etc.
  <strong> </strong>Hosted Clusters<strong>: Creados en cloud providers
  </strong> <strong>Custom Clusters</strong>: On-premises con nodos propios</p>
</div>
<div class="paragraph">
<p><strong>3. Arquitectura de agentes en clústeres downstream</strong></p>
</div>
<div class="listingblock">
<div class="title">Cluster Agent:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">Deployment: cattle-cluster-agent
Namespace: cattle-system
Responsabilidades:
  - Comunicación bidireccional con Rancher Server
  - Sincronización de recursos (Projects, Users, RBAC)
  - Ejecución de comandos remotos
  - Reporte de métricas y eventos
  - Túnel para kubectl proxy

Configuración:
  replicas: 1
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    limits:
      cpu: 500m
      memory: 512Mi</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Node Agent (rancher-agent):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">DaemonSet: cattle-node-agent
Namespace: cattle-system
Responsabilidades:
  - Health check de nodos
  - Recolección de métricas del nodo
  - Ejecución de comandos en el nodo
  - Gestión de logs

Configuración:
  hostNetwork: true
  hostPID: true
  privileged: true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comunicación_entre_componentes">Comunicación entre componentes</h4>
<div class="paragraph">
<p>La comunicación segura entre componentes es esencial para la arquitectura de Rancher.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="rancher-communication.png" alt="rancher communication" width="683" height="566">
</div>
<div class="title">Figure 5. Flujo de comunicación completo</div>
</div>
<div class="paragraph">
<p><strong>1. Protocolos de comunicación</strong></p>
</div>
<div class="ulist">
<div class="title">User → Rancher Server:</div>
<ul>
<li>
<p><strong>HTTPS</strong>: REST API calls (puerto 443)</p>
</li>
<li>
<p><strong>WSS</strong>: WebSocket para UI en tiempo real</p>
</li>
<li>
<p><strong>Autenticación</strong>: Token bearer o session cookie</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Rancher Server → Cluster Agent:</div>
<ul>
<li>
<p><strong>WebSocket</strong>: Conexión bidireccional persistente</p>
</li>
<li>
<p><strong>Iniciado por</strong>: Cluster Agent (outbound desde el clúster)</p>
</li>
<li>
<p><strong>Puerto</strong>: 443 (HTTPS)</p>
</li>
<li>
<p><strong>Ventaja</strong>: No requiere inbound al clúster</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Cluster Agent → Kubernetes API:</div>
<ul>
<li>
<p><strong>HTTPS</strong>: REST API</p>
</li>
<li>
<p><strong>Puerto</strong>: 6443 (típicamente)</p>
</li>
<li>
<p><strong>Auth</strong>: ServiceAccount token</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>2. Modelo de seguridad</strong></p>
</div>
<div class="listingblock">
<div class="title">Certificados y TLS:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">Rancher Server:
  - Certificado TLS para acceso HTTPS
  - Puede usar Let's Encrypt automático
  - O certificados personalizados/privados

Cluster Agents:
  - Validan certificado del Rancher Server
  - Usan tokens de registro para autenticación inicial
  - Posteriormente usan tokens rotativos

Comunicación interna:
  - Todo el tráfico encriptado con TLS 1.2+
  - Mutual TLS entre agentes y server
  - Tokens JWT para autenticación</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>3. Modelo de túnel inverso</strong></p>
</div>
<div class="paragraph">
<p>Una de las características clave de Rancher es el túnel inverso que elimina la necesidad de exponer clústeres downstream.</p>
</div>
<div class="ulist">
<div class="title">Ventajas del túnel inverso:</div>
<ul>
<li>
<p>No requiere abrir puertos de entrada en clústeres</p>
</li>
<li>
<p>Cluster Agents inician conexiones outbound (puerto 443)</p>
</li>
<li>
<p>Firewall-friendly para entornos corporativos</p>
</li>
<li>
<p>Funciona en entornos con NAT y proxies</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Configuración de proxy para cluster agent:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: cattle-proxy
  namespace: cattle-system
data:
  HTTP_PROXY: "http://proxy.example.com:8080"
  HTTPS_PROXY: "http://proxy.example.com:8080"
  NO_PROXY: "localhost,127.0.0.1,10.0.0.0/8"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_alta_disponibilidad_y_escalabilidad">Alta disponibilidad y escalabilidad</h4>
<div class="paragraph">
<p>Para entornos de producción, Rancher debe desplegarse en configuración de alta disponibilidad.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="rancher-ha.png" alt="rancher ha" width="785" height="599">
</div>
<div class="title">Figure 6. Arquitectura de alta disponibilidad</div>
</div>
<div class="paragraph">
<p><strong>1. Requisitos de alta disponibilidad</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Configuración mínima de HA:</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 42.8571%;">
<col style="width: 28.5715%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Componente</th>
<th class="tableblock halign-left valign-top">Requisito</th>
<th class="tableblock halign-left valign-top">Recomendación</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nodos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mínimo 3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5 para mejor tolerancia</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPU por nodo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 cores</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 cores</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RAM por nodo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16 GB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Disco (etcd)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50 GB SSD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100 GB NVMe</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Load Balancer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Layer 4 o Layer 7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Layer 7 con health checks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Red</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 Gbps</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 Gbps</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>2. Configuración de HA con RKE</strong></p>
</div>
<div class="listingblock">
<div class="title">cluster.yml para despliegue HA:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">nodes:
  - address: 10.0.0.10
    hostname_override: rancher-1
    user: ubuntu
    role:
      - controlplane
      - etcd
      - worker

  - address: 10.0.0.11
    hostname_override: rancher-2
    user: ubuntu
    role:
      - controlplane
      - etcd
      - worker

  - address: 10.0.0.12
    hostname_override: rancher-3
    user: ubuntu
    role:
      - controlplane
      - etcd
      - worker

services:
  etcd:
    backup_config:
      enabled: true
      interval_hours: 12
      retention: 6
      s3_backup_config:
        access_key: "your-access-key"
        bucket_name: "rancher-backups"
        endpoint: "s3.amazonaws.com"
        region: "us-west-2"

    snapshot: true
    creation: 12h
    retention: 72h

  kube-api:
    service_cluster_ip_range: 10.43.0.0/16
    service_node_port_range: 30000-32767
    pod_security_policy: false

  kube-controller:
    cluster_cidr: 10.42.0.0/16
    service_cluster_ip_range: 10.43.0.0/16

  kubelet:
    cluster_domain: cluster.local
    cluster_dns_server: 10.43.0.10
    fail_swap_on: false

network:
  plugin: canal
  options:
    flannel_backend_type: vxlan

ingress:
  provider: nginx
  options:
    use-forwarded-headers: "true"

# Certificados
certificates:
  - CN: rancher.example.com
    hosts:
      - rancher.example.com
      - 10.0.0.10
      - 10.0.0.11
      - 10.0.0.12</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>3. Configuración del Load Balancer</strong></p>
</div>
<div class="listingblock">
<div class="title">NGINX como Load Balancer (Layer 4):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-nginx hljs" data-lang="nginx">stream {
    upstream rancher_servers {
        least_conn;
        server 10.0.0.10:443 max_fails=3 fail_timeout=5s;
        server 10.0.0.11:443 max_fails=3 fail_timeout=5s;
        server 10.0.0.12:443 max_fails=3 fail_timeout=5s;
    }

    server {
        listen 443;
        proxy_pass rancher_servers;
        proxy_timeout 900s;
        proxy_connect_timeout 15s;
    }

    upstream rancher_servers_http {
        least_conn;
        server 10.0.0.10:80 max_fails=3 fail_timeout=5s;
        server 10.0.0.11:80 max_fails=3 fail_timeout=5s;
        server 10.0.0.12:80 max_fails=3 fail_timeout=5s;
    }

    server {
        listen 80;
        proxy_pass rancher_servers_http;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">HAProxy como Load Balancer:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-haproxy hljs" data-lang="haproxy">global
    log /dev/log local0
    log /dev/log local1 notice
    maxconn 4096

defaults
    log global
    mode tcp
    option tcplog
    option dontlognull
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms

frontend rancher_https
    bind *:443
    mode tcp
    default_backend rancher_backend_https

backend rancher_backend_https
    mode tcp
    balance roundrobin
    option httpchk GET /healthz
    http-check expect status 200
    server rancher1 10.0.0.10:443 check
    server rancher2 10.0.0.11:443 check
    server rancher3 10.0.0.12:443 check

frontend rancher_http
    bind *:80
    mode tcp
    default_backend rancher_backend_http

backend rancher_backend_http
    mode tcp
    balance roundrobin
    server rancher1 10.0.0.10:80 check
    server rancher2 10.0.0.11:80 check
    server rancher3 10.0.0.12:80 check</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>4. Estrategias de escalabilidad</strong></p>
</div>
<div class="ulist">
<div class="title">Escalabilidad vertical (Scale Up):</div>
<ul>
<li>
<p>Aumentar recursos de nodos existentes</p>
</li>
<li>
<p>Útil hasta cierto límite</p>
</li>
<li>
<p>Requiere downtime para cada nodo</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Escalabilidad horizontal (Scale Out):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Añadir nodos al clúster RKE
# 1. Añadir nodo al cluster.yml
# 2. Ejecutar RKE
rke up --config cluster.yml

# Para Rancher en Kubernetes
kubectl scale deployment rancher -n cattle-system --replicas=5</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Límites de escalabilidad:</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Recurso</th>
<th class="tableblock halign-left valign-top">Límite</th>
<th class="tableblock halign-left valign-top">Notas</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clústeres downstream</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2000+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Depende de recursos</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nodos totales gestionados</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100,000+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Distribuidos en clústeres</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usuarios concurrentes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10,000+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Con HA adecuado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Projects</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ilimitados</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Por lógica de namespace</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Workloads por clúster</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15,000+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Límite de Kubernetes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>5. Monitoreo de HA</strong></p>
</div>
<div class="listingblock">
<div class="title">Métricas clave a monitorear:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">Rancher Server:
  - CPU/Memory utilization
  - Request latency
  - WebSocket connections
  - API error rates

etcd:
  - Latency de operaciones
  - Tamaño del database
  - Éxito de snapshots
  - Sync duration

Load Balancer:
  - Health check status
  - Connection count
  - Request distribution
  - Response times</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Health checks recomendados:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Check Rancher API
curl -k https://rancher.example.com/healthz

# Check etcd cluster
kubectl -n kube-system exec -it etcd-rancher-1 -- \
  etcdctl --endpoints=https://127.0.0.1:2379 \
  --cert=/etc/kubernetes/ssl/kube-etcd-*.pem \
  --key=/etc/kubernetes/ssl/kube-etcd-*-key.pem \
  --cacert=/etc/kubernetes/ssl/kube-ca.pem \
  endpoint health

# Check cluster connectivity
kubectl get nodes
kubectl get pods -n cattle-system</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_1_3_versiones_y_ediciones_de_rancher">1.3 Versiones y ediciones de Rancher</h3>
<div class="paragraph">
<p>Rancher ofrece diferentes ediciones y modelos de soporte para adaptarse a las necesidades de distintas organizaciones, desde proyectos de código abierto hasta implementaciones empresariales críticas.</p>
</div>
<div class="sect3">
<h4 id="_rancher_prime_vs_community_edition">Rancher Prime vs Community Edition</h4>
<div class="paragraph">
<p>SUSE ofrece dos ediciones principales de Rancher, cada una diseñada para diferentes escenarios de uso y niveles de soporte.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. Comparativa entre ediciones</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 37.5%;">
<col style="width: 37.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Característica</th>
<th class="tableblock halign-left valign-top">Rancher Prime</th>
<th class="tableblock halign-left valign-top">Community Edition</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Licencia</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Suscripción comercial SUSE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apache 2.0 (Open Source)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Código fuente</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mismo código base</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mismo código base</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Soporte técnico</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24x7x365 con SLA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comunidad (foros, Slack)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Actualizaciones</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Releases estables y LTS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Releases upstream</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Parches de seguridad</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Backports garantizados</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Best effort</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Ciclo de vida</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">18 meses soporte estándar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6 meses típico</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Soporte LTS</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hasta 24 meses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No disponible</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Certificación</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Certificado para producción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sin certificación formal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Documentación</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Guías empresariales + KB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Documentación pública</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Training</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cursos oficiales incluidos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recursos comunitarios</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Compliance</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CVE tracking y reportes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comunitario</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Precio</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Por nodo/clúster gestionado</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gratuito</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Rancher Prime (Suscripción Empresarial)</strong></p>
</div>
<div class="paragraph">
<p>Rancher Prime es la versión empresarial con soporte comercial completo de SUSE.</p>
</div>
<div class="ulist">
<div class="title">Beneficios clave:</div>
<ul>
<li>
<p><strong>Soporte técnico premium</strong>: 24x7x365 con tiempos de respuesta garantizados por SLA</p>
</li>
<li>
<p><strong>Lifecycle extendido</strong>: Soporte hasta 24 meses por versión LTS</p>
</li>
<li>
<p><strong>Parches de seguridad</strong>: CVE patches backported a versiones soportadas</p>
</li>
<li>
<p><strong>Certificación y compliance</strong>: Validado para entornos regulados</p>
</li>
<li>
<p><strong>Roadmap prioritario</strong>: Influencia en el desarrollo futuro</p>
</li>
<li>
<p><strong>Professional services</strong>: Acceso a servicios de consultoría</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Niveles de soporte Prime:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Nivel</th>
<th class="tableblock halign-left valign-top">Respuesta P1</th>
<th class="tableblock halign-left valign-top">Respuesta P2</th>
<th class="tableblock halign-left valign-top">Disponibilidad</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Standard</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 horas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 horas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24x7</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Premium</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 hora</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 horas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24x7</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enterprise</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30 minutos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 horas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24x7 + TAM</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mission Critical</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15 minutos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 hora</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24x7 + TAM dedicado</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Modelo de precios (estimado):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Opción 1: Por nodo gestionado
  - $100-300 USD/nodo/año
  - Incluye todos los nodos en clústeres downstream

Opción 2: Por clúster
  - $5,000-15,000 USD/clúster/año
  - Sin límite de nodos por clúster

Opción 3: Unlimited
  - Precio negociado según volumen
  - Para &gt; 1000 nodos o &gt; 50 clústeres</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Rancher Community Edition</strong></p>
</div>
<div class="paragraph">
<p>Versión gratuita y de código abierto ideal para desarrollo, testing y organizaciones con capacidad interna de soporte.</p>
</div>
<div class="ulist">
<div class="title">Características:</div>
<ul>
<li>
<p>Todas las funcionalidades técnicas de Rancher</p>
</li>
<li>
<p>Actualizaciones frecuentes (mensual típicamente)</p>
</li>
<li>
<p>Soporte comunitario vía foros y Slack</p>
</li>
<li>
<p>Sin compromisos de SLA</p>
</li>
<li>
<p>Ideal para: Dev/Test, POCs, startups, homelab</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Limitaciones comparativas:</div>
<ul>
<li>
<p>Sin garantía de parches de seguridad backported</p>
</li>
<li>
<p>Ciclo de vida de soporte más corto</p>
</li>
<li>
<p>Sin acceso a training empresarial</p>
</li>
<li>
<p>Sin servicios profesionales incluidos</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>¿Cuándo elegir cada edición?</strong></p>
</div>
<div class="ulist">
<div class="title">Rancher Prime es recomendado para:</div>
<ul>
<li>
<p>Entornos de producción críticos</p>
</li>
<li>
<p>Organizaciones reguladas (finanzas, salud, gobierno)</p>
</li>
<li>
<p>Equipos pequeños sin expertise profundo en Kubernetes</p>
</li>
<li>
<p>Necesidad de compliance y auditoría</p>
</li>
<li>
<p>SLAs contractuales requeridos</p>
</li>
<li>
<p>Más de 3 clústeres en producción</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Community Edition es adecuado para:</div>
<ul>
<li>
<p>Entornos de desarrollo y testing</p>
</li>
<li>
<p>Equipos con fuerte expertise en Kubernetes</p>
</li>
<li>
<p>POCs y evaluaciones</p>
</li>
<li>
<p>Proyectos open source</p>
</li>
<li>
<p>Presupuesto limitado con recursos internos</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_matriz_de_soporte_y_versiones_compatibles">Matriz de soporte y versiones compatibles</h4>
<div class="paragraph">
<p>Rancher soporta múltiples versiones de Kubernetes y tiene un ciclo de vida de versiones bien definido.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. Matriz de compatibilidad Rancher 2.9.x (Oct 2025)</caption>
<colgroup>
<col style="width: 22.2222%;">
<col style="width: 33.3333%;">
<col style="width: 22.2222%;">
<col style="width: 22.2223%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Rancher Version</th>
<th class="tableblock halign-left valign-top">Kubernetes Versions</th>
<th class="tableblock halign-left valign-top">Release Date</th>
<th class="tableblock halign-left valign-top">EOL Date</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.9.3 (Latest)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.29.x, 1.28.x, 1.27.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Oct 2025</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apr 2027 (Prime)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.9.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.29.x, 1.28.x, 1.27.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aug 2025</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Feb 2027 (Prime)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.9.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.28.x, 1.27.x, 1.26.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jun 2025</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dec 2026 (Prime)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.9.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.28.x, 1.27.x, 1.26.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apr 2025</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Oct 2026 (Prime)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.8.7 (LTS)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.28.x, 1.27.x, 1.26.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mar 2025</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sep 2026 (Prime)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.8.6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.27.x, 1.26.x, 1.25.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jan 2025</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jul 2026 (Prime)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.7.x (Legacy)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.26.x, 1.25.x, 1.24.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2024</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EOL Mar 2025</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Soporte de Distribuciones Kubernetes</strong></p>
</div>
<div class="paragraph">
<p>Rancher es compatible con múltiples distribuciones y proveedores de Kubernetes.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. Distribuciones soportadas:</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Distribución</th>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Notas</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RKE (Rancher Kubernetes Engine)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nativo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creado y gestionado por Rancher</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RKE2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nativo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Certificado FIPS, CIS hardened</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">K3s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ligero</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Para edge, IoT, ARM</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Amazon EKS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cloud</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Importación y provisioning</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Azure AKS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cloud</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Importación y provisioning</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Google GKE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cloud</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Importación y provisioning</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Red Hat OpenShift</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enterprise</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Solo importación (limitado)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VMware Tanzu</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enterprise</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Importación</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vanilla Kubernetes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Custom</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cualquier instalación estándar</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Minikube/Kind</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dev</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Para desarrollo local</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Compatibilidad de componentes</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. Versiones mínimas requeridas (Rancher 2.9.x):</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Componente</th>
<th class="tableblock halign-left valign-top">Versión mínima</th>
<th class="tableblock halign-left valign-top">Recomendado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Docker</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20.10.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">containerd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.7.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.26.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.28.x o 1.29.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Helm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.14+</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubectl</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.26</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Matching K8s version</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">etcd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.5.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.5.10+</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cert-manager</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.11.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.14.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ingress NGINX</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.8.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.10.x</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Requisitos de navegadores web</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 12. Soporte de navegadores para Rancher UI:</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Navegador</th>
<th class="tableblock halign-left valign-top">Versión mínima</th>
<th class="tableblock halign-left valign-top">Notas</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Chrome</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">90+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recomendado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Firefox</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">88+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Totalmente soportado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Safari</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">14+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">macOS/iOS</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Edge (Chromium)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">90+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Totalmente soportado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Edge (Legacy)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No soportado</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_políticas_de_actualización_y_soporte">Políticas de actualización y soporte</h4>
<div class="paragraph">
<p>SUSE mantiene políticas claras sobre el ciclo de vida y soporte de las versiones de Rancher.</p>
</div>
<div class="paragraph">
<p><strong>Ciclo de vida de versiones</strong></p>
</div>
<div class="imageblock">
<div class="content">
<img src="rancher-lifecycle.png" alt="rancher lifecycle" width="494" height="750">
</div>
<div class="title">Figure 7. Fases del ciclo de vida</div>
</div>
<div class="paragraph">
<p><strong>Política de versiones semánticas</strong></p>
</div>
<div class="paragraph">
<p>Rancher sigue versionado semántico (SemVer): MAJOR.MINOR.PATCH</p>
</div>
<div class="listingblock">
<div class="title">Significado de cada nivel:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">MAJOR (2.x.x):
  - Cambios incompatibles en la API
  - Cambios arquitectónicos significativos
  - Requiere planificación de migración

MINOR (2.9.x):
  - Nuevas características compatibles
  - Mejoras de funcionalidad
  - Deprecations anunciadas

PATCH (2.9.3):
  - Bug fixes
  - Security patches
  - Sin cambios de funcionalidad</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cadencia de releases</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 13. Calendario típico de lanzamientos:</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Tipo de release</th>
<th class="tableblock halign-left valign-top">Frecuencia</th>
<th class="tableblock halign-left valign-top">Ejemplo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Major release</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">18-24 meses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0 → 2.x</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Minor release</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3-4 meses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.8 → 2.9</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Patch release</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2-4 semanas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.9.2 → 2.9.3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Security patch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">As needed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CVE response</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LTS release</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12 meses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.8 LTS</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Estrategia de actualización</strong></p>
</div>
<div class="listingblock">
<div class="title">Path de actualización recomendado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Regla general:
- Actualizar de PATCH a PATCH: Directo (ej: 2.9.1 → 2.9.3)
- Actualizar de MINOR a MINOR: Una versión (ej: 2.8.x → 2.9.x)
- Actualizar de MAJOR a MAJOR: Requiere planificación

Ejemplo de path correcto:
  2.7.9 → 2.8.5 → 2.9.3 ✓

Ejemplo de path incorrecto:
  2.7.9 → 2.9.3 ✗ (skip minor version)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Proceso de actualización recomendado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># 1. Backup del clúster Rancher
./rke-backup.sh

# 2. Verificar versión actual
kubectl -n cattle-system get deploy rancher -o jsonpath='{.spec.template.spec.containers[0].image}'

# 3. Revisar release notes
# https://github.com/rancher/rancher/releases

# 4. Actualizar Rancher via Helm
helm repo update
helm upgrade rancher rancher-stable/rancher \
  --namespace cattle-system \
  --version=2.9.3 \
  --reuse-values

# 5. Verificar actualización
kubectl -n cattle-system rollout status deploy/rancher
kubectl -n cattle-system get pods

# 6. Verificar funcionalidad
curl -k https://rancher.example.com/healthz</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Deprecations y removals</strong></p>
</div>
<div class="paragraph">
<p>SUSE anuncia deprecations con anticipación siguiendo esta política:</p>
</div>
<div class="ulist">
<div class="title">Política de deprecation:</div>
<ul>
<li>
<p><strong>Anuncio</strong>: Mínimo 2 minor releases antes de removal</p>
</li>
<li>
<p><strong>Warning</strong>: Logs y UI muestran advertencias</p>
</li>
<li>
<p><strong>Grace period</strong>: Mínimo 12 meses para Prime customers</p>
</li>
<li>
<p><strong>Migration guide</strong>: Documentación de migración provista</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 14. Ejemplo reciente de deprecations:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Feature</th>
<th class="tableblock halign-left valign-top">Deprecated</th>
<th class="tableblock halign-left valign-top">Removed</th>
<th class="tableblock halign-left valign-top">Alternativa</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Legacy Monitoring</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.7.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.9.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rancher Monitoring v2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rancher CLI v1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.8.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TBD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rancher CLI v2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Projects (partial)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TBD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TBD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Namespaces + RBAC</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cluster Templates</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.6.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.8.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fleet + GitOps</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Soporte de Kubernetes upstream</strong></p>
</div>
<div class="paragraph">
<p>Rancher soporta versiones de Kubernetes siguiendo la política oficial de Kubernetes.</p>
</div>
<div class="listingblock">
<div class="title">Política de soporte K8s:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Kubernetes mantiene:
  - 3 minor versions activas
  - ~14 meses de soporte por version

Rancher mantiene:
  - Mínimo 3 minor versions de K8s
  - Añade soporte de nuevas versiones en 30-60 días
  - Extiende soporte para Prime customers

Ejemplo (Oct 2025):
  K8s upstream soporta: 1.29, 1.28, 1.27
  Rancher 2.9 soporta: 1.29, 1.28, 1.27, 1.26 (extended)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Testing y certificación</strong></p>
</div>
<div class="ulist">
<div class="title">Proceso de certificación Prime:</div>
<ul>
<li>
<p>Testing en múltiples cloud providers</p>
</li>
<li>
<p>Validación de upgrade paths</p>
</li>
<li>
<p>Security scanning y penetration testing</p>
</li>
<li>
<p>Performance benchmarking</p>
</li>
<li>
<p>Compliance validation (CIS, FIPS, etc.)</p>
</li>
<li>
<p>Documentación de known issues</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Recursos de actualización</strong></p>
</div>
<div class="ulist">
<div class="title">Herramientas y documentación:</div>
<ul>
<li>
<p><strong>Release Notes</strong>: <a href="https://github.com/rancher/rancher/releases" class="bare">https://github.com/rancher/rancher/releases</a></p>
</li>
<li>
<p><strong>Upgrade Guide</strong>: Documentación oficial de SUSE</p>
</li>
<li>
<p><strong>Known Issues</strong>: KB articles por versión</p>
</li>
<li>
<p><strong>Compatibility Matrix</strong>: Tabla de compatibilidad actualizada</p>
</li>
<li>
<p><strong>Migration Tools</strong>: Scripts de migración si aplican</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Checklist pre-actualización:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-checklist hljs" data-lang="checklist">☐ Revisar release notes y breaking changes
☐ Verificar compatibilidad de Kubernetes versions
☐ Backup completo de Rancher server
☐ Backup de clústeres downstream críticos
☐ Verificar espacio en disco suficiente
☐ Programar ventana de mantenimiento
☐ Notificar a usuarios sobre downtime potencial
☐ Preparar rollback plan
☐ Verificar health de etcd cluster
☐ Documentar versiones actuales de todos los componentes
☐ Revisar custom configurations que puedan afectarse
☐ Testing en ambiente no-productivo primero</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Opciones de soporte técnico</strong></p>
</div>
<div class="ulist">
<div class="title">Canales de soporte Prime:</div>
<ul>
<li>
<p><strong>Portal web</strong>: Casos 24x7 con tracking</p>
</li>
<li>
<p><strong>Teléfono</strong>: Línea directa para incidentes críticos</p>
</li>
<li>
<p><strong>Chat</strong>: Support chat en horario laboral</p>
</li>
<li>
<p><strong>Email</strong>: Respuesta garantizada por SLA</p>
</li>
<li>
<p><strong>TAM</strong>: Technical Account Manager (tiers superiores)</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Canales de soporte Community:</div>
<ul>
<li>
<p><strong>GitHub Issues</strong>: <a href="https://github.com/rancher/rancher/issues" class="bare">https://github.com/rancher/rancher/issues</a></p>
</li>
<li>
<p><strong>Forums</strong>: <a href="https://forums.rancher.com/" class="bare">https://forums.rancher.com/</a></p>
</li>
<li>
<p><strong>Slack</strong>: <a href="https://slack.rancher.io/" class="bare">https://slack.rancher.io/</a></p>
</li>
<li>
<p><strong>Stack Overflow</strong>: Tag <code>rancher</code></p>
</li>
<li>
<p><strong>Documentation</strong>: <a href="https://ranchermanager.docs.rancher.com/" class="bare">https://ranchermanager.docs.rancher.com/</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_2_instalación_y_configuración">Módulo 2: Instalación y Configuración</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_2_1_requisitos_del_sistema">2.1 Requisitos del sistema</h3>
<div class="paragraph">
<p>Antes de instalar Rancher, es fundamental comprender y preparar los requisitos de hardware, software, red y compatibilidad necesarios para garantizar un despliegue exitoso y estable.</p>
</div>
<div class="sect3">
<h4 id="_requisitos_de_hardware_y_software">Requisitos de hardware y software</h4>
<div class="paragraph">
<p>Los requisitos varían significativamente según el tipo de instalación (desarrollo vs producción) y el número de clústeres a gestionar.</p>
</div>
<div class="paragraph">
<p><strong>Requisitos para Rancher Server</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 15. Configuración de desarrollo (Docker single-node):</caption>
<colgroup>
<col style="width: 40%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Recurso</th>
<th class="tableblock halign-left valign-top">Especificación</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPU</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 cores</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RAM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 GB mínimo, 8 GB recomendado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Disco</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50 GB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ubuntu 20.04+, RHEL/CentOS 8+, SLES 15+</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Docker</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20.10.x o superior</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arquitectura</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x86_64 / AMD64</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 16. Configuración de producción (HA con 3 nodos):</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Recurso</th>
<th class="tableblock halign-left valign-top">Mínimo (por nodo)</th>
<th class="tableblock halign-left valign-top">Recomendado (por nodo)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPU</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 cores</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4-8 cores</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RAM</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16-32 GB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Disco (OS)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50 GB SSD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100 GB SSD</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Disco (etcd)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50 GB SSD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100-200 GB NVMe</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IOPS (etcd)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3000 IOPS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5000+ IOPS</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Network</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 Gbps</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 Gbps</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Latencia entre nodos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt; 10ms</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt; 5ms</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 17. Escalabilidad según número de clústeres gestionados:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Clústeres downstream</th>
<th class="tableblock halign-left valign-top">CPU (total)</th>
<th class="tableblock halign-left valign-top">RAM (total)</th>
<th class="tableblock halign-left valign-top">Nodos recomendados</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1-5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 cores</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5-15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16 cores</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">15-50</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32 cores</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3-5</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">50-100</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64 cores</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">256 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5-7</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">100+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Escalamiento horizontal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Según carga</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5+</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Sistemas operativos soportados</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 18. Rancher Server:</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">OS</th>
<th class="tableblock halign-left valign-top">Versiones</th>
<th class="tableblock halign-left valign-top">Notas</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ubuntu</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20.04 LTS, 22.04 LTS, 24.04 LTS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recomendado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RHEL/CentOS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8.x, 9.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Totalmente soportado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SLES</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15 SP3+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Con Rancher Prime</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rocky Linux</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8.x, 9.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Compatible</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Oracle Linux</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8.x, 9.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Compatible</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Debian</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11, 12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comunidad</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Amazon Linux 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2023</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Para AWS</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Container Runtime soportados</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 19. Para clústeres RKE2/K3s:</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Runtime</th>
<th class="tableblock halign-left valign-top">Versión</th>
<th class="tableblock halign-left valign-top">Notas</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">containerd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.x, 1.7.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recomendado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Docker</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20.10.x, 23.x, 24.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Para RKE1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CRI-O</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.26+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Soporte limitado</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Requisitos de software adicional</strong></p>
</div>
<div class="listingblock">
<div class="title">Herramientas necesarias:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Rancher Server (HA installation)
- Kubernetes cluster: v1.26+
- Helm: v3.10+
- kubectl: v1.26+
- cert-manager: v1.11+

# Rancher Server (Docker installation)
- Docker: 20.10+
- docker-compose (opcional): v2.x

# Clústeres downstream (RKE)
- Docker: 20.10+
- SSH access a todos los nodos

# Clústeres downstream (RKE2/K3s)
- containerd (incluido)
- Ningún prerequisito adicional</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuraciones_de_red_necesarias">Configuraciones de red necesarias</h4>
<div class="paragraph">
<p>La red es uno de los aspectos más críticos para el correcto funcionamiento de Rancher.</p>
</div>
<div class="paragraph">
<p><strong>Puertos requeridos para Rancher Server</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 20. Puertos de acceso externo:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Puerto</th>
<th class="tableblock halign-left valign-top">Protocolo</th>
<th class="tableblock halign-left valign-top">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">80</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP (redirige a 443)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTPS - Acceso principal a Rancher UI y API</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API (si Rancher en K8s)</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 21. Puertos entre nodos Rancher (HA):</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Puerto</th>
<th class="tableblock halign-left valign-top">Protocolo</th>
<th class="tableblock halign-left valign-top">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2379-2380</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">etcd client y peer communication</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kubernetes API server</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8472</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Canal/Flannel VXLAN overlay</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">9099</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Canal/Flannel livenessProbe/readinessProbe</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10250</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubelet API</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10254</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ingress controller livenessProbe/readinessProbe</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">30000-32767</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP/UDP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NodePort range (si se usa)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Puertos para clústeres downstream</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 22. Comunicación Rancher → Clústeres downstream:</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 50.0002%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Puerto</th>
<th class="tableblock halign-left valign-top">Protocolo</th>
<th class="tableblock halign-left valign-top">Dirección</th>
<th class="tableblock halign-left valign-top">Descripción</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Outbound</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cluster agents → Rancher Server</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6443</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bidireccional</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubectl proxy para K8s API</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">22</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Outbound (opcional)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SSH para node provisioning</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Los cluster agents inician conexiones OUTBOUND hacia Rancher Server en puerto 443. No se requieren conexiones inbound a los clústeres downstream.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Requisitos de DNS</strong></p>
</div>
<div class="listingblock">
<div class="title">DNS necesario:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Rancher Server:
  - FQDN público/privado: rancher.example.com
  - Resuelve a IP del Load Balancer o nodos Rancher
  - Certificado SSL debe coincidir con FQDN

Downstream clusters:
  - No requieren DNS público
  - DNS interno para resolución entre nodos
  - CoreDNS/kube-dns en el clúster</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de configuración DNS:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-dns hljs" data-lang="dns"># Zona DNS pública
rancher.example.com.      IN  A     203.0.113.10
rancher.example.com.      IN  A     203.0.113.11
rancher.example.com.      IN  A     203.0.113.12

# O con Load Balancer
rancher.example.com.      IN  CNAME lb.example.com.
lb.example.com.           IN  A     203.0.113.100</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Configuración de Firewall</strong></p>
</div>
<div class="listingblock">
<div class="title">Reglas de firewall típicas (iptables):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Permitir acceso HTTPS a Rancher Server
iptables -A INPUT -p tcp --dport 443 -j ACCEPT
iptables -A INPUT -p tcp --dport 80 -j ACCEPT

# Permitir comunicación entre nodos Rancher (ejemplo para etcd)
iptables -A INPUT -s 10.0.0.0/24 -p tcp --dport 2379:2380 -j ACCEPT
iptables -A INPUT -s 10.0.0.0/24 -p tcp --dport 6443 -j ACCEPT

# Permitir tráfico Kubernetes interno
iptables -A INPUT -s 10.42.0.0/16 -j ACCEPT
iptables -A INPUT -s 10.43.0.0/16 -j ACCEPT

# Permitir outbound a internet (para cluster agents)
iptables -A OUTPUT -p tcp --dport 443 -j ACCEPT</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Proxy y entornos corporativos</strong></p>
</div>
<div class="paragraph">
<p>Para entornos con proxy HTTP(S):</p>
</div>
<div class="listingblock">
<div class="title">Configuración de proxy para Rancher:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Variables de entorno para Rancher Server
HTTP_PROXY=http://proxy.corp.com:8080
HTTPS_PROXY=http://proxy.corp.com:8080
NO_PROXY=localhost,127.0.0.1,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,.svc,.cluster.local

# Para Docker
cat &gt;&gt; /etc/systemd/system/docker.service.d/http-proxy.conf &lt;&lt;EOF
[Service]
Environment="HTTP_PROXY=http://proxy.corp.com:8080"
Environment="HTTPS_PROXY=http://proxy.corp.com:8080"
Environment="NO_PROXY=localhost,127.0.0.1,10.0.0.0/8"
EOF

systemctl daemon-reload
systemctl restart docker</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Rangos de red recomendados</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 23. Rangos CIDR estándar:</caption>
<colgroup>
<col style="width: 28.5714%;">
<col style="width: 28.5714%;">
<col style="width: 42.8572%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Red</th>
<th class="tableblock halign-left valign-top">CIDR</th>
<th class="tableblock halign-left valign-top">Uso</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pod network</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.42.0.0/16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPs para pods (Canal/Flannel)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Service network</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10.43.0.0/16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ClusterIP services</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Node network</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Depende de infra</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPs de nodos físicos/VMs</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ingress</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LoadBalancer o NodePort</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Asegúrate de que los rangos de red no se solapen con la red corporativa existente.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_compatibilidad_con_proveedores_cloud">Compatibilidad con proveedores cloud</h4>
<div class="paragraph">
<p>Rancher es compatible con los principales proveedores de cloud y ofrece integración nativa para provisioning de clústeres.</p>
</div>
<div class="paragraph">
<p><strong>Amazon Web Services (AWS)</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 24. Requisitos para AWS:</caption>
<colgroup>
<col style="width: 40%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Requisito</th>
<th class="tableblock halign-left valign-top">Detalles</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Credenciales</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Access Key ID + Secret Access Key con permisos EC2, IAM</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VPC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VPC existente o crear nueva</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Subnets</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mínimo 1 subnet, recomendado 3 (multi-AZ)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Security Groups</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Permitir puertos requeridos</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IAM Roles</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Roles para nodos con políticas adecuadas</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EBS volumes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Para storage persistente</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<div class="title">Servicios AWS compatibles:</div>
<ul>
<li>
<p><strong>EC2</strong>: Para nodos de clústeres RKE</p>
</li>
<li>
<p><strong>EKS</strong>: Importación y gestión de clústeres EKS existentes</p>
</li>
<li>
<p><strong>EBS</strong>: Storage backend para PersistentVolumes</p>
</li>
<li>
<p><strong>ELB/ALB</strong>: Load balancers para ingress</p>
</li>
<li>
<p><strong>Route53</strong>: DNS management</p>
</li>
<li>
<p><strong>IAM</strong>: IRSA (IAM Roles for Service Accounts)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de política IAM mínima:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "ec2:DescribeInstances",
        "ec2:DescribeRegions",
        "ec2:DescribeSecurityGroups",
        "ec2:DescribeSubnets",
        "ec2:DescribeVolumes",
        "ec2:CreateSecurityGroup",
        "ec2:CreateTags",
        "ec2:CreateVolume",
        "ec2:RunInstances",
        "ec2:TerminateInstances",
        "iam:PassRole",
        "iam:CreateServiceLinkedRole"
      ],
      "Resource": "*"
    }
  ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Microsoft Azure</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 25. Requisitos para Azure:</caption>
<colgroup>
<col style="width: 40%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Requisito</th>
<th class="tableblock halign-left valign-top">Detalles</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Credenciales</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Service Principal (Client ID + Secret) o Managed Identity</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resource Group</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Grupo de recursos para el clúster</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Virtual Network</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VNet con subnets adecuadas</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Network Security Groups</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NSG con reglas requeridas</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Azure Disk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Para storage persistente</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<div class="title">Servicios Azure compatibles:</div>
<ul>
<li>
<p><strong>Azure VM</strong>: Para nodos de clústeres RKE</p>
</li>
<li>
<p><strong>AKS</strong>: Importación y gestión de clústeres AKS</p>
</li>
<li>
<p><strong>Azure Disk</strong>: Storage backend</p>
</li>
<li>
<p><strong>Azure Load Balancer</strong>: Para ingress</p>
</li>
<li>
<p><strong>Azure DNS</strong>: DNS management</p>
</li>
<li>
<p><strong>Azure AD</strong>: Autenticación</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Crear Service Principal para Rancher:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Crear service principal
az ad sp create-for-rbac --name RancherSP --role Contributor

# Output:
{
  "appId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "displayName": "RancherSP",
  "password": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "tenant": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
}

# Asignar rol adicional para AKS
az role assignment create \
  --assignee &lt;appId&gt; \
  --role "Azure Kubernetes Service Cluster Admin Role"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Google Cloud Platform (GCP)</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 26. Requisitos para GCP:</caption>
<colgroup>
<col style="width: 40%;">
<col style="width: 60%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Requisito</th>
<th class="tableblock halign-left valign-top">Detalles</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Credenciales</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Service Account JSON key</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Project</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GCP Project ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VPC Network</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Red VPC con subnets</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Firewall Rules</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reglas para puertos requeridos</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Persistent Disk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Para storage</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<div class="title">Servicios GCP compatibles:</div>
<ul>
<li>
<p><strong>Compute Engine</strong>: Para nodos de clústeres RKE</p>
</li>
<li>
<p><strong>GKE</strong>: Importación y gestión de clústeres GKE</p>
</li>
<li>
<p><strong>Persistent Disk</strong>: Storage backend</p>
</li>
<li>
<p><strong>Cloud Load Balancing</strong>: Para ingress</p>
</li>
<li>
<p><strong>Cloud DNS</strong>: DNS management</p>
</li>
<li>
<p><strong>Cloud IAM</strong>: Autenticación</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Crear Service Account para Rancher:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Crear service account
gcloud iam service-accounts create rancher-sa \
  --display-name "Rancher Service Account"

# Asignar roles necesarios
gcloud projects add-iam-policy-binding PROJECT_ID \
  --member="serviceAccount:rancher-sa@PROJECT_ID.iam.gserviceaccount.com" \
  --role="roles/compute.admin"

gcloud projects add-iam-policy-binding PROJECT_ID \
  --member="serviceAccount:rancher-sa@PROJECT_ID.iam.gserviceaccount.com" \
  --role="roles/container.admin"

# Generar key
gcloud iam service-accounts keys create rancher-key.json \
  --iam-account=rancher-sa@PROJECT_ID.iam.gserviceaccount.com</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Otros proveedores cloud</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 27. Compatibilidad adicional:</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Provider</th>
<th class="tableblock halign-left valign-top">Soporte</th>
<th class="tableblock halign-left valign-top">Notas</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DigitalOcean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOKS + Droplets</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Linode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LKE + VMs</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vultr</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vía custom</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Custom node driver</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OVH Cloud</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vía custom</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Custom node driver</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenStack</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Node driver nativo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VMware vSphere</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Node driver nativo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nutanix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Node driver nativo</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_requisitos_para_entornos_air_gapped">Requisitos para entornos air-gapped</h4>
<div class="paragraph">
<p>Los entornos air-gapped (sin acceso a internet) requieren preparación adicional para descargar y alojar todos los artefactos necesarios.</p>
</div>
<div class="paragraph">
<p><strong>Concepto de air-gapped</strong></p>
</div>
<div class="paragraph">
<p>Un entorno air-gapped es aquel que no tiene conectividad directa a internet por razones de seguridad, compliance o restricciones de red.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="rancher-airgap.png" alt="rancher airgap" width="477" height="717">
</div>
<div class="title">Figure 8. Arquitectura air-gapped</div>
</div>
<div class="paragraph">
<p><strong>Componentes necesarios en air-gapped</strong></p>
</div>
<div class="listingblock">
<div class="title">Lista de artefactos requeridos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Imágenes Docker/Container:
   - Rancher server images
   - Rancher agent images
   - System images (nginx, coredns, etc.)
   - Monitoring stack images (Prometheus, Grafana)
   - Logging stack images (Fluentd, Elasticsearch)

2. Helm charts:
   - Rancher chart
   - cert-manager chart
   - Monitoring charts
   - Logging charts

3. Binaries:
   - Rancher CLI
   - kubectl
   - helm
   - RKE/RKE2 binaries

4. Certificados SSL:
   - Certificados para Rancher
   - CA certificates si son custom</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Private Docker Registry</strong></p>
</div>
<div class="paragraph">
<p>Es obligatorio tener un registry privado accesible desde el entorno air-gapped.</p>
</div>
<div class="ulist">
<div class="title">Opciones de registry:</div>
<ul>
<li>
<p><strong>Harbor</strong>: Open source, features completas, recomendado</p>
</li>
<li>
<p><strong>Docker Registry</strong>: Básico, open source</p>
</li>
<li>
<p><strong>Nexus Repository</strong>: Multi-format repository manager</p>
</li>
<li>
<p><strong>Artifactory</strong>: Enterprise registry</p>
</li>
<li>
<p><strong>Cloud provider registries</strong>: ACR, ECR, GCR (si accesibles)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Deploy Harbor como private registry:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Instalar Harbor con docker-compose
wget https://github.com/goharbor/harbor/releases/download/v2.10.0/harbor-offline-installer-v2.10.0.tgz
tar xvf harbor-offline-installer-v2.10.0.tgz
cd harbor

# Configurar harbor.yml
cp harbor.yml.tmpl harbor.yml
vim harbor.yml
# Modificar:
#   hostname: registry.airgap.local
#   https.certificate: /path/to/cert.crt
#   https.private_key: /path/to/cert.key
#   harbor_admin_password: YourSecurePassword

# Instalar
./install.sh --with-chartmuseum

# Verificar
docker-compose ps</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Proceso de preparación air-gapped</strong></p>
</div>
<div class="listingblock">
<div class="title">Paso 1: Descargar todas las imágenes (desde máquina con internet):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Script para descargar imágenes de Rancher 2.9.3
RANCHER_VERSION=v2.9.3

# Descargar la lista de imágenes requeridas
curl -L https://github.com/rancher/rancher/releases/download/${RANCHER_VERSION}/rancher-images.txt -o rancher-images.txt

# Descargar script de save
curl -L https://github.com/rancher/rancher/releases/download/${RANCHER_VERSION}/rancher-save-images.sh -o rancher-save-images.sh

# Dar permisos y ejecutar
chmod +x rancher-save-images.sh
./rancher-save-images.sh --image-list rancher-images.txt

# Se genera: rancher-images.tar.gz (varios GB)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Paso 2: Transferir artefactos al entorno air-gapped:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Método 1: USB/Disco duro externo
cp rancher-images.tar.gz /media/usb/
cp cert-manager-v1.14.0.tar.gz /media/usb/
cp helm-charts/ /media/usb/ -r

# Método 2: Transfer a bastion host
scp rancher-images.tar.gz user@bastion:/tmp/
scp cert-manager-v1.14.0.tar.gz user@bastion:/tmp/</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Paso 3: Cargar imágenes al registry privado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Desde el entorno air-gapped
REGISTRY=registry.airgap.local

# Load images
docker load -i rancher-images.tar.gz

# Tag y push a registry privado
curl -L https://github.com/rancher/rancher/releases/download/${RANCHER_VERSION}/rancher-load-images.sh -o rancher-load-images.sh
chmod +x rancher-load-images.sh

./rancher-load-images.sh \
  --image-list rancher-images.txt \
  --registry ${REGISTRY}

# Verificar imágenes en registry
curl -u admin:password https://${REGISTRY}/v2/_catalog</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Configuración de CA certificates custom</strong></p>
</div>
<div class="paragraph">
<p>Si el registry privado usa certificados autofirmados o CA privada:</p>
</div>
<div class="listingblock">
<div class="title">Añadir CA cert a los nodos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ubuntu/Debian
cp ca.crt /usr/local/share/ca-certificates/
update-ca-certificates

# RHEL/CentOS
cp ca.crt /etc/pki/ca-trust/source/anchors/
update-ca-trust

# Reiniciar Docker/containerd
systemctl restart docker
systemctl restart containerd</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Instalación de Rancher en air-gapped</strong></p>
</div>
<div class="listingblock">
<div class="title">Pasos específicos para air-gapped:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># 1. Instalar cert-manager desde registry privado
helm install cert-manager cert-manager/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --set image.repository=${REGISTRY}/jetstack/cert-manager-controller \
  --set webhook.image.repository=${REGISTRY}/jetstack/cert-manager-webhook \
  --set cainjector.image.repository=${REGISTRY}/jetstack/cert-manager-cainjector \
  --set installCRDs=true

# 2. Instalar Rancher desde registry privado
helm install rancher rancher-stable/rancher \
  --namespace cattle-system \
  --create-namespace \
  --set hostname=rancher.airgap.local \
  --set rancherImage=${REGISTRY}/rancher/rancher \
  --set systemDefaultRegistry=${REGISTRY} \
  --set useBundledSystemChart=true

# 3. Verificar instalación
kubectl -n cattle-system get pods
kubectl -n cattle-system get svc</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Checklist de requisitos air-gapped</strong></p>
</div>
<div class="listingblock">
<div class="title">Antes de instalar Rancher en air-gapped:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-checklist hljs" data-lang="checklist">☐ Private registry instalado y accesible
☐ Todas las imágenes de Rancher cargadas en registry
☐ Imágenes de cert-manager en registry
☐ Imágenes de system charts en registry
☐ Helm charts descargados localmente
☐ Certificados CA configurados en todos los nodos
☐ DNS interno configurado para resolver registry
☐ Ancho de banda interno suficiente para pull de imágenes
☐ Storage adecuado para registry (100+ GB)
☐ Backup strategy para registry
☐ Documentación de proceso de actualización
☐ Testing en ambiente de prueba completado</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Actualizaciones en entornos air-gapped</strong></p>
</div>
<div class="paragraph">
<p>Las actualizaciones requieren repetir el proceso de descarga y carga de nuevas imágenes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># 1. Descargar nueva versión (desde máquina con internet)
RANCHER_VERSION=v2.9.4
curl -L https://github.com/rancher/rancher/releases/download/${RANCHER_VERSION}/rancher-images.txt -o rancher-images-${RANCHER_VERSION}.txt
./rancher-save-images.sh --image-list rancher-images-${RANCHER_VERSION}.txt

# 2. Transferir al entorno air-gapped
# 3. Cargar en registry privado
./rancher-load-images.sh \
  --image-list rancher-images-${RANCHER_VERSION}.txt \
  --registry ${REGISTRY}

# 4. Actualizar Rancher
helm upgrade rancher rancher-stable/rancher \
  --namespace cattle-system \
  --version ${RANCHER_VERSION} \
  --set rancherImage=${REGISTRY}/rancher/rancher \
  --set systemDefaultRegistry=${REGISTRY} \
  --reuse-values</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_2_instalación_de_rancher">2.2 Instalación de Rancher</h3>
<div class="paragraph">
<p>Rancher puede instalarse de diferentes formas según las necesidades del entorno. Las dos opciones principales son instalación con Helm (producción) e instalación con Docker (desarrollo/testing).</p>
</div>
<div class="sect3">
<h4 id="_instalación_con_helm">Instalación con Helm</h4>
<div class="paragraph">
<p>La instalación con Helm es el método recomendado para entornos de producción, proporcionando alta disponibilidad y escalabilidad.</p>
</div>
<div class="paragraph">
<p><strong>Prerequisitos para instalación con Helm</strong></p>
</div>
<div class="ulist">
<div class="title">Requisitos previos:</div>
<ul>
<li>
<p>Clúster Kubernetes funcional (v1.26+)</p>
</li>
<li>
<p>Helm 3.10+ instalado</p>
</li>
<li>
<p>kubectl configurado para acceder al clúster</p>
</li>
<li>
<p>Acceso a internet o registry privado con las imágenes necesarias</p>
</li>
<li>
<p>Certificados SSL (Let&#8217;s Encrypt, custom, o autofirmados)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Paso 1: Preparar el clúster Kubernetes</strong></p>
</div>
<div class="paragraph">
<p>Si no tienes un clúster Kubernetes, puedes crear uno con RKE, RKE2, o usar un clúster gestionado (EKS, AKS, GKE).</p>
</div>
<div class="listingblock">
<div class="title">Crear clúster con RKE2 (ejemplo):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Instalar RKE2 en el primer nodo (controlplane + etcd + worker)
curl -sfL https://get.rke2.io | sh -
systemctl enable rke2-server.service
systemctl start rke2-server.service

# Esperar a que el clúster esté listo
export KUBECONFIG=/etc/rancher/rke2/rke2.yaml
/var/lib/rancher/rke2/bin/kubectl get nodes

# Para nodos adicionales, obtener el token
cat /var/lib/rancher/rke2/server/node-token

# En nodos adicionales
curl -sfL https://get.rke2.io | INSTALL_RKE2_TYPE="server" sh -
mkdir -p /etc/rancher/rke2/
cat &gt; /etc/rancher/rke2/config.yaml &lt;&lt;EOF
server: https://&lt;primer-nodo-ip&gt;:9345
token: &lt;token-del-primer-nodo&gt;
tls-san:
  - &lt;load-balancer-ip&gt;
EOF

systemctl enable rke2-server.service
systemctl start rke2-server.service</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Paso 2: Instalar cert-manager</strong></p>
</div>
<div class="paragraph">
<p>cert-manager es necesario para gestionar certificados TLS en Rancher.</p>
</div>
<div class="listingblock">
<div class="title">Instalar cert-manager:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Añadir el repositorio de Helm de cert-manager
helm repo add jetstack https://charts.jetstack.io
helm repo update

# Crear namespace
kubectl create namespace cert-manager

# Instalar cert-manager
helm install cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --version v1.14.0 \
  --set installCRDs=true

# Verificar instalación
kubectl get pods --namespace cert-manager

# Esperar a que todos los pods estén Running
kubectl wait --for=condition=Available --timeout=300s \
  -n cert-manager deployment/cert-manager \
  deployment/cert-manager-webhook \
  deployment/cert-manager-cainjector</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Paso 3: Añadir el repositorio Helm de Rancher</strong></p>
</div>
<div class="listingblock">
<div class="title">Añadir repositorio:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Repositorio stable (releases oficiales)
helm repo add rancher-stable https://releases.rancher.com/server-charts/stable

# O repositorio latest (más reciente, menos estable)
# helm repo add rancher-latest https://releases.rancher.com/server-charts/latest

# Actualizar índice de repositorios
helm repo update</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Paso 4: Crear namespace para Rancher</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl create namespace cattle-system</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Paso 5: Instalar Rancher</strong></p>
</div>
<div class="paragraph">
<p>Existen tres opciones principales para certificados SSL:</p>
</div>
<div class="paragraph">
<p><strong>Opción A: Certificados de Rancher (autofirmados)</strong></p>
</div>
<div class="paragraph">
<p>La opción más simple para pruebas y desarrollo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm install rancher rancher-stable/rancher \
  --namespace cattle-system \
  --set hostname=rancher.example.com \
  --set replicas=3 \
  --set bootstrapPassword=admin

# Verificar instalación
kubectl -n cattle-system rollout status deploy/rancher
kubectl -n cattle-system get deploy rancher</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Opción B: Let&#8217;s Encrypt (certificados gratuitos)</strong></p>
</div>
<div class="paragraph">
<p>Recomendado para entornos públicos con DNS válido.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm install rancher rancher-stable/rancher \
  --namespace cattle-system \
  --set hostname=rancher.example.com \
  --set replicas=3 \
  --set bootstrapPassword=admin \
  --set ingress.tls.source=letsEncrypt \
  --set letsEncrypt.email=admin@example.com \
  --set letsEncrypt.environment=production

# Para staging (testing):
# --set letsEncrypt.environment=staging</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Opción C: Certificados propios (custom certificates)</strong></p>
</div>
<div class="paragraph">
<p>Para entornos empresariales con PKI corporativa.</p>
</div>
<div class="listingblock">
<div class="title">Crear secret con certificados custom:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Crear secret TLS con tu certificado y key
kubectl -n cattle-system create secret tls tls-rancher-ingress \
  --cert=/path/to/tls.crt \
  --key=/path/to/tls.key

# Si tienes una CA intermedia, crear secret adicional
kubectl -n cattle-system create secret generic tls-ca \
  --from-file=cacerts.pem=/path/to/ca.crt

# Instalar Rancher con certificados custom
helm install rancher rancher-stable/rancher \
  --namespace cattle-system \
  --set hostname=rancher.example.com \
  --set replicas=3 \
  --set bootstrapPassword=admin \
  --set ingress.tls.source=secret \
  --set privateCA=true</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Paso 6: Verificar la instalación</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver el estado del deployment
kubectl -n cattle-system rollout status deploy/rancher

# Ver todos los recursos
kubectl -n cattle-system get all

# Ver logs si hay problemas
kubectl -n cattle-system logs -l app=rancher

# Obtener la URL de acceso
echo https://rancher.example.com/dashboard/?setup=$(kubectl get secret --namespace cattle-system bootstrap-secret -o go-template='{{.data.bootstrapPassword|base64decode}}')</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Configuración avanzada con Helm values</strong></p>
</div>
<div class="paragraph">
<p>Para configuraciones más complejas, crear un archivo <code>values.yaml</code>:</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de values.yaml completo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Hostname de Rancher
hostname: rancher.example.com

# Número de réplicas (mínimo 3 para HA)
replicas: 3

# Contraseña inicial del admin (cambiar en producción)
bootstrapPassword: "SecurePassword123!"

# Configuración de ingress
ingress:
  tls:
    source: secret  # o letsEncrypt, o rancher
  extraAnnotations:
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "30"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "1800"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "1800"

# Para certificados custom
privateCA: true

# Recursos para los pods
resources:
  requests:
    cpu: 500m
    memory: 1Gi
  limits:
    cpu: 2000m
    memory: 4Gi

# Anti-affinity para distribuir pods en diferentes nodos
antiAffinity: required

# Configuración de proxy (si aplica)
proxy: http://proxy.example.com:8080
noProxy: 127.0.0.0/8,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,.svc,.cluster.local

# Audit logging
auditLog:
  level: 2
  maxAge: 10
  maxBackup: 10
  maxSize: 100

# Sistema de autenticación por defecto
# (se puede cambiar después en la UI)
# authenticationMode: restricted

# Registry privado (para air-gapped)
# systemDefaultRegistry: registry.example.com
# useBundledSystemChart: true</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Instalar con values.yaml:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm install rancher rancher-stable/rancher \
  --namespace cattle-system \
  --values values.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Actualización de Rancher con Helm</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Actualizar repositorio
helm repo update

# Ver versión actual
helm list -n cattle-system

# Backup antes de actualizar (crítico!)
kubectl -n cattle-system get secret bootstrap-secret -o yaml &gt; bootstrap-secret.yaml
helm get values rancher -n cattle-system -o yaml &gt; rancher-values.yaml

# Actualizar a nueva versión
helm upgrade rancher rancher-stable/rancher \
  --namespace cattle-system \
  --version=2.9.3 \
  --reuse-values

# O con nuevos valores
helm upgrade rancher rancher-stable/rancher \
  --namespace cattle-system \
  --version=2.9.3 \
  --values values.yaml

# Verificar actualización
kubectl -n cattle-system rollout status deploy/rancher</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Troubleshooting instalación Helm</strong></p>
</div>
<div class="listingblock">
<div class="title">Problemas comunes y soluciones:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Problema: Pods en CrashLoopBackOff
kubectl -n cattle-system describe pod -l app=rancher
kubectl -n cattle-system logs -l app=rancher --tail=100

# Problema: Certificados inválidos
kubectl -n cattle-system get secret tls-rancher-ingress -o yaml
kubectl -n cattle-system describe certificate

# Problema: cert-manager no funciona
kubectl -n cert-manager get pods
kubectl -n cert-manager logs -l app=cert-manager

# Problema: Ingress no responde
kubectl -n cattle-system get ingress
kubectl -n cattle-system describe ingress rancher

# Problema: DNS no resuelve
nslookup rancher.example.com
curl -k https://rancher.example.com/ping

# Reinstalar desde cero
helm uninstall rancher -n cattle-system
kubectl delete namespace cattle-system
# Esperar a que todo se elimine completamente
kubectl create namespace cattle-system
# Reinstalar</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_instalación_con_docker_desarrollo">Instalación con Docker (desarrollo)</h4>
<div class="paragraph">
<p>La instalación con Docker es ideal para desarrollo, testing y demos rápidos. <strong>No usar en producción.</strong></p>
</div>
<div class="paragraph">
<p><strong>Método 1: Instalación básica con Docker</strong></p>
</div>
<div class="listingblock">
<div class="title">Instalación simple:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Instalar Docker si no está instalado
curl -fsSL https://get.docker.com | sh
systemctl start docker
systemctl enable docker

# Ejecutar Rancher en un contenedor
docker run -d --restart=unless-stopped \
  -p 80:80 -p 443:443 \
  --privileged \
  --name rancher \
  rancher/rancher:v2.9.3

# Ver logs
docker logs -f rancher

# Esperar a que Rancher esté listo (buscar "Bootstrap Password")
docker logs rancher 2&gt;&amp;1 | grep "Bootstrap Password:"

# O generar nueva contraseña
docker exec -it rancher reset-password</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 2: Con volumen persistente</strong></p>
</div>
<div class="paragraph">
<p>Para mantener datos entre reinicios:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Crear volumen para persistencia
docker volume create rancher-data

# Ejecutar Rancher con volumen
docker run -d --restart=unless-stopped \
  -p 80:80 -p 443:443 \
  --privileged \
  --name rancher \
  -v rancher-data:/var/lib/rancher \
  rancher/rancher:v2.9.3

# Acceder a Rancher
echo "Accede a https://$(hostname -I | awk '{print $1}')"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 3: Con hostname personalizado</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Con hostname específico (requiere DNS o /etc/hosts configurado)
docker run -d --restart=unless-stopped \
  -p 80:80 -p 443:443 \
  --privileged \
  --name rancher \
  -v rancher-data:/var/lib/rancher \
  -e CATTLE_BOOTSTRAP_PASSWORD=mypassword123 \
  rancher/rancher:v2.9.3 \
  --no-cacerts

# Configurar /etc/hosts si no tienes DNS
echo "192.168.1.100 rancher.local" | sudo tee -a /etc/hosts</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 4: Con certificados SSL custom (Docker)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Preparar certificados
mkdir -p /opt/rancher/certs
cp tls.crt /opt/rancher/certs/
cp tls.key /opt/rancher/certs/
cp ca.crt /opt/rancher/certs/

# Ejecutar Rancher con certificados
docker run -d --restart=unless-stopped \
  -p 80:80 -p 443:443 \
  --privileged \
  --name rancher \
  -v rancher-data:/var/lib/rancher \
  -v /opt/rancher/certs/tls.crt:/etc/rancher/ssl/cert.pem:ro \
  -v /opt/rancher/certs/tls.key:/etc/rancher/ssl/key.pem:ro \
  -v /opt/rancher/certs/ca.crt:/etc/rancher/ssl/cacerts.pem:ro \
  rancher/rancher:v2.9.3</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 5: Con docker-compose</strong></p>
</div>
<div class="paragraph">
<p>Más fácil de gestionar y versionar.</p>
</div>
<div class="listingblock">
<div class="title">docker-compose.yml:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">version: '3.8'

services:
  rancher:
    image: rancher/rancher:v2.9.3
    container_name: rancher
    restart: unless-stopped
    privileged: true
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - rancher-data:/var/lib/rancher
      # Opcional: certificados custom
      # - ./certs/tls.crt:/etc/rancher/ssl/cert.pem:ro
      # - ./certs/tls.key:/etc/rancher/ssl/key.pem:ro
      # - ./certs/ca.crt:/etc/rancher/ssl/cacerts.pem:ro
    environment:
      - CATTLE_BOOTSTRAP_PASSWORD=SecurePassword123!
      # Opcional: para debugging
      # - CATTLE_DEBUG=true
      # Opcional: proxy
      # - HTTP_PROXY=http://proxy.example.com:8080
      # - HTTPS_PROXY=http://proxy.example.com:8080
      # - NO_PROXY=localhost,127.0.0.1,rancher

volumes:
  rancher-data:
    driver: local</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Comandos docker-compose:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Iniciar Rancher
docker-compose up -d

# Ver logs
docker-compose logs -f

# Detener Rancher
docker-compose down

# Detener y eliminar volúmenes (cuidado!)
docker-compose down -v

# Actualizar a nueva versión
docker-compose pull
docker-compose up -d</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Backup y restauración (Docker)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Backup del volumen de datos
docker run --rm \
  -v rancher-data:/source \
  -v $(pwd):/backup \
  alpine tar czf /backup/rancher-backup-$(date +%Y%m%d).tar.gz -C /source .

# Restauración
docker run --rm \
  -v rancher-data:/target \
  -v $(pwd):/backup \
  alpine sh -c "cd /target &amp;&amp; tar xzf /backup/rancher-backup-20251030.tar.gz"

# Reiniciar Rancher
docker restart rancher</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_de_certificados_ssl">Configuración de certificados SSL</h4>
<div class="paragraph">
<p>La configuración correcta de certificados SSL es crítica para la seguridad y funcionamiento de Rancher.</p>
</div>
<div class="paragraph">
<p><strong>Opción 1: Let&#8217;s Encrypt (automático)</strong></p>
</div>
<div class="paragraph">
<p>Ya configurado durante la instalación con Helm. Renovación automática cada 60-90 días.</p>
</div>
<div class="listingblock">
<div class="title">Verificar certificados Let&#8217;s Encrypt:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver el certificado
kubectl -n cattle-system get certificate

# Ver detalles
kubectl -n cattle-system describe certificate rancher

# Ver el secret del certificado
kubectl -n cattle-system get secret tls-rancher-ingress -o yaml

# Forzar renovación (si es necesario)
kubectl -n cattle-system delete secret tls-rancher-ingress
# cert-manager creará uno nuevo automáticamente</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Opción 2: Certificados autofirmados de Rancher</strong></p>
</div>
<div class="paragraph">
<p>Generados automáticamente por Rancher. Solo para testing.</p>
</div>
<div class="listingblock">
<div class="title">Generar nuevos certificados autofirmados:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Rancher regenera automáticamente al iniciar
# Para forzar regeneración:
kubectl -n cattle-system delete secret tls-rancher-ingress
kubectl -n cattle-system rollout restart deploy/rancher</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Opción 3: Certificados corporativos/custom</strong></p>
</div>
<div class="paragraph">
<p><strong>Generar certificados custom con OpenSSL</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># 1. Generar CA privada (si no tienes una)
openssl genrsa -out ca.key 4096
openssl req -x509 -new -nodes -key ca.key -sha256 -days 3650 \
  -out ca.crt \
  -subj "/C=US/ST=State/L=City/O=Organization/CN=MyCA"

# 2. Generar key privada para Rancher
openssl genrsa -out tls.key 4096

# 3. Crear CSR (Certificate Signing Request)
openssl req -new -key tls.key -out tls.csr \
  -subj "/C=US/ST=State/L=City/O=Organization/CN=rancher.example.com"

# 4. Crear archivo de extensiones para SAN
cat &gt; rancher-ext.cnf &lt;&lt;EOF
subjectAltName = DNS:rancher.example.com,DNS:rancher,IP:192.168.1.100
EOF

# 5. Firmar el certificado con la CA
openssl x509 -req -in tls.csr -CA ca.crt -CAkey ca.key \
  -CAcreateserial -out tls.crt -days 365 -sha256 \
  -extfile rancher-ext.cnf

# 6. Verificar el certificado
openssl x509 -in tls.crt -text -noout | grep -A1 "Subject Alternative Name"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Instalar certificados custom en Rancher (Helm)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Crear secrets en Kubernetes
kubectl -n cattle-system create secret tls tls-rancher-ingress \
  --cert=tls.crt \
  --key=tls.key

kubectl -n cattle-system create secret generic tls-ca \
  --from-file=cacerts.pem=ca.crt

# Si Rancher ya está instalado, actualizar
helm upgrade rancher rancher-stable/rancher \
  --namespace cattle-system \
  --set ingress.tls.source=secret \
  --set privateCA=true \
  --reuse-values

# Reiniciar pods
kubectl -n cattle-system rollout restart deploy/rancher</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Instalar certificados custom en Rancher (Docker)</strong></p>
</div>
<div class="paragraph">
<p>Ya mostrado en la sección de instalación Docker, pero para referencia:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker run -d --restart=unless-stopped \
  -p 80:80 -p 443:443 \
  --privileged \
  --name rancher \
  -v rancher-data:/var/lib/rancher \
  -v /path/to/tls.crt:/etc/rancher/ssl/cert.pem:ro \
  -v /path/to/tls.key:/etc/rancher/ssl/key.pem:ro \
  -v /path/to/ca.crt:/etc/rancher/ssl/cacerts.pem:ro \
  rancher/rancher:v2.9.3</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Renovación de certificados</strong></p>
</div>
<div class="listingblock">
<div class="title">Proceso de renovación de certificados custom:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># 1. Generar nuevos certificados (como arriba)

# 2. Actualizar secret en Kubernetes
kubectl -n cattle-system create secret tls tls-rancher-ingress \
  --cert=tls-new.crt \
  --key=tls-new.key \
  --dry-run=client -o yaml | kubectl apply -f -

# 3. Reiniciar Rancher
kubectl -n cattle-system rollout restart deploy/rancher

# 4. Verificar
kubectl -n cattle-system get pods
curl -vk https://rancher.example.com 2&gt;&amp;1 | grep "SSL certificate"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Troubleshooting certificados</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver detalles del certificado actual
echo | openssl s_client -connect rancher.example.com:443 2&gt;/dev/null | \
  openssl x509 -noout -text

# Ver fecha de expiración
echo | openssl s_client -connect rancher.example.com:443 2&gt;/dev/null | \
  openssl x509 -noout -dates

# Verificar chain completo
openssl s_client -connect rancher.example.com:443 -showcerts

# Verificar desde el navegador
# Chrome: Developer Tools → Security → View Certificate
# Firefox: Lock icon → Connection Secure → More Information</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_inicial_del_servidor">Configuración inicial del servidor</h4>
<div class="paragraph">
<p>Después de instalar Rancher, es necesario completar la configuración inicial.</p>
</div>
<div class="paragraph">
<p><strong>Acceso inicial a Rancher</strong></p>
</div>
<div class="listingblock">
<div class="title">Obtener URL y contraseña inicial:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Para instalación con Helm
echo https://rancher.example.com/dashboard/?setup=$(kubectl get secret --namespace cattle-system bootstrap-secret -o go-template='{{.data.bootstrapPassword|base64decode}}')

# Para instalación con Docker
docker logs rancher 2&gt;&amp;1 | grep "Bootstrap Password:"

# O resetear contraseña
docker exec -it rancher reset-password
kubectl -n cattle-system exec -it $(kubectl -n cattle-system get pods -l app=rancher -o name | head -1) -- reset-password</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Wizard de configuración inicial</strong></p>
</div>
<div class="paragraph">
<p>Al acceder por primera vez, Rancher presenta un wizard:</p>
</div>
<div class="olist arabic">
<div class="title">Pasos del wizard:</div>
<ol class="arabic">
<li>
<p><strong>Aceptar términos y condiciones</strong></p>
</li>
<li>
<p><strong>Establecer contraseña del admin</strong> (cambiar la bootstrap password)</p>
</li>
<li>
<p><strong>Configurar Server URL</strong> (debe coincidir con el hostname)</p>
</li>
<li>
<p><strong>Configurar telemetría</strong> (opcional, para estadísticas de uso)</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Ejemplo de Server URL:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">https://rancher.example.com

# Debe ser accesible desde:
- Navegador del administrador
- Cluster agents en clústeres downstream
- API clients

# NO usar:
- localhost
- 127.0.0.1
- IPs privadas si los clústeres están en diferentes redes</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Configuración vía CLI (automatización)</strong></p>
</div>
<div class="paragraph">
<p>Para automatizar la configuración inicial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Esperar a que Rancher esté listo
kubectl -n cattle-system wait --for=condition=Available --timeout=600s deployment/rancher

# Obtener token de bootstrap
BOOTSTRAP_PASSWORD=$(kubectl get secret --namespace cattle-system bootstrap-secret -o go-template='{{.data.bootstrapPassword|base64decode}}')

# Configurar contraseña del admin vía API
RANCHER_URL="https://rancher.example.com"
NEW_PASSWORD="MySecurePassword123!"

# Login con bootstrap password
TOKEN=$(curl -sk -X POST "${RANCHER_URL}/v3-public/localProviders/local?action=login" \
  -H 'content-type: application/json' \
  -d "{\"username\":\"admin\",\"password\":\"${BOOTSTRAP_PASSWORD}\"}" | jq -r .token)

# Cambiar contraseña
curl -sk -X POST "${RANCHER_URL}/v3/users?action=changepassword" \
  -H "Authorization: Bearer ${TOKEN}" \
  -H 'content-type: application/json' \
  -d "{\"currentPassword\":\"${BOOTSTRAP_PASSWORD}\",\"newPassword\":\"${NEW_PASSWORD}\"}"

# Configurar Server URL
curl -sk -X PUT "${RANCHER_URL}/v3/settings/server-url" \
  -H "Authorization: Bearer ${TOKEN}" \
  -H 'content-type: application/json' \
  -d "{\"name\":\"server-url\",\"value\":\"${RANCHER_URL}\"}"

# Crear API token para automatización futura
API_TOKEN=$(curl -sk -X POST "${RANCHER_URL}/v3/token" \
  -H "Authorization: Bearer ${TOKEN}" \
  -H 'content-type: application/json' \
  -d '{"type":"token","description":"Automation Token","ttl":0}' | jq -r .token)

echo "API Token: ${API_TOKEN}"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Configuraciones post-instalación recomendadas</strong></p>
</div>
<div class="listingblock">
<div class="title">Configuraciones críticas:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Backup automático:
   - Configurar snapshots de etcd
   - Backup del namespace cattle-system
   - Documentar proceso de restauración

2. Monitoreo:
   - Habilitar Rancher Monitoring
   - Configurar alertas críticas
   - Dashboard de health

3. Seguridad:
   - Cambiar contraseña por defecto
   - Configurar autenticación externa (LDAP/SAML)
   - Habilitar audit logging
   - Revisar RBAC policies

4. Red:
   - Verificar firewall rules
   - Configurar proxy si aplica
   - Validar DNS resolution

5. Alta disponibilidad:
   - Verificar que hay 3+ réplicas
   - Comprobar anti-affinity rules
   - Testear failover</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Verificación de instalación completa</strong></p>
</div>
<div class="listingblock">
<div class="title">Checklist de verificación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
echo "=== Verificación de instalación de Rancher ==="

# 1. Pods corriendo
echo "1. Verificando pods..."
kubectl -n cattle-system get pods -l app=rancher
kubectl -n cattle-system get pods -l app=rancher | grep -q "Running" &amp;&amp; echo "✓ Pods OK" || echo "✗ Pods con problemas"

# 2. Servicio accesible
echo "2. Verificando servicio..."
kubectl -n cattle-system get svc rancher
echo "✓ Servicio OK"

# 3. Ingress configurado
echo "3. Verificando ingress..."
kubectl -n cattle-system get ingress rancher
echo "✓ Ingress OK"

# 4. Certificados válidos
echo "4. Verificando certificados..."
kubectl -n cattle-system get secret tls-rancher-ingress
echo "✓ Certificados OK"

# 5. API responde
echo "5. Verificando API..."
curl -k https://rancher.example.com/ping &amp;&amp; echo "✓ API responde" || echo "✗ API no responde"

# 6. UI accesible
echo "6. Verificando UI..."
curl -k https://rancher.example.com/ | grep -q "Rancher" &amp;&amp; echo "✓ UI OK" || echo "✗ UI con problemas"

# 7. etcd saludable (si es clúster local)
echo "7. Verificando etcd..."
kubectl -n cattle-system exec -it $(kubectl -n cattle-system get pods -l app=rancher -o name | head -1) -- \
  kubectl -n kube-system exec -it etcd-rancher-0 -- etcdctl endpoint health 2&gt;/dev/null &amp;&amp; \
  echo "✓ etcd OK" || echo "⚠ etcd check skipped"

echo ""
echo "=== Fin de verificación ==="</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Próximos pasos</strong></p>
</div>
<div class="paragraph">
<p>Después de la instalación exitosa:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Configurar autenticación (ver sección 2.3)</p>
</li>
<li>
<p>Importar o crear el primer clúster (ver módulo 3)</p>
</li>
<li>
<p>Configurar backup y disaster recovery (ver módulo 9)</p>
</li>
<li>
<p>Instalar aplicaciones desde el marketplace (ver módulo 5)</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_2_3_configuración_del_entorno">2.3 Configuración del entorno</h3>
<div class="paragraph">
<p>Una vez instalado Rancher, es fundamental configurar el entorno de forma segura y robusta antes de comenzar a gestionar clústeres.</p>
</div>
<div class="sect3">
<h4 id="_configuración_de_autenticación">Configuración de autenticación</h4>
<div class="paragraph">
<p>Rancher soporta múltiples métodos de autenticación. Por defecto usa autenticación local, pero en producción se recomienda integrar con sistemas externos.</p>
</div>
<div class="paragraph">
<p><strong>Tipos de autenticación disponibles</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 28. Métodos de autenticación soportados:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Método</th>
<th class="tableblock halign-left valign-top">Descripción</th>
<th class="tableblock halign-left valign-top">Uso recomendado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usuarios y contraseñas almacenados en Rancher</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Solo para desarrollo y testing</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active Directory (LDAP)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integración con Microsoft AD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Entornos corporativos Windows</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FreeIPA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integración con FreeIPA/Red Hat Identity Management</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Entornos corporativos Linux</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Azure AD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integración con Microsoft Azure AD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Entornos cloud Microsoft</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GitHub</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Autenticación mediante GitHub</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equipos de desarrollo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Google OAuth</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Autenticación con cuentas Google</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equipos pequeños, G Suite</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keycloak (OIDC/SAML)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integración con Keycloak</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Entornos complejos, SSO</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Okta</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integración con Okta</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Empresas con Okta</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Shibboleth (SAML)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Federación académica/corporativa</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Universidades, grandes empresas</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ping Identity</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integración con Ping</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Empresas enterprise</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenLDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP genérico</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servidores LDAP custom</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Autenticación local (por defecto)</strong></p>
</div>
<div class="paragraph">
<p>Ya configurada al instalar Rancher. Gestión básica de usuarios:</p>
</div>
<div class="listingblock">
<div class="title">Gestión de usuarios locales:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Via UI: Global → Security → Authentication → Users
# Para crear usuario vía API:

RANCHER_URL="https://rancher.example.com"
API_TOKEN="token-xxxxx:xxxxxxxxxxxxxx"

# Crear nuevo usuario local
curl -k -X POST "${RANCHER_URL}/v3/users" \
  -H "Authorization: Bearer ${API_TOKEN}" \
  -H 'Content-Type: application/json' \
  -d '{
    "type": "user",
    "username": "johndoe",
    "password": "SecurePassword123!",
    "name": "John Doe",
    "mustChangePassword": true,
    "enabled": true
  }'

# Listar usuarios
curl -k "${RANCHER_URL}/v3/users" \
  -H "Authorization: Bearer ${API_TOKEN}"

# Deshabilitar usuario
curl -k -X PUT "${RANCHER_URL}/v3/users/u-xxxxx" \
  -H "Authorization: Bearer ${API_TOKEN}" \
  -H 'Content-Type: application/json' \
  -d '{"enabled": false}'</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Configurar política de contraseñas</strong></p>
</div>
<div class="listingblock">
<div class="title">Política de contraseñas (via UI):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Global → Security → Authentication → Local

Opciones:
- Minimum Password Length: 12 caracteres
- Require at least one uppercase letter
- Require at least one lowercase letter
- Require at least one number
- Require at least one special character
- Password expiration: 90 días
- Password history: últimas 5 contraseñas</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_integración_con_proveedores_de_identidad_ldap_saml_oidc">Integración con proveedores de identidad (LDAP, SAML, OIDC)</h4>
<div class="paragraph">
<p><strong>Integración con Active Directory (LDAP)</strong></p>
</div>
<div class="paragraph">
<p>La integración más común en entornos corporativos.</p>
</div>
<div class="listingblock">
<div class="title">Configuración de Active Directory:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Ir a: Global → Security → Authentication → Active Directory

2. Configurar servidor:
   - Hostname: ad.example.com
   - Port: 636 (LDAPS) o 389 (LDAP)
   - TLS: Enabled (recomendado)
   - CA Certificate: (si usas certificado custom)

3. Service Account:
   - Distinguished Name: CN=rancher-svc,OU=Service Accounts,DC=example,DC=com
   - Password: &lt;password del service account&gt;

4. User Search Base:
   - DN: OU=Users,DC=example,DC=com
   - Search Filter: (&amp;(objectClass=user)(sAMAccountName={username}))
   - Username Attribute: sAMAccountName
   - Login Attribute: sAMAccountName
   - User Object Class: person

5. Group Search Base:
   - DN: OU=Groups,DC=example,DC=com
   - Search Filter: (objectClass=group)
   - Group Object Class: group
   - Group Name Attribute: cn
   - Group Member Mapping Attribute: member

6. Test connection:
   - Username: testuser
   - Password: &lt;contraseña&gt;
   - Verify: Should show user info and groups

7. Enable y Save</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Configuración de AD via API:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "activeDirectoryConfig",
  "enabled": true,
  "servers": ["ad.example.com"],
  "port": 636,
  "tls": true,
  "startTls": false,
  "serviceAccountDistinguishedName": "CN=rancher-svc,OU=Service Accounts,DC=example,DC=com",
  "serviceAccountPassword": "SecurePassword123!",
  "userSearchBase": "OU=Users,DC=example,DC=com",
  "userSearchFilter": "(&amp;(objectClass=user)(sAMAccountName={username}))",
  "userLoginAttribute": "sAMAccountName",
  "userNameAttribute": "cn",
  "userObjectClass": "person",
  "groupSearchBase": "OU=Groups,DC=example,DC=com",
  "groupSearchFilter": "(objectClass=group)",
  "groupObjectClass": "group",
  "groupNameAttribute": "cn",
  "groupMemberMappingAttribute": "member",
  "connectionTimeout": 5000,
  "nestedGroupMembershipEnabled": true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Integración con Keycloak (OIDC)</strong></p>
</div>
<div class="paragraph">
<p>OpenID Connect es el estándar moderno para autenticación.</p>
</div>
<div class="paragraph">
<div class="title">Configuración de Keycloak:</div>
<p><strong>Paso 1: Configurar cliente en Keycloak</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Login en Keycloak admin console
2. Ir a: Clients → Create Client
3. Configurar:
   - Client ID: rancher
   - Client Protocol: openid-connect
   - Access Type: confidential
   - Valid Redirect URIs: https://rancher.example.com/*
   - Web Origins: https://rancher.example.com
4. En Credentials tab:
   - Copiar Client Secret</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Paso 2: Configurar Rancher</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Ir a: Global → Security → Authentication → Keycloak (OIDC)

2. Configurar endpoints:
   - Auth Endpoint: https://keycloak.example.com/auth/realms/master/protocol/openid-connect/auth
   - Token Endpoint: https://keycloak.example.com/auth/realms/master/protocol/openid-connect/token
   - User Info Endpoint: https://keycloak.example.com/auth/realms/master/protocol/openid-connect/userinfo
   - JWKS Endpoint: https://keycloak.example.com/auth/realms/master/protocol/openid-connect/certs

3. Cliente OAuth:
   - Client ID: rancher
   - Client Secret: &lt;client secret from Keycloak&gt;
   - Scope: openid profile email groups

4. Test y Enable</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Configuración automatizada con Terraform:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">resource "rancher2_auth_config_keycloak_oidc" "keycloak" {
  display_name_field = "name"
  groups_field       = "groups"
  uid_field          = "sub"
  user_name_field    = "preferred_username"

  auth_endpoint       = "https://keycloak.example.com/auth/realms/master/protocol/openid-connect/auth"
  token_endpoint      = "https://keycloak.example.com/auth/realms/master/protocol/openid-connect/token"
  user_info_endpoint  = "https://keycloak.example.com/auth/realms/master/protocol/openid-connect/userinfo"

  client_id     = "rancher"
  client_secret = var.keycloak_client_secret

  enabled = true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Integración con Azure AD (SAML)</strong></p>
</div>
<div class="paragraph">
<div class="title">Configuración de Azure AD:</div>
<p><strong>Paso 1: Registrar aplicación en Azure AD</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Via Azure Portal:
1. Azure Active Directory → Enterprise Applications → New Application
2. Create your own application
3. Nombre: Rancher
4. Integrar cualquier otra aplicación que no encuentre en la galería (Non-gallery)

# Configurar SSO
1. Single sign-on → SAML
2. Basic SAML Configuration:
   - Identifier (Entity ID): https://rancher.example.com
   - Reply URL (ACS): https://rancher.example.com/v1-saml/acs/azure
3. User Attributes &amp; Claims:
   - Unique User Identifier: user.userprincipalname
   - Additional claims:
     - email: user.mail
     - givenname: user.givenname
     - surname: user.surname
     - groups: user.groups
4. SAML Certificates:
   - Descargar Federation Metadata XML
   - O copiar App Federation Metadata URL</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Paso 2: Configurar Rancher</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Ir a: Global → Security → Authentication → Azure AD

2. Configurar:
   - Display Name Field: givenname
   - User Name Field: email
   - UID Field: email
   - Groups Field: groups

   - Entity ID: https://rancher.example.com
   - Rancher API Host: https://rancher.example.com
   - IDP Metadata: &lt;pegar contenido del XML de Azure&gt;

3. Test y Enable</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Integración con GitHub</strong></p>
</div>
<div class="paragraph">
<p>Más simple, ideal para equipos de desarrollo.</p>
</div>
<div class="paragraph">
<div class="title">Configuración de GitHub OAuth:</div>
<p><strong>Paso 1: Crear OAuth App en GitHub</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. GitHub → Settings → Developer settings → OAuth Apps → New OAuth App
2. Configurar:
   - Application name: Rancher
   - Homepage URL: https://rancher.example.com
   - Authorization callback URL: https://rancher.example.com/verify-auth
3. Register application
4. Copiar Client ID y generar Client Secret</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Paso 2: Configurar Rancher</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Ir a: Global → Security → Authentication → GitHub

2. Configurar:
   - Client ID: &lt;from GitHub&gt;
   - Client Secret: &lt;from GitHub&gt;
   - GitHub Endpoint: https://github.com (para GitHub Enterprise usar URL custom)

3. Authenticate with GitHub
4. Autorizar en GitHub
5. Configure Authorization:
   - Allow any valid users
   - Allow members of Organizations: &lt;org1&gt;, &lt;org2&gt;
   - Allow members of Teams: &lt;org&gt;/&lt;team&gt;

6. Save</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Sincronización de grupos</strong></p>
</div>
<div class="paragraph">
<p>Para mapear grupos externos a roles en Rancher:</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de asignación de grupos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Crear Global Role Binding para grupo AD
curl -k -X POST "${RANCHER_URL}/v3/globalrolebindings" \
  -H "Authorization: Bearer ${API_TOKEN}" \
  -H 'Content-Type: application/json' \
  -d '{
    "type": "globalRoleBinding",
    "globalRoleId": "admin",
    "groupPrincipalId": "activedirectory_group://CN=RancherAdmins,OU=Groups,DC=example,DC=com"
  }'

# Crear Cluster Role Binding para grupo
curl -k -X POST "${RANCHER_URL}/v3/clusterroletemplatebindings" \
  -H "Authorization: Bearer ${API_TOKEN}" \
  -H 'Content-Type: application/json' \
  -d '{
    "type": "clusterRoleTemplateBinding",
    "clusterId": "c-xxxxx",
    "roleTemplateId": "cluster-owner",
    "groupPrincipalId": "activedirectory_group://CN=DevOps,OU=Groups,DC=example,DC=com"
  }'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_de_notificaciones">Configuración de notificaciones</h4>
<div class="paragraph">
<p>Rancher puede enviar notificaciones sobre eventos importantes del sistema.</p>
</div>
<div class="paragraph">
<p><strong>Tipos de notificadores disponibles</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 29. Notificadores soportados:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Descripción</th>
<th class="tableblock halign-left valign-top">Casos de uso</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Slack</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Webhooks a canales Slack</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equipos que usan Slack</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Email (SMTP)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Correos electrónicos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alertas críticas, reportes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PagerDuty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integración con PagerDuty</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equipos de operaciones 24/7</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Webhook</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP POST a endpoint custom</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integraciones personalizadas</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Microsoft Teams</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Webhooks a Teams</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equipos que usan Microsoft Teams</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DingTalk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integración con DingTalk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Equipos en Asia-Pacífico</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Configurar notificaciones Slack</strong></p>
</div>
<div class="paragraph">
<div class="title">Configuración de Slack:</div>
<p><strong>Paso 1: Crear Incoming Webhook en Slack</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Ir a: https://api.slack.com/apps
2. Create New App → From scratch
3. Nombre: Rancher Notifications
4. Seleccionar workspace
5. Incoming Webhooks → Activate
6. Add New Webhook to Workspace
7. Seleccionar canal destino (#rancher-alerts)
8. Copiar Webhook URL: https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXX</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Paso 2: Configurar en Rancher</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text"># Via UI:
1. Cluster → Tools → Notifiers → Add Notifier
2. Tipo: Slack
3. Configurar:
   - Name: slack-alerts
   - Webhook URL: &lt;URL de Slack&gt;
   - Default Channel: #rancher-alerts
   - Proxy URL: (si aplica)

# Via API:
curl -k -X POST "${RANCHER_URL}/v3/notifiers" \
  -H "Authorization: Bearer ${API_TOKEN}" \
  -H 'Content-Type: application/json' \
  -d '{
    "type": "notifier",
    "clusterId": "c-xxxxx",
    "name": "slack-alerts",
    "slackConfig": {
      "defaultRecipient": "#rancher-alerts",
      "url": "https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXX"
    }
  }'</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Configurar notificaciones Email (SMTP)</strong></p>
</div>
<div class="listingblock">
<div class="title">Configuración de SMTP:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Tools → Notifiers → Add Notifier
2. Tipo: Email
3. Configurar SMTP:
   - Default Recipient: alerts@example.com
   - SMTP Server: smtp.gmail.com
   - Port: 587
   - Use TLS: Yes
   - Username: rancher@example.com
   - Password: &lt;app password&gt;
   - Sender: rancher@example.com</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo con Gmail:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "type": "notifier",
  "clusterId": "c-xxxxx",
  "name": "email-alerts",
  "smtpConfig": {
    "defaultRecipient": "alerts@example.com",
    "host": "smtp.gmail.com",
    "port": 587,
    "username": "rancher@example.com",
    "password": "app-specific-password",
    "sender": "rancher@example.com",
    "tls": true
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Configurar notificaciones PagerDuty</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. En PagerDuty:
   - Services → Rancher → Integrations → Add Integration
   - Integration Type: Events API V2
   - Copiar Integration Key

2. En Rancher:
   - Cluster → Tools → Notifiers → Add Notifier
   - Tipo: PagerDuty
   - Integration Key: &lt;key de PagerDuty&gt;
   - Service Key Type: Integration Key</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Configurar alertas</strong></p>
</div>
<div class="paragraph">
<p>Una vez configurados los notificadores, crear reglas de alerta:</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de alerta para uso alto de CPU:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Via UI: Cluster → Tools → Alerts → Add Alert
# O via YAML:

apiVersion: management.cattle.io/v3
kind: ClusterAlertRule
metadata:
  name: high-cpu-alert
  namespace: c-xxxxx
spec:
  clusterName: c-xxxxx
  displayName: "High CPU Usage"
  groupName: cluster-alerts
  recipients:
    - notifier: slack-alerts
      recipient: "#critical-alerts"
  metricRule:
    comparison: greater-than
    duration: 5m
    expression: avg(cpu_usage)
    threshold: 80
    description: "CPU usage above 80% for 5 minutes"
  severity: critical</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Tipos de alertas disponibles:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. System Events:
   - Node down
   - Pod crashlooping
   - Deployment failed

2. Resource Alerts:
   - High CPU usage
   - High memory usage
   - Disk space low

3. Workload Alerts:
   - Pod not running
   - Available replicas below threshold

4. Event-based:
   - Kubernetes events (warning/error)</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Testing de notificaciones</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Test notifier via API
curl -k -X POST "${RANCHER_URL}/v3/notifiers/c-xxxxx:n-xxxxx?action=send" \
  -H "Authorization: Bearer ${API_TOKEN}" \
  -H 'Content-Type: application/json' \
  -d '{
    "message": "Test notification from Rancher",
    "recipient": "#test-channel"
  }'

# Generar alerta de prueba
kubectl run test-pod --image=nginx --limits=cpu=50m,memory=50Mi
kubectl delete pod test-pod
# Debería generar alerta de pod deleted</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_backup_y_restauración_del_servidor_rancher">Backup y restauración del servidor Rancher</h4>
<div class="paragraph">
<p>El backup regular es crítico para disaster recovery.</p>
</div>
<div class="paragraph">
<p><strong>Componentes a respaldar</strong></p>
</div>
<div class="listingblock">
<div class="title">Datos críticos en Rancher:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Local cluster etcd:
   - Contiene toda la configuración de Rancher
   - Clústeres registrados
   - Usuarios, roles, permisos
   - Apps instaladas
   - Configuración de cattle-system

2. Persistent volumes (si aplica):
   - Logs de auditoría
   - Monitoring data

3. Secrets de Kubernetes:
   - Certificados SSL
   - Tokens de API
   - Credenciales de clústeres downstream</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 1: Backup con rancher-backup operator (recomendado)</strong></p>
</div>
<div class="paragraph">
<p>El método oficial y más robusto.</p>
</div>
<div class="listingblock">
<div class="title">Instalar rancher-backup:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Via Helm
helm repo add rancher-charts https://charts.rancher.io
helm repo update

# Instalar el operador
helm install rancher-backup-crd rancher-charts/rancher-backup-crd \
  --namespace cattle-resources-system \
  --create-namespace

helm install rancher-backup rancher-charts/rancher-backup \
  --namespace cattle-resources-system

# Verificar instalación
kubectl -n cattle-resources-system get pods -l app.kubernetes.io/name=rancher-backup</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Configurar S3 storage para backups:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Secret
metadata:
  name: s3-creds
  namespace: cattle-resources-system
type: Opaque
stringData:
  accessKey: &lt;AWS_ACCESS_KEY_ID&gt;
  secretKey: &lt;AWS_SECRET_ACCESS_KEY&gt;
---
apiVersion: resources.cattle.io/v1
kind: Backup
metadata:
  name: rancher-backup-daily
  namespace: cattle-resources-system
spec:
  resourceSetName: rancher-resource-set
  schedule: "0 2 * * *"  # Daily at 2 AM
  retentionCount: 30
  storageLocation:
    s3:
      credentialSecretName: s3-creds
      credentialSecretNamespace: cattle-resources-system
      bucketName: rancher-backups
      folder: prod
      region: us-east-1
      endpoint: s3.amazonaws.com</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Backup manual (on-demand):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: resources.cattle.io/v1
kind: Backup
metadata:
  name: rancher-backup-manual
  namespace: cattle-resources-system
spec:
  resourceSetName: rancher-resource-set
  storageLocation:
    s3:
      credentialSecretName: s3-creds
      credentialSecretNamespace: cattle-resources-system
      bucketName: rancher-backups
      folder: manual
      region: us-east-1
      endpoint: s3.amazonaws.com</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Aplicar backup:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f backup.yaml

# Verificar estado
kubectl -n cattle-resources-system get backups
kubectl -n cattle-resources-system describe backup rancher-backup-manual

# Ver logs
kubectl -n cattle-resources-system logs -l app.kubernetes.io/name=rancher-backup</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 2: Backup de etcd (clúster local)</strong></p>
</div>
<div class="paragraph">
<p>Para backups más bajos nivel del clúster Kubernetes de Rancher.</p>
</div>
<div class="listingblock">
<div class="title">Backup de etcd con RKE2:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># RKE2 hace snapshots automáticos cada 12 horas
# Ubicación: /var/lib/rancher/rke2/server/db/snapshots/

# Backup manual
rke2 etcd-snapshot save --name manual-backup-$(date +%Y%m%d-%H%M%S)

# Listar snapshots
rke2 etcd-snapshot list

# Configurar snapshots automáticos
cat &gt; /etc/rancher/rke2/config.yaml &lt;&lt;EOF
etcd-snapshot-schedule-cron: "0 */6 * * *"  # Cada 6 horas
etcd-snapshot-retention: 14  # Mantener 14 snapshots
etcd-snapshot-dir: /var/lib/rancher/rke2/server/db/snapshots
EOF

systemctl restart rke2-server</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Backup de etcd con RKE1:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Con RKE CLI
rke etcd snapshot-save \
  --config cluster.yml \
  --name manual-backup-$(date +%Y%m%d-%H%M%S)

# Backups automáticos configurados en cluster.yml
services:
  etcd:
    backup_config:
      enabled: true
      interval_hours: 6
      retention: 14
      s3_backup_config:
        access_key: &lt;AWS_ACCESS_KEY&gt;
        secret_key: &lt;AWS_SECRET_KEY&gt;
        bucket_name: rancher-etcd-backups
        region: us-east-1
        folder: prod</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 3: Backup con Docker (single-node)</strong></p>
</div>
<div class="paragraph">
<p>Para instalaciones de desarrollo con Docker.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Backup del contenedor completo
docker stop rancher
docker commit rancher rancher-backup-$(date +%Y%m%d)
docker start rancher

# Backup del volumen
docker run --rm \
  -v rancher-data:/source:ro \
  -v $(pwd):/backup \
  alpine tar czf /backup/rancher-backup-$(date +%Y%m%d).tar.gz -C /source .

# Listar backups
ls -lh rancher-backup-*.tar.gz</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Restauración del servidor Rancher</strong></p>
</div>
<div class="listingblock">
<div class="title">Restaurar con rancher-backup operator:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: resources.cattle.io/v1
kind: Restore
metadata:
  name: restore-rancher
  namespace: cattle-resources-system
spec:
  backupFilename: rancher-backup-daily-20251030-020000.tar.gz
  storageLocation:
    s3:
      credentialSecretName: s3-creds
      credentialSecretNamespace: cattle-resources-system
      bucketName: rancher-backups
      folder: prod
      region: us-east-1
      endpoint: s3.amazonaws.com</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f restore.yaml

# Monitorear restauración
kubectl -n cattle-resources-system get restores
kubectl -n cattle-resources-system describe restore restore-rancher
kubectl -n cattle-resources-system logs -l app.kubernetes.io/name=rancher-backup

# Reiniciar Rancher después de restauración
kubectl -n cattle-system rollout restart deploy/rancher</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Restaurar desde snapshot de etcd (RKE2):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Detener RKE2
systemctl stop rke2-server

# Restaurar snapshot
rke2 server \
  --cluster-reset \
  --cluster-reset-restore-path=/var/lib/rancher/rke2/server/db/snapshots/manual-backup-20251030-120000

# Iniciar RKE2
systemctl start rke2-server

# Verificar clúster
export KUBECONFIG=/etc/rancher/rke2/rke2.yaml
kubectl get nodes
kubectl -n cattle-system get pods</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Restaurar con Docker:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Desde imagen backup
docker stop rancher
docker rm rancher
docker run -d --restart=unless-stopped \
  -p 80:80 -p 443:443 \
  --privileged \
  --name rancher \
  rancher-backup-20251030

# Desde volumen backup
docker volume create rancher-data-restored
docker run --rm \
  -v rancher-data-restored:/target \
  -v $(pwd):/backup \
  alpine sh -c "cd /target &amp;&amp; tar xzf /backup/rancher-backup-20251030.tar.gz"

docker run -d --restart=unless-stopped \
  -p 80:80 -p 443:443 \
  --privileged \
  --name rancher \
  -v rancher-data-restored:/var/lib/rancher \
  rancher/rancher:v2.9.3</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Disaster Recovery completo</strong></p>
</div>
<div class="listingblock">
<div class="title">Procedimiento completo de DR:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
# Script de disaster recovery de Rancher

echo "=== Rancher Disaster Recovery ==="

# 1. Preparar nuevo clúster Kubernetes
echo "1. Preparando clúster Kubernetes..."
# (Instalar RKE2/K3s según necesidad)

# 2. Instalar cert-manager
echo "2. Instalando cert-manager..."
helm install cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --version v1.14.0 \
  --set installCRDs=true
kubectl wait --for=condition=Available --timeout=300s -n cert-manager deployment --all

# 3. Instalar rancher-backup operator
echo "3. Instalando rancher-backup operator..."
helm install rancher-backup-crd rancher-charts/rancher-backup-crd \
  --namespace cattle-resources-system \
  --create-namespace
helm install rancher-backup rancher-charts/rancher-backup \
  --namespace cattle-resources-system

# 4. Instalar Rancher
echo "4. Instalando Rancher..."
kubectl create namespace cattle-system
helm install rancher rancher-stable/rancher \
  --namespace cattle-system \
  --set hostname=rancher.example.com \
  --set replicas=3 \
  --set bootstrapPassword=temp123
kubectl -n cattle-system rollout status deploy/rancher

# 5. Restaurar backup
echo "5. Restaurando backup..."
cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: resources.cattle.io/v1
kind: Restore
metadata:
  name: restore-dr
  namespace: cattle-resources-system
spec:
  backupFilename: rancher-backup-latest.tar.gz
  storageLocation:
    s3:
      credentialSecretName: s3-creds
      credentialSecretNamespace: cattle-resources-system
      bucketName: rancher-backups
      folder: prod
      region: us-east-1
EOF

# 6. Esperar restauración
echo "6. Esperando restauración..."
kubectl -n cattle-resources-system wait --for=condition=Complete --timeout=600s restore/restore-dr

# 7. Reiniciar Rancher
echo "7. Reiniciando Rancher..."
kubectl -n cattle-system rollout restart deploy/rancher
kubectl -n cattle-system rollout status deploy/rancher

# 8. Verificar
echo "8. Verificando instalación..."
kubectl -n cattle-system get pods
kubectl get clusters

echo "=== DR completado ==="
echo "Accede a: https://rancher.example.com"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Best practices para backup</strong></p>
</div>
<div class="listingblock">
<div class="title">Recomendaciones:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Frecuencia:
   - Backups automáticos cada 6-12 horas
   - Backup manual antes de cada cambio importante
   - Backup antes de actualizar Rancher

2. Retención:
   - Mantener últimos 7-14 backups diarios
   - Backups semanales por 3 meses
   - Backups mensuales por 1 año

3. Almacenamiento:
   - Usar S3 o storage externo (no local)
   - Cifrar backups en reposo
   - Replicar en múltiples regiones

4. Testing:
   - Probar restauración mensualmente
   - Documentar tiempo de recovery (RTO)
   - Documentar pérdida de datos aceptable (RPO)

5. Monitoreo:
   - Alertar si backup falla
   - Verificar integridad de backups
   - Documentar proceso de DR</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Verificación de backup</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Verificar último backup exitoso
kubectl -n cattle-resources-system get backups -o json | \
  jq '.items | sort_by(.status.completedAt) | last | {name: .metadata.name, completed: .status.completedAt, size: .status.storageSize}'

# Verificar backups en S3
aws s3 ls s3://rancher-backups/prod/ --recursive --human-readable

# Test de restauración en clúster de prueba
kubectl apply -f test-restore.yaml
kubectl -n cattle-resources-system logs -f -l app.kubernetes.io/name=rancher-backup

# Comparar configuración antes/después del backup
kubectl get all -A --export &gt; pre-backup.yaml
# Hacer backup y restauración
kubectl get all -A --export &gt; post-restore.yaml
diff pre-backup.yaml post-restore.yaml</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_3_gestión_de_clústeres_kubernetes">Módulo 3: Gestión de Clústeres Kubernetes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_3_1_creación_de_nuevos_clústeres">3.1 Creación de nuevos clústeres</h3>
<div class="paragraph">
<p>Rancher facilita la creación y gestión de clústeres Kubernetes mediante diferentes métodos. Puede crear clústeres desde cero, importar clústeres existentes, o usar clústeres gestionados de proveedores cloud.</p>
</div>
<div class="sect3">
<h4 id="_creación_de_clústeres_rke_rancher_kubernetes_engine">Creación de clústeres RKE (Rancher Kubernetes Engine)</h4>
<div class="paragraph">
<p>RKE (Rancher Kubernetes Engine) y RKE2 son las distribuciones de Kubernetes creadas y mantenidas por Rancher. RKE2 es la evolución de RKE con mayor seguridad y certificación del gobierno de EE.UU.</p>
</div>
<div class="paragraph">
<p><strong>Diferencias entre RKE1 y RKE2</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 30. Comparación RKE1 vs RKE2:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Característica</th>
<th class="tableblock halign-left valign-top">RKE1</th>
<th class="tableblock halign-left valign-top">RKE2</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arquitectura</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basado en Docker</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basado en containerd</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Certificación</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CNCF Certified</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CNCF Certified + FIPS 140-2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Security Hardening</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Manual</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CIS Hardening by default</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Control Plane</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Como contenedores Docker</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Como procesos systemd</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Actualizaciones</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Más manual</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rolling updates integradas</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Windows Support</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Limitado</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Completo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recomendación</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Legacy (mantenimiento)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nuevas instalaciones</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Método 1: Crear clúster RKE2 con infraestructura existente</strong></p>
</div>
<div class="paragraph">
<p>Este método asume que ya tienes VMs o servidores bare metal preparados.</p>
</div>
<div class="listingblock">
<div class="title">Crear clúster RKE2 desde Rancher UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. En Rancher UI:
   - Cluster Management → Create
   - Seleccionar "Custom" cluster
   - Nombre: production-cluster

2. Configuración básica:
   - Kubernetes Version: v1.28.15+rke2r1 (seleccionar última stable)
   - Network Provider: Cilium (o Calico/Canal)
   - Cloud Provider: None (o seleccionar si es AWS/Azure/GCP)

3. Configuración de nodos:
   Seleccionar roles para cada nodo:
   - etcd: Al menos 3 nodos (número impar)
   - Control Plane: Al menos 3 nodos (para HA)
   - Worker: Según capacidad necesaria

   Mejores prácticas:
   - Dedicar nodos separados para etcd + controlplane
   - Workers solo para workloads
   - O combinar etcd + controlplane + worker en clústeres pequeños

4. Member Roles:
   - Add Member: Asignar usuarios/grupos con roles

5. Labels &amp; Annotations:
   - Añadir labels para organización:
     environment: production
     region: us-east-1
     owner: platform-team

6. Advanced Options:
   - Additional Controller Manager Args:
     --node-monitor-grace-period=40s
   - Additional Scheduler Args:
     --bind-address=0.0.0.0
   - Additional API Server Args:
     --audit-log-path=/var/log/kube-audit/audit.log

7. Registro de nodos:
   Al crear, Rancher genera comandos de registro</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Comandos de registro de nodos</strong></p>
</div>
<div class="paragraph">
<p>Rancher genera comandos únicos para cada clúster:</p>
</div>
<div class="listingblock">
<div class="title">Registrar nodo con todos los roles (small cluster):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># En el nodo Linux (Ubuntu/RHEL/SLES)
sudo curl -fL https://rancher.example.com/system-agent-install.sh | \
  sudo sh -s - --server https://rancher.example.com \
  --label 'cattle.io/os=linux' \
  --token &lt;registration-token&gt; \
  --ca-checksum &lt;ca-checksum&gt; \
  --etcd --controlplane --worker</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Registrar nodos dedicados para HA:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Nodos 1-3: etcd + controlplane (sin workloads)
sudo curl -fL https://rancher.example.com/system-agent-install.sh | \
  sudo sh -s - --server https://rancher.example.com \
  --label 'cattle.io/os=linux' \
  --token &lt;registration-token&gt; \
  --ca-checksum &lt;ca-checksum&gt; \
  --etcd --controlplane

# Nodos 4+: workers (solo workloads)
sudo curl -fL https://rancher.example.com/system-agent-install.sh | \
  sudo sh -s - --server https://rancher.example.com \
  --label 'cattle.io/os=linux' \
  --token &lt;registration-token&gt; \
  --ca-checksum &lt;ca-checksum&gt; \
  --worker

# Para Windows workers
# Ejecutar PowerShell script proporcionado por Rancher UI</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Preparación de nodos antes de registro</strong></p>
</div>
<div class="listingblock">
<div class="title">Requisitos en cada nodo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
# Script de preparación de nodo para RKE2

set -e

echo "=== Preparando nodo para RKE2 ==="

# 1. Actualizar sistema
echo "1. Actualizando sistema..."
apt-get update &amp;&amp; apt-get upgrade -y  # Ubuntu/Debian
# yum update -y  # RHEL/CentOS

# 2. Deshabilitar swap
echo "2. Deshabilitando swap..."
swapoff -a
sed -i '/swap/d' /etc/fstab

# 3. Configurar módulos del kernel
echo "3. Configurando módulos kernel..."
cat &lt;&lt;EOF | tee /etc/modules-load.d/k8s.conf
overlay
br_netfilter
EOF

modprobe overlay
modprobe br_netfilter

# 4. Configurar sysctl
echo "4. Configurando sysctl..."
cat &lt;&lt;EOF | tee /etc/sysctl.d/k8s.conf
net.bridge.bridge-nf-call-iptables  = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.ipv4.ip_forward                 = 1
EOF

sysctl --system

# 5. Instalar dependencias
echo "5. Instalando dependencias..."
apt-get install -y curl wget tar  # Ubuntu/Debian
# yum install -y curl wget tar  # RHEL/CentOS

# 6. Configurar firewall (ejemplo UFW en Ubuntu)
echo "6. Configurando firewall..."
ufw allow 22/tcp    # SSH
ufw allow 80/tcp    # HTTP
ufw allow 443/tcp   # HTTPS
ufw allow 6443/tcp  # Kubernetes API
ufw allow 2379:2380/tcp  # etcd
ufw allow 10250/tcp # kubelet
ufw allow 30000:32767/tcp  # NodePort Services

# 7. Configurar NTP
echo "7. Configurando NTP..."
apt-get install -y chrony
systemctl enable chrony
systemctl start chrony

# 8. Verificar conectividad a Rancher
echo "8. Verificando conectividad a Rancher..."
curl -k https://rancher.example.com/ping &amp;&amp; echo "✓ Rancher accesible" || echo "✗ No se puede alcanzar Rancher"

# 9. Configurar hostname único
echo "9. Configurando hostname..."
hostnamectl set-hostname node-$(hostname -I | awk '{print $1}' | tr '.' '-')

echo "=== Nodo preparado ==="
echo "Ejecutar comando de registro de Rancher ahora"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 2: Crear clúster RKE2 en proveedores cloud</strong></p>
</div>
<div class="paragraph">
<p>Rancher puede crear clústeres directamente en AWS, Azure, GCP, etc.</p>
</div>
<div class="listingblock">
<div class="title">Crear clúster en AWS (EC2):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Prerequisitos:
   - Cloud Credentials configuradas en Rancher
   - Ir a: Cluster Management → Cloud Credentials → Create
   - Tipo: AWS
   - Access Key: &lt;AWS_ACCESS_KEY_ID&gt;
   - Secret Key: &lt;AWS_SECRET_ACCESS_KEY&gt;

2. Crear clúster:
   - Cluster Management → Create
   - Seleccionar: Amazon EC2

3. Configuración:
   Cluster Name: aws-production

   Machine Pools:

   Pool 1 - Control Plane + etcd:
   - Count: 3
   - Instance Type: t3.medium (2 vCPU, 4 GB RAM)
   - Roles: etcd + controlplane
   - Root Disk Size: 40 GB
   - Region: us-east-1
   - Zone: us-east-1a, us-east-1b, us-east-1c

   Pool 2 - Workers:
   - Count: 5
   - Instance Type: t3.xlarge (4 vCPU, 16 GB RAM)
   - Roles: worker
   - Root Disk Size: 100 GB
   - Region: us-east-1
   - Zone: us-east-1a, us-east-1b, us-east-1c

4. Network Configuration:
   - VPC: Create new (o usar existente)
   - Subnet: Auto-create
   - Security Group: Auto-create
   - Public IP: Yes (para acceso inicial)

5. Labels &amp; Taints:
   - Labels para workers:
     workload.type: general
     zone: us-east-1a
   - Taints (opcional):
     dedicated=gpu:NoSchedule (para nodos GPU)

6. Create</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Crear clúster en Azure (AKS):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cloud Credentials (Azure):
   - Subscription ID
   - Client ID (App ID)
   - Client Secret
   - Tenant ID

2. Crear clúster:
   - Cluster Management → Create
   - Seleccionar: Azure AKS

3. Configuración:
   Cluster Name: azure-production
   Resource Group: rancher-clusters (nuevo o existente)
   Region: East US
   Kubernetes Version: 1.28.5

   Node Pools:

   System Pool:
   - Count: 3
   - VM Size: Standard_D4s_v3
   - OS Disk Size: 100 GB
   - Mode: System

   User Pool:
   - Count: 5
   - VM Size: Standard_D8s_v3
   - OS Disk Size: 200 GB
   - Mode: User

4. Networking:
   - Network Plugin: Azure CNI (o kubenet)
   - Service CIDR: 10.0.0.0/16
   - DNS Service IP: 10.0.0.10
   - Docker Bridge CIDR: 172.17.0.1/16
   - Load Balancer SKU: Standard

5. Create</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 3: Crear clúster RKE1 (legacy)</strong></p>
</div>
<div class="paragraph">
<p>Para compatibilidad con instalaciones antiguas.</p>
</div>
<div class="listingblock">
<div class="title">Crear clúster RKE1:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. En Rancher UI:
   - Cluster Management → Create
   - Seleccionar "Custom" cluster
   - Toggle: Use existing nodes and create cluster using RKE

2. Configuración:
   - Nombre: legacy-cluster
   - Kubernetes Version: v1.27.10-rancher2-1
   - Network Provider: Canal
   - Enable Project Network Isolation: Yes

3. Registrar nodos con Docker:
   # Nodos deben tener Docker instalado
   sudo docker run -d --privileged --restart=unless-stopped \
     --net=host -v /etc/kubernetes:/etc/kubernetes \
     -v /var/run:/var/run \
     rancher/rancher-agent:v2.9.3 \
     --server https://rancher.example.com \
     --token &lt;token&gt; \
     --ca-checksum &lt;checksum&gt; \
     --etcd --controlplane --worker</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 4: Crear clúster con Terraform</strong></p>
</div>
<div class="paragraph">
<p>Automatización completa con Infrastructure as Code.</p>
</div>
<div class="listingblock">
<div class="title">Terraform para clúster RKE2 en AWS:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">terraform {
  required_providers {
    rancher2 = {
      source  = "rancher/rancher2"
      version = "~&gt; 4.0"
    }
    aws = {
      source  = "hashicorp/aws"
      version = "~&gt; 5.0"
    }
  }
}

provider "rancher2" {
  api_url   = "https://rancher.example.com"
  token_key = var.rancher_token
  insecure  = false
}

provider "aws" {
  region = var.aws_region
}

# Cloud Credential
resource "rancher2_cloud_credential" "aws" {
  name = "aws-credentials"
  amazonec2_credential_config {
    access_key = var.aws_access_key
    secret_key = var.aws_secret_key
  }
}

# Machine Config Template para control plane
resource "rancher2_machine_config_v2" "controlplane" {
  generate_name = "controlplane"
  amazonec2_config {
    ami                 = "ami-0c55b159cbfafe1f0"  # Ubuntu 22.04
    region              = var.aws_region
    security_group      = [aws_security_group.rancher_cluster.name]
    subnet_id           = aws_subnet.rancher.id
    vpc_id              = aws_vpc.rancher.id
    zone                = "a"
    root_size           = "40"
    instance_type       = "t3.medium"
    ssh_user            = "ubuntu"
    iam_instance_profile = aws_iam_instance_profile.rancher_node.name
  }
}

# Machine Config Template para workers
resource "rancher2_machine_config_v2" "worker" {
  generate_name = "worker"
  amazonec2_config {
    ami                 = "ami-0c55b159cbfafe1f0"
    region              = var.aws_region
    security_group      = [aws_security_group.rancher_cluster.name]
    subnet_id           = aws_subnet.rancher.id
    vpc_id              = aws_vpc.rancher.id
    zone                = "a"
    root_size           = "100"
    instance_type       = "t3.xlarge"
    ssh_user            = "ubuntu"
    iam_instance_profile = aws_iam_instance_profile.rancher_node.name
  }
}

# Clúster RKE2
resource "rancher2_cluster_v2" "production" {
  name                   = "production-cluster"
  kubernetes_version     = "v1.28.15+rke2r1"
  enable_network_policy  = true
  default_pod_security_policy_template_name = "restricted"

  rke_config {
    machine_pools {
      name                         = "controlplane-pool"
      cloud_credential_secret_name = rancher2_cloud_credential.aws.id
      control_plane_role           = true
      etcd_role                    = true
      worker_role                  = false
      quantity                     = 3
      machine_config {
        kind = rancher2_machine_config_v2.controlplane.kind
        name = rancher2_machine_config_v2.controlplane.name
      }
    }

    machine_pools {
      name                         = "worker-pool"
      cloud_credential_secret_name = rancher2_cloud_credential.aws.id
      control_plane_role           = false
      etcd_role                    = false
      worker_role                  = true
      quantity                     = 5
      machine_config {
        kind = rancher2_machine_config_v2.worker.kind
        name = rancher2_machine_config_v2.worker.name
      }
    }

    machine_selector_config {
      config = {
        protect-kernel-defaults = true
      }
    }

    upgrade_strategy {
      control_plane_concurrency = "1"
      worker_concurrency        = "2"

      control_plane_drain_options {
        enabled = true
        delete_empty_dir_data = true
        timeout = 300
      }

      worker_drain_options {
        enabled = true
        delete_empty_dir_data = true
        timeout = 300
      }
    }

    etcd {
      snapshot_schedule_cron = "0 */6 * * *"
      snapshot_retention     = 14
      s3_config {
        bucket = "rancher-etcd-backups"
        region = var.aws_region
        folder = "production"
      }
    }

    chart_values = &lt;&lt;EOF
rke2-cilium:
  ipam:
    mode: kubernetes
  tunnel: vxlan
EOF
  }

  agent_env_vars {
    name  = "HTTP_PROXY"
    value = var.proxy_url
  }
}

# Outputs
output "cluster_id" {
  value = rancher2_cluster_v2.production.cluster_v1_id
}

output "kubeconfig" {
  value     = rancher2_cluster_v2.production.kube_config
  sensitive = true
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_de_nodos_y_roles">Configuración de nodos y roles</h4>
<div class="paragraph">
<p>Los nodos en Kubernetes pueden tener diferentes roles según su función en el clúster.</p>
</div>
<div class="paragraph">
<p><strong>Roles de nodos en Rancher</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 31. Roles disponibles:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Rol</th>
<th class="tableblock halign-left valign-top">Función</th>
<th class="tableblock halign-left valign-top">Requisitos mínimos</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">etcd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Base de datos del clúster (key-value store)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 CPU, 4 GB RAM, 50 GB disco</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Control Plane</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">API server, scheduler, controller manager</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2 CPU, 4 GB RAM, 50 GB disco</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Worker</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ejecuta workloads (pods)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Según workloads (mín: 2 CPU, 4 GB RAM)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Arquitecturas recomendadas</strong></p>
</div>
<div class="listingblock">
<div class="title">Clúster pequeño (desarrollo/testing):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-plantuml hljs" data-lang="plantuml">@startuml
!define RECTANGLE rectangle

skinparam backgroundColor transparent
skinparam rectangle {
  BackgroundColor&lt;&lt;etcd&gt;&gt; LightYellow
  BackgroundColor&lt;&lt;controlplane&gt;&gt; LightBlue
  BackgroundColor&lt;&lt;worker&gt;&gt; LightGreen
}

RECTANGLE "Node 1" &lt;&lt;etcd&gt;&gt; as n1 {
  [etcd]
  [Control Plane]
  [Worker]
}

RECTANGLE "Node 2" &lt;&lt;etcd&gt;&gt; as n2 {
  [etcd]
  [Control Plane]
  [Worker]
}

RECTANGLE "Node 3" &lt;&lt;etcd&gt;&gt; as n3 {
  [etcd]
  [Control Plane]
  [Worker]
}

note right of n1
  Todos los roles combinados
  3 nodos mínimo para HA
  Económico pero menos aislado
end note

@enduml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Clúster mediano (staging):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-plantuml hljs" data-lang="plantuml">@startuml
!define RECTANGLE rectangle

skinparam backgroundColor transparent

RECTANGLE "Control Plane Pool" as cp {
  RECTANGLE "Node 1" {
    [etcd]
    [Control Plane]
  }
  RECTANGLE "Node 2" {
    [etcd]
    [Control Plane]
  }
  RECTANGLE "Node 3" {
    [etcd]
    [Control Plane]
  }
}

RECTANGLE "Worker Pool" as wp {
  RECTANGLE "Worker 1" {
    [Worker]
  }
  RECTANGLE "Worker 2" {
    [Worker]
  }
  RECTANGLE "Worker 3" {
    [Worker]
  }
  RECTANGLE "..." {
  }
}

cp --&gt; wp : gestiona

note right of cp
  Control plane dedicado
  Workers separados
  Mejor aislamiento
  Escalado independiente
end note

@enduml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Clúster grande (producción):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-plantuml hljs" data-lang="plantuml">@startuml
!define RECTANGLE rectangle

skinparam backgroundColor transparent

RECTANGLE "etcd Pool" as etcd {
  RECTANGLE "etcd 1"
  RECTANGLE "etcd 2"
  RECTANGLE "etcd 3"
}

RECTANGLE "Control Plane Pool" as cp {
  RECTANGLE "CP 1" {
    [API Server]
    [Scheduler]
    [Controller]
  }
  RECTANGLE "CP 2" {
    [API Server]
    [Scheduler]
    [Controller]
  }
  RECTANGLE "CP 3" {
    [API Server]
    [Scheduler]
    [Controller]
  }
}

RECTANGLE "Worker Pool General" as wg {
  RECTANGLE "Worker 1-N"
}

RECTANGLE "Worker Pool GPU" as gpu {
  RECTANGLE "GPU Worker 1-M"
}

etcd --&gt; cp : datos
cp --&gt; wg : gestiona
cp --&gt; gpu : gestiona

note right of etcd
  Máxima separación
  etcd dedicado
  Control plane dedicado
  Workers especializados
  Mejor rendimiento
end note

@enduml</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Taints y tolerations para workers especializados</strong></p>
</div>
<div class="listingblock">
<div class="title">Aplicar taints a nodos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Via kubectl (después de crear clúster)
kubectl taint nodes gpu-node-1 dedicated=gpu:NoSchedule

# Via labels en Rancher durante creación:
# En Node Template o Machine Pool:
# Taints: dedicated=gpu:NoSchedule

# Para remover taint
kubectl taint nodes gpu-node-1 dedicated=gpu:NoSchedule-</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Configurar tolerations en deployments:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: ml-training
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ml-training
  template:
    metadata:
      labels:
        app: ml-training
    spec:
      tolerations:
      - key: "dedicated"
        operator: "Equal"
        value: "gpu"
        effect: "NoSchedule"
      nodeSelector:
        accelerator: nvidia-tesla-v100
      containers:
      - name: training
        image: tensorflow/tensorflow:latest-gpu
        resources:
          limits:
            nvidia.com/gpu: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Node labels y selectors</strong></p>
</div>
<div class="listingblock">
<div class="title">Añadir labels personalizados:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Via kubectl
kubectl label nodes worker-1 workload.type=memory-intensive
kubectl label nodes worker-2 workload.type=cpu-intensive
kubectl label nodes worker-3 zone=us-east-1a
kubectl label nodes worker-4 storage=ssd

# Ver labels de un nodo
kubectl get node worker-1 --show-labels

# Usar nodeSelector en pod
apiVersion: v1
kind: Pod
metadata:
  name: redis
spec:
  nodeSelector:
    workload.type: memory-intensive
    storage: ssd
  containers:
  - name: redis
    image: redis:7</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_personalización_de_versiones_de_kubernetes">Personalización de versiones de Kubernetes</h4>
<div class="paragraph">
<p>Rancher soporta múltiples versiones de Kubernetes simultáneamente.</p>
</div>
<div class="paragraph">
<p><strong>Versiones disponibles</strong></p>
</div>
<div class="listingblock">
<div class="title">Listar versiones disponibles:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Via Rancher UI:
# Cluster Management → Create → Ver dropdown de Kubernetes Version

# Via API:
curl -sk -X GET "${RANCHER_URL}/v1/management.cattle.io.k8sversions" \
  -H "Authorization: Bearer ${API_TOKEN}" | \
  jq -r '.data[] | "\(.id) - \(.serverVersion)"'

# Output ejemplo:
# v1.28.15+rke2r1 - v1.28.15
# v1.27.16+rke2r1 - v1.27.16
# v1.26.15+rke2r1 - v1.26.15</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Matriz de compatibilidad</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 32. Versiones soportadas por Rancher 2.9.x:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Rancher Version</th>
<th class="tableblock halign-left valign-top">Kubernetes Min</th>
<th class="tableblock halign-left valign-top">Kubernetes Max</th>
<th class="tableblock halign-left valign-top">Recomendada</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.9.3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.26.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.30.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.28.15</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.9.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.25.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.29.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.28.14</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.9.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.25.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.29.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.27.16</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.8.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.24.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.28.x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.27.x</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Seleccionar versión específica</strong></p>
</div>
<div class="listingblock">
<div class="title">Durante creación de clúster:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Rancher UI → Create Cluster
2. Kubernetes Version dropdown:
   - v1.28.15+rke2r1 (Recomendado)
   - v1.27.16+rke2r1 (Stable, LTS)
   - v1.29.10+rke2r1 (Latest)

Consideraciones:
- Usar versiones N-1 o N-2 para estabilidad
- Verificar compatibilidad con aplicaciones
- Revisar changelog de Kubernetes
- Testing en staging antes de producción</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Con Terraform:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">resource "rancher2_cluster_v2" "cluster" {
  name               = "production"
  kubernetes_version = "v1.28.15+rke2r1"
  # ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Actualización de versión de Kubernetes</strong></p>
</div>
<div class="listingblock">
<div class="title">Actualizar clúster existente:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster Management → Select cluster → ⋮ → Edit Config
2. Kubernetes Version → Seleccionar nueva versión
3. Upgrade Strategy:
   - Control Plane Concurrency: 1 (uno a la vez)
   - Worker Concurrency: 10% (10% de workers en paralelo)
   - Drain nodes: Yes
   - Max Unavailable Worker: 10%

4. Save → Upgrade will start automatically

Proceso automático:
1. Upgrade control plane nodes (uno por uno)
2. Upgrade etcd nodes (uno por uno)
3. Upgrade workers (en batches según concurrency)
4. Cada nodo es drenado antes de upgrade
5. Validación de health después de cada nodo</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Actualizar con kubectl:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver versión actual
kubectl version

# Rancher maneja el upgrade, pero puedes monitorearlo
kubectl get nodes -w

# Ver estado de upgrade en cada nodo
kubectl describe node &lt;node-name&gt; | grep -A 5 "System Info"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_de_networking_y_cni">Configuración de networking y CNI</h4>
<div class="paragraph">
<p>El CNI (Container Network Interface) es crítico para la comunicación entre pods.</p>
</div>
<div class="paragraph">
<p><strong>CNI disponibles en Rancher</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 33. Comparación de CNI:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">CNI</th>
<th class="tableblock halign-left valign-top">Características</th>
<th class="tableblock halign-left valign-top">Rendimiento</th>
<th class="tableblock halign-left valign-top">Uso recomendado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calico</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Network policies, IPAM, BGP routing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Muy bueno</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Producción, security-focused</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cilium</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">eBPF-based, observability, security</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Excelente</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Moderno, alta performance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Canal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calico + Flannel (policies + simple networking)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bueno</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Balance simplicidad/features</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Flannel</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simple overlay network, VXLAN</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bueno</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Desarrollo, simple setups</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multus</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multiple NICs, SR-IOV</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Variable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Telecom, NFV</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Weave</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simple mesh network, encryption</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aceptable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Legacy, simplicidad</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Configurar Cilium (recomendado)</strong></p>
</div>
<div class="listingblock">
<div class="title">Durante creación de clúster:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster Creation → Network Provider: Cilium

2. Chart Values (opcional, avanzado):
   Click "Edit as YAML"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Configuración personalizada de Cilium:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># En Cluster Creation → Chart Values → rke2-cilium

rke2-cilium:
  # IPAM
  ipam:
    mode: kubernetes  # o "cluster-pool" para IPAM de Cilium
    operator:
      clusterPoolIPv4PodCIDRList: ["10.42.0.0/16"]
      clusterPoolIPv4MaskSize: 24

  # Tunnel mode
  tunnel: vxlan  # o "disabled" para routing nativo

  # Hubble (observability)
  hubble:
    enabled: true
    relay:
      enabled: true
    ui:
      enabled: true
      service:
        type: LoadBalancer
    metrics:
      enabled:
        - dns
        - drop
        - tcp
        - flow
        - icmp
        - http

  # Security
  encryption:
    enabled: true
    type: wireguard  # o "ipsec"

  # Load Balancer (sin external LB)
  kubeProxyReplacement: true
  k8sServiceHost: &lt;control-plane-vip&gt;
  k8sServicePort: 6443

  # BGP (avanzado)
  bgpControlPlane:
    enabled: false

  # Monitoring
  prometheus:
    enabled: true
    serviceMonitor:
      enabled: true

  # Performance
  resources:
    limits:
      cpu: 4000m
      memory: 4Gi
    requests:
      cpu: 100m
      memory: 512Mi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Configurar Calico</strong></p>
</div>
<div class="listingblock">
<div class="title">Configuración de Calico:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># En Cluster Creation → Chart Values → rke2-calico

rke2-calico:
  # Configuración básica
  installation:
    calicoNetwork:
      ipPools:
      - blockSize: 26
        cidr: 10.42.0.0/16
        encapsulation: VXLAN  # o "IPIP" o "None" (routing directo)
        natOutgoing: Enabled
        nodeSelector: all()

  # Network Policy
  networkPolicy:
    enabled: true

  # Typha (para clústeres grandes &gt;50 nodos)
  typha:
    enabled: true
    replicas: 3

  # Felix (agent en cada nodo)
  felix:
    bpfEnabled: false  # true para eBPF (requiere kernel 5.3+)
    chainInsertMode: Insert
    logSeverityScreen: Info
    prometheusMetricsEnabled: true

  # BGP configuration
  bgp:
    enabled: false  # true si usas BGP peering
    # bgpPeers:
    # - peerIP: 192.168.1.1
    #   asNumber: 64512</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Verificar networking después de creación</strong></p>
</div>
<div class="listingblock">
<div class="title">Comandos de verificación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># 1. Ver CNI instalado
kubectl get pods -n kube-system | grep -E 'calico|cilium|flannel'

# 2. Ver configuración de red
kubectl get nodes -o wide

# 3. Test de conectividad entre pods
kubectl run test-1 --image=busybox --rm -it -- sh
# Dentro del pod:
wget -O- http://kubernetes.default.svc.cluster.local

# 4. Test de DNS
kubectl run test-dns --image=busybox --rm -it -- nslookup kubernetes.default

# 5. Ver IP pools (Calico)
kubectl get ippools -o yaml

# 6. Ver CiliumNodes (Cilium)
kubectl get ciliumnodes

# 7. Test de network policy
# Crear test namespace
kubectl create ns test-netpol
kubectl run web --image=nginx -n test-netpol
kubectl expose pod web --port=80 -n test-netpol

# Crear cliente
kubectl run client --image=busybox -n test-netpol --rm -it -- sh
# Dentro: wget -O- http://web  (debería funcionar)

# Aplicar network policy (deny all)
kubectl apply -f - &lt;&lt;EOF
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all
  namespace: test-netpol
spec:
  podSelector: {}
  policyTypes:
  - Ingress
EOF

# Reintentar conexión (debería fallar)
kubectl run client --image=busybox -n test-netpol --rm -it -- wget -O- http://web --timeout=5</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Configuración avanzada: Multiple CNI con Multus</strong></p>
</div>
<div class="paragraph">
<p>Para casos de uso avanzados (telco, NFV, múltiples interfaces).</p>
</div>
<div class="listingblock">
<div class="title">Instalar Multus:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Multus como CNI adicional (después de crear clúster con CNI primario)
apiVersion: v1
kind: ConfigMap
metadata:
  name: multus-cni-config
  namespace: kube-system
data:
  cni-conf.json: |
    {
      "name": "multus-cni-network",
      "type": "multus",
      "delegates": [
        {
          "cniVersion": "0.3.1",
          "name": "default-cni",
          "type": "cilium"
        }
      ],
      "kubeconfig": "/etc/cni/net.d/multus.d/multus.kubeconfig"
    }
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: kube-multus-ds
  namespace: kube-system
spec:
  selector:
    matchLabels:
      name: multus
  template:
    metadata:
      labels:
        name: multus
    spec:
      hostNetwork: true
      tolerations:
      - operator: Exists
        effect: NoSchedule
      containers:
      - name: kube-multus
        image: ghcr.io/k8snetworkplumbingwg/multus-cni:stable
        command: ["/entrypoint.sh"]
        args: ["--multus-conf-file=auto"]
        resources:
          requests:
            cpu: 100m
            memory: 50Mi
          limits:
            cpu: 200m
            memory: 100Mi
        securityContext:
          privileged: true
        volumeMounts:
        - name: cni
          mountPath: /host/etc/cni/net.d
        - name: cnibin
          mountPath: /host/opt/cni/bin
      volumes:
      - name: cni
        hostPath:
          path: /etc/cni/net.d
      - name: cnibin
        hostPath:
          path: /opt/cni/bin</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Troubleshooting networking</strong></p>
</div>
<div class="listingblock">
<div class="title">Diagnóstico de problemas comunes:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
echo "=== Diagnóstico de Networking Kubernetes ==="

# 1. Estado de pods CNI
echo "1. Estado de CNI pods:"
kubectl get pods -n kube-system -l k8s-app=cilium -o wide
kubectl get pods -n kube-system -l k8s-app=calico-node -o wide

# 2. Ver logs de CNI
echo "2. Logs de CNI:"
kubectl logs -n kube-system -l k8s-app=cilium --tail=50

# 3. Verificar IP forwarding en nodos
echo "3. IP forwarding:"
kubectl get nodes -o name | while read node; do
  echo "$node:"
  kubectl debug $node -it --image=busybox -- sysctl net.ipv4.ip_forward
done

# 4. Verificar firewall rules
echo "4. Firewall rules:"
kubectl get nodes -o name | while read node; do
  echo "$node:"
  kubectl debug $node -it --image=nicolaka/netshoot -- iptables -L -n | grep -i forward
done

# 5. Test de conectividad cluster
echo "5. Test de conectividad:"
kubectl run nettest --image=nicolaka/netshoot --rm -it -- bash -c "
  ping -c 3 8.8.8.8
  nslookup kubernetes.default
  curl -I https://kubernetes.default.svc.cluster.local:443 -k
"

# 6. Ver rutas en nodos
echo "6. Rutas:"
kubectl get nodes -o name | head -1 | while read node; do
  kubectl debug $node -it --image=nicolaka/netshoot -- ip route
done

echo "=== Fin diagnóstico ==="</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_backup_y_restauración_de_clústeres">Backup y restauración de clústeres</h4>
<div class="paragraph">
<p>El backup regular de clústeres es crítico para disaster recovery y debe cubrir tanto datos del cluster (etcd) como datos de aplicaciones.</p>
</div>
<div class="paragraph">
<p><strong>Componentes a respaldar en un clúster</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 34. Elementos críticos:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Componente</th>
<th class="tableblock halign-left valign-top">Contenido</th>
<th class="tableblock halign-left valign-top">Método</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">etcd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Estado del clúster Kubernetes (pods, services, configs)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Snapshots automáticos/manuales</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Persistent Volumes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Datos de aplicaciones</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Volume snapshots, Velero</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ConfigMaps/Secrets</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuraciones y credenciales</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Velero, kubectl export</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CRDs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Custom Resource Definitions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Velero, kubectl export</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Namespaces</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Objetos de aplicaciones</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Velero</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RBAC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Roles, RoleBindings, ServiceAccounts</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Velero, kubectl export</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Método 1: Backup de etcd (incluido en RKE/RKE2)</strong></p>
</div>
<div class="paragraph">
<p>RKE2 y RKE1 incluyen backup automático de etcd.</p>
</div>
<div class="listingblock">
<div class="title">Configurar backup automático de etcd (RKE2):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Al crear clúster en Rancher, en Advanced Options → etcd

# O editar clúster existente:
# Cluster → Edit Config → Advanced → etcd
apiVersion: provisioning.cattle.io/v1
kind: Cluster
metadata:
  name: production-cluster
spec:
  rkeConfig:
    etcd:
      # Backup local en cada nodo etcd
      snapshotScheduleCron: "0 */6 * * *"  # Cada 6 horas
      snapshotRetention: 14  # Mantener 14 snapshots

      # Backup a S3 (recomendado)
      s3:
        bucket: rancher-cluster-backups
        cloudCredentialName: aws-creds  # Cloud credential en Rancher
        endpoint: s3.amazonaws.com
        region: us-east-1
        folder: production-cluster
        skipSSLVerify: false</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Verificar backups de etcd:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Listar snapshots locales (en nodos etcd)
# SSH al nodo etcd
ls -lh /var/lib/rancher/rke2/server/db/snapshots/

# Listar snapshots en S3
aws s3 ls s3://rancher-cluster-backups/production-cluster/ --recursive

# Ver configuración de backup del clúster
kubectl get cluster.provisioning.cattle.io production-cluster -o yaml | grep -A 10 etcd

# Forzar snapshot manual (via Rancher UI)
# Cluster → ⋮ → Take Snapshot

# O via API
curl -k -X POST "${RANCHER_URL}/v1/provisioning.cattle.io.clusters/${CLUSTER_ID}?action=backupEtcd" \
  -H "Authorization: Bearer ${API_TOKEN}"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 2: Backup completo con Velero</strong></p>
</div>
<div class="paragraph">
<p>Velero es el estándar de facto para backup de clústeres Kubernetes.</p>
</div>
<div class="listingblock">
<div class="title">Instalar Velero en el clúster:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># 1. Instalar Velero CLI
wget https://github.com/vmware-tanzu/velero/releases/download/v1.14.0/velero-v1.14.0-linux-amd64.tar.gz
tar -xvf velero-v1.14.0-linux-amd64.tar.gz
sudo mv velero-v1.14.0-linux-amd64/velero /usr/local/bin/
velero version

# 2. Configurar credenciales S3
cat &gt; credentials-velero &lt;&lt;EOF
[default]
aws_access_key_id = &lt;AWS_ACCESS_KEY_ID&gt;
aws_secret_access_key = &lt;AWS_SECRET_ACCESS_KEY&gt;
EOF

# 3. Instalar Velero en el clúster
velero install \
  --provider aws \
  --plugins velero/velero-plugin-for-aws:v1.10.0 \
  --bucket rancher-velero-backups \
  --secret-file ./credentials-velero \
  --backup-location-config region=us-east-1 \
  --snapshot-location-config region=us-east-1 \
  --use-volume-snapshots=true \
  --use-node-agent \
  --uploader-type=restic

# 4. Verificar instalación
kubectl get pods -n velero
velero version</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Configurar backups automáticos con Velero:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Backup schedule diario de todo el clúster
apiVersion: velero.io/v1
kind: Schedule
metadata:
  name: daily-cluster-backup
  namespace: velero
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  template:
    includedNamespaces:
    - '*'
    excludedNamespaces:
    - kube-system
    - kube-public
    - velero
    includedResources:
    - '*'
    includeClusterResources: true
    storageLocation: default
    volumeSnapshotLocations:
    - default
    ttl: 720h0m0s  # Mantener 30 días
    snapshotVolumes: true
    defaultVolumesToFsBackup: false</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Backup manual con Velero:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Backup completo del clúster
velero backup create full-backup-$(date +%Y%m%d) \
  --include-namespaces '*' \
  --include-cluster-resources=true

# Backup de namespace específico
velero backup create app-backup \
  --include-namespaces production \
  --include-cluster-resources=false

# Backup con volúmenes (usando restic)
velero backup create app-with-data \
  --include-namespaces production \
  --default-volumes-to-fs-backup

# Ver estado del backup
velero backup describe full-backup-20251030

# Ver logs del backup
velero backup logs full-backup-20251030

# Listar todos los backups
velero backup get</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Restauración desde backup de etcd</strong></p>
</div>
<div class="listingblock">
<div class="title">Restaurar clúster desde snapshot de etcd:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># IMPORTANTE: Esto recrea completamente el clúster
# Todos los nodos deben estar disponibles

# Método 1: Via Rancher UI
# 1. Cluster → ⋮ → Restore Snapshot
# 2. Seleccionar snapshot
# 3. Confirm

# Método 2: Via API
curl -k -X POST "${RANCHER_URL}/v1/provisioning.cattle.io.clusters/${CLUSTER_ID}?action=restoreSnapshot" \
  -H "Authorization: Bearer ${API_TOKEN}" \
  -H 'Content-Type: application/json' \
  -d '{
    "snapshotName": "on-demand-production-cluster-20251030-120000"
  }'

# Método 3: Restauración manual en RKE2 (disaster recovery completo)
# En el primer nodo etcd:
systemctl stop rke2-server

# Restaurar snapshot
rke2 server \
  --cluster-reset \
  --cluster-reset-restore-path=/var/lib/rancher/rke2/server/db/snapshots/etcd-snapshot-production-20251030-120000 \
  --token &lt;existing-cluster-token&gt;

# Esperar a que complete
# Iniciar RKE2
systemctl start rke2-server

# Verificar
export KUBECONFIG=/etc/rancher/rke2/rke2.yaml
kubectl get nodes

# En los nodos adicionales (si es clúster multi-master):
# Eliminar datos viejos y rejoin
systemctl stop rke2-server
rm -rf /var/lib/rancher/rke2/server/db
systemctl start rke2-server</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Restauración con Velero</strong></p>
</div>
<div class="listingblock">
<div class="title">Restaurar desde backup de Velero:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Listar backups disponibles
velero backup get

# Restauración completa
velero restore create --from-backup full-backup-20251030

# Restaurar solo un namespace
velero restore create --from-backup full-backup-20251030 \
  --include-namespaces production

# Restaurar con mapeo de namespace (restaurar a diferente namespace)
velero restore create --from-backup full-backup-20251030 \
  --namespace-mappings production:production-restored

# Restaurar solo recursos específicos
velero restore create --from-backup full-backup-20251030 \
  --include-resources deployments,services,configmaps

# Ver estado de restauración
velero restore describe &lt;restore-name&gt;

# Ver logs de restauración
velero restore logs &lt;restore-name&gt;

# Listar todas las restauraciones
velero restore get</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Backup de aplicaciones específicas</strong></p>
</div>
<div class="listingblock">
<div class="title">Ejemplo: Backup de base de datos PostgreSQL:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Backup con pre/post hooks para consistency
apiVersion: velero.io/v1
kind: Backup
metadata:
  name: postgres-backup
  namespace: velero
spec:
  includedNamespaces:
  - database
  includedResources:
  - '*'
  hooks:
    resources:
    - name: postgres-backup-hook
      includedNamespaces:
      - database
      labelSelector:
        matchLabels:
          app: postgresql
      pre:
      - exec:
          container: postgresql
          command:
          - /bin/bash
          - -c
          - 'PGPASSWORD=$POSTGRES_PASSWORD pg_dump -U postgres -h localhost mydb &gt; /tmp/backup.sql'
          timeout: 3m
      post:
      - exec:
          container: postgresql
          command:
          - /bin/bash
          - -c
          - 'rm -f /tmp/backup.sql'
  volumeSnapshotLocations:
  - default
  storageLocation: default
  ttl: 720h0m0s</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Disaster Recovery completo</strong></p>
</div>
<div class="listingblock">
<div class="title">Procedimiento DR completo de clúster:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
# Script de Disaster Recovery completo

set -e

echo "=== Disaster Recovery de Clúster Kubernetes ==="

# Variables
CLUSTER_NAME="production-cluster"
BACKUP_DATE="20251030"
S3_BUCKET="rancher-cluster-backups"

# 1. Crear nuevo clúster en Rancher (o usar existente)
echo "1. Asegurarse de tener clúster destino creado en Rancher"

# 2. Restaurar etcd snapshot (si aplicable)
echo "2. Restaurando snapshot de etcd..."
# Via Rancher UI o API (ver sección anterior)

# 3. Instalar Velero en clúster destino
echo "3. Instalando Velero..."
velero install \
  --provider aws \
  --plugins velero/velero-plugin-for-aws:v1.10.0 \
  --bucket ${S3_BUCKET} \
  --secret-file ./credentials-velero \
  --backup-location-config region=us-east-1

# 4. Esperar a que Velero esté listo
kubectl wait --for=condition=Available --timeout=300s -n velero deployment/velero

# 5. Listar backups disponibles
echo "5. Backups disponibles:"
velero backup get

# 6. Restaurar desde backup más reciente
echo "6. Restaurando desde backup..."
BACKUP_NAME=$(velero backup get -o json | jq -r '.items | sort_by(.status.completionTimestamp) | last | .metadata.name')
velero restore create dr-restore-$(date +%s) --from-backup ${BACKUP_NAME} --wait

# 7. Verificar restauración
echo "7. Verificando recursos restaurados..."
kubectl get all -A

# 8. Verificar PVCs
echo "8. Verificando Persistent Volume Claims..."
kubectl get pvc -A

# 9. Verificar aplicaciones críticas
echo "9. Verificando aplicaciones..."
kubectl get pods -A | grep -v "Running\|Completed"

# 10. Verificar services y endpoints
echo "10. Verificando servicios..."
kubectl get svc,ep -A

# 11. Test de conectividad
echo "11. Testing conectividad..."
kubectl run test-dr --image=busybox --rm -it -- wget -O- http://myapp.production.svc.cluster.local

echo "=== DR completado ==="
echo "Verificar manualmente:"
echo "- Aplicaciones accesibles"
echo "- Datos de bases de datos"
echo "- Certificados y secrets"
echo "- Configuración de DNS"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Best practices para backup</strong></p>
</div>
<div class="listingblock">
<div class="title">Recomendaciones:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Estrategia 3-2-1:
   - 3 copias de los datos
   - 2 medios de almacenamiento diferentes
   - 1 copia offsite (S3 en otra región)

2. Frecuencia de backups:
   - etcd: Cada 6-12 horas
   - Aplicaciones críticas: Cada hora
   - Aplicaciones normales: Diario
   - Backup manual antes de cambios grandes

3. Retención:
   - Diarios: 7 días
   - Semanales: 4 semanas
   - Mensuales: 12 meses
   - Antes de upgrades: Permanente (marcar)

4. Testing:
   - Test de restauración mensual en clúster de prueba
   - Documentar RTO (Recovery Time Objective): &lt; 1 hora
   - Documentar RPO (Recovery Point Objective): &lt; 6 horas
   - Automatizar proceso DR

5. Seguridad:
   - Cifrar backups en reposo (S3 encryption)
   - Cifrar backups en tránsito (TLS)
   - Rotar credenciales de backup
   - Restricir acceso a backups (IAM policies)
   - Audit logging de acceso a backups

6. Monitoreo:
   - Alertar si backup falla
   - Verificar integridad de backups
   - Monitorear tamaño de backups
   - Dashboard con última fecha de backup exitoso</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Verificación de backups</strong></p>
</div>
<div class="listingblock">
<div class="title">Script de verificación de backups:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
echo "=== Verificación de Backups ==="

# 1. Verificar último snapshot de etcd
echo "1. Último snapshot etcd:"
aws s3 ls s3://rancher-cluster-backups/production-cluster/ --recursive | \
  sort | tail -1

# 2. Verificar backups de Velero
echo "2. Últimos backups de Velero:"
velero backup get | tail -5

# 3. Verificar estado del último backup
LAST_BACKUP=$(velero backup get -o json | jq -r '.items | sort_by(.status.completionTimestamp) | last | .metadata.name')
echo "3. Estado del último backup: $LAST_BACKUP"
velero backup describe $LAST_BACKUP | grep -E "Phase|Warnings|Errors"

# 4. Verificar tamaño de backups
echo "4. Tamaño de backups en S3:"
aws s3 ls s3://rancher-velero-backups/ --recursive --human-readable --summarize

# 5. Verificar schedule de backups
echo "5. Schedules configurados:"
velero schedule get

# 6. Verificar última ejecución de schedule
echo "6. Última ejecución de schedules:"
velero schedule describe daily-cluster-backup | grep "Last Backup"

# 7. Test de integridad (restaurar en clúster temporal)
echo "7. Para test completo, ejecutar:"
echo "   - Crear clúster temporal"
echo "   - velero restore create test-restore --from-backup $LAST_BACKUP"
echo "   - Verificar recursos"
echo "   - Eliminar clúster temporal"

echo "=== Fin verificación ==="</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_monitoreo_del_estado_de_salud">Monitoreo del estado de salud</h4>
<div class="paragraph">
<p>El monitoreo continuo del clúster es esencial para detectar problemas antes de que afecten a producción.</p>
</div>
<div class="paragraph">
<p><strong>Componentes a monitorear</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 35. Métricas críticas:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 50%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Categoría</th>
<th class="tableblock halign-left valign-top">Métricas</th>
<th class="tableblock halign-left valign-top">Umbral crítico</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nodos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPU, memoria, disco, red</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPU &gt; 80%, Memoria &gt; 85%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Control Plane</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">API server latency, etcd latency</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Latency &gt; 100ms</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">etcd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DB size, leader changes, proposals</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Size &gt; 8GB, Changes &gt; 3/hour</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pods</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Restarts, OOMKilled, CrashLoopBackOff</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Restarts &gt; 5/hour</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Red</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Packet loss, latency entre nodos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loss &gt; 1%, Latency &gt; 10ms</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Almacenamiento</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PV usage, I/O wait</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usage &gt; 85%, I/O wait &gt; 20%</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Método 1: Rancher Monitoring (Prometheus + Grafana)</strong></p>
</div>
<div class="paragraph">
<p>Solución integrada y recomendada.</p>
</div>
<div class="listingblock">
<div class="title">Instalar Rancher Monitoring:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text"># Via Rancher UI:
1. Cluster → Apps → Charts
2. Buscar "Rancher Monitoring"
3. Install

Configuración:
- Prometheus Storage: 50Gi (PVC)
- Retention: 15d
- Grafana Enabled: Yes
- Grafana Storage: 10Gi (PVC)
- AlertManager Enabled: Yes

Resources:
- Prometheus:
  - CPU: 1000m
  - Memory: 3000Mi
- Grafana:
  - CPU: 200m
  - Memory: 200Mi

4. Install</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Configuración avanzada de Monitoring:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Cluster → Apps → Installed Apps → rancher-monitoring → Edit YAML

prometheus:
  prometheusSpec:
    # Recursos
    resources:
      requests:
        cpu: 1000m
        memory: 3000Mi
      limits:
        cpu: 2000m
        memory: 6000Mi

    # Storage
    storageSpec:
      volumeClaimTemplate:
        spec:
          storageClassName: fast-ssd
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 100Gi

    # Retención
    retention: 30d
    retentionSize: 90GB

    # Scrape interval
    scrapeInterval: 30s
    evaluationInterval: 30s

    # External labels para federación
    externalLabels:
      cluster: production
      region: us-east-1
      environment: prod

    # Remote write (para long-term storage)
    remoteWrite:
    - url: https://prometheus-remote.example.com/api/v1/write
      basicAuth:
        username:
          name: remote-write-secret
          key: username
        password:
          name: remote-write-secret
          key: password

grafana:
  enabled: true
  adminPassword: SecurePassword123!

  persistence:
    enabled: true
    storageClassName: fast-ssd
    size: 10Gi

  # Ingress para acceso externo
  ingress:
    enabled: true
    hosts:
    - grafana.example.com
    tls:
    - secretName: grafana-tls
      hosts:
      - grafana.example.com

alertmanager:
  enabled: true

  alertmanagerSpec:
    storage:
      volumeClaimTemplate:
        spec:
          storageClassName: fast-ssd
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 10Gi

  # Configuración de alertas
  config:
    global:
      resolve_timeout: 5m
      slack_api_url: 'https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXX'

    route:
      group_by: ['alertname', 'cluster', 'service']
      group_wait: 10s
      group_interval: 10s
      repeat_interval: 12h
      receiver: 'default'
      routes:
      - match:
          severity: critical
        receiver: critical
        continue: true
      - match:
          severity: warning
        receiver: warning

    receivers:
    - name: 'default'
      slack_configs:
      - channel: '#alerts'
        title: 'Alert: {{ .GroupLabels.alertname }}'
        text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'

    - name: 'critical'
      slack_configs:
      - channel: '#critical-alerts'
        title: '🚨 CRITICAL: {{ .GroupLabels.alertname }}'
        text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'
      pagerduty_configs:
      - service_key: &lt;pagerduty-integration-key&gt;

    - name: 'warning'
      slack_configs:
      - channel: '#warning-alerts'
        title: '⚠️  Warning: {{ .GroupLabels.alertname }}'
        text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Acceder a Grafana</strong></p>
</div>
<div class="listingblock">
<div class="title">Acceso a dashboards:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Obtener contraseña de Grafana admin
kubectl get secret -n cattle-monitoring-system rancher-monitoring-grafana \
  -o jsonpath='{.data.admin-password}' | base64 -d

# Port-forward si no hay ingress
kubectl port-forward -n cattle-monitoring-system \
  svc/rancher-monitoring-grafana 3000:80

# Abrir navegador
open http://localhost:3000
# Usuario: admin
# Contraseña: &lt;obtenida arriba&gt;

# Dashboards incluidos:
# - Kubernetes / Compute Resources / Cluster
# - Kubernetes / Compute Resources / Namespace (Pods)
# - Kubernetes / Compute Resources / Node (Pods)
# - Kubernetes / Networking / Cluster
# - etcd
# - Kubernetes / API server
# - Kubernetes / Kubelet</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Crear alertas personalizadas</strong></p>
</div>
<div class="listingblock">
<div class="title">PrometheusRule para alertas custom:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: custom-cluster-alerts
  namespace: cattle-monitoring-system
  labels:
    release: rancher-monitoring
spec:
  groups:
  - name: cluster-health
    interval: 30s
    rules:

    # Alerta: CPU alto en nodos
    - alert: NodeHighCPU
      expr: |
        (1 - avg by (instance) (rate(node_cpu_seconds_total{mode="idle"}[5m]))) * 100 &gt; 80
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "Node {{ $labels.instance }} has high CPU usage"
        description: "CPU usage is {{ $value }}% on {{ $labels.instance }}"

    # Alerta: Memoria alta en nodos
    - alert: NodeHighMemory
      expr: |
        (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 &gt; 85
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "Node {{ $labels.instance }} has high memory usage"
        description: "Memory usage is {{ $value }}% on {{ $labels.instance }}"

    # Alerta: Disco casi lleno
    - alert: NodeDiskAlmostFull
      expr: |
        (1 - (node_filesystem_avail_bytes{mountpoint="/"} / node_filesystem_size_bytes{mountpoint="/"})) * 100 &gt; 85
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "Disk almost full on {{ $labels.instance }}"
        description: "Disk usage is {{ $value }}% on {{ $labels.instance }}"

    # Alerta: Nodo no disponible
    - alert: NodeNotReady
      expr: |
        kube_node_status_condition{condition="Ready",status="true"} == 0
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "Node {{ $labels.node }} is not ready"
        description: "Node {{ $labels.node }} has been unready for more than 5 minutes"

    # Alerta: Pod en CrashLoopBackOff
    - alert: PodCrashLooping
      expr: |
        rate(kube_pod_container_status_restarts_total[15m]) &gt; 0
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "Pod {{ $labels.namespace }}/{{ $labels.pod }} is crash looping"
        description: "Pod has restarted {{ $value }} times in the last 15 minutes"

    # Alerta: etcd DB size grande
    - alert: EtcdDatabaseSizeLarge
      expr: |
        etcd_mvcc_db_total_size_in_bytes / 1024 / 1024 / 1024 &gt; 8
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "etcd database size is large"
        description: "etcd DB size is {{ $value }}GB"

    # Alerta: API server latency alto
    - alert: APIServerHighLatency
      expr: |
        histogram_quantile(0.99, sum(rate(apiserver_request_duration_seconds_bucket{verb!="WATCH"}[5m])) by (verb, le)) &gt; 1
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "API server has high latency"
        description: "API server 99th percentile latency is {{ $value }}s"

    # Alerta: PVC casi lleno
    - alert: PVCAlmostFull
      expr: |
        (kubelet_volume_stats_used_bytes / kubelet_volume_stats_capacity_bytes) * 100 &gt; 85
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "PVC {{ $labels.namespace }}/{{ $labels.persistentvolumeclaim }} is almost full"
        description: "PVC usage is {{ $value }}%"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 2: Monitoreo básico con kubectl</strong></p>
</div>
<div class="paragraph">
<p>Para clústeres sin Prometheus.</p>
</div>
<div class="listingblock">
<div class="title">Script de monitoreo básico:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
# Script de health check básico

echo "=== Cluster Health Check ==="
echo "Timestamp: $(date)"
echo ""

# 1. Estado de nodos
echo "1. Node Status:"
kubectl get nodes -o custom-columns=NAME:.metadata.name,STATUS:.status.conditions[-1].type,CPU:.status.capacity.cpu,MEMORY:.status.capacity.memory,VERSION:.status.nodeInfo.kubeletVersion
echo ""

# 2. Pods no saludables
echo "2. Unhealthy Pods:"
kubectl get pods -A --field-selector status.phase!=Running,status.phase!=Succeeded | tail -n +2
echo ""

# 3. Resource usage de nodos
echo "3. Node Resource Usage:"
kubectl top nodes
echo ""

# 4. Pods con más uso de recursos
echo "4. Top 10 Pods by CPU:"
kubectl top pods -A --sort-by=cpu | head -11
echo ""

echo "5. Top 10 Pods by Memory:"
kubectl top pods -A --sort-by=memory | head -11
echo ""

# 6. PVC usage
echo "6. PVC Status:"
kubectl get pvc -A -o custom-columns=NAMESPACE:.metadata.namespace,NAME:.metadata.name,STATUS:.status.phase,CAPACITY:.spec.resources.requests.storage,STORAGECLASS:.spec.storageClassName
echo ""

# 7. Events recientes (errores/warnings)
echo "7. Recent Warning/Error Events:"
kubectl get events -A --field-selector type!=Normal --sort-by='.lastTimestamp' | tail -20
echo ""

# 8. Control plane components
echo "8. Control Plane Components:"
kubectl get componentstatuses 2&gt;/dev/null || kubectl get pods -n kube-system -l tier=control-plane
echo ""

# 9. Critical pods
echo "9. Critical System Pods:"
kubectl get pods -n kube-system -o custom-columns=NAME:.metadata.name,STATUS:.status.phase,RESTARTS:.status.containerStatuses[0].restartCount,AGE:.metadata.creationTimestamp
echo ""

# 10. Cluster-wide resource requests
echo "10. Cluster-wide Resource Requests:"
kubectl describe nodes | grep -A 5 "Allocated resources"

echo ""
echo "=== Health Check Complete ==="</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Método 3: Rancher Cluster Explorer</strong></p>
</div>
<div class="paragraph">
<p>Interface visual integrada en Rancher.</p>
</div>
<div class="listingblock">
<div class="title">Usar Cluster Explorer:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Rancher UI → Cluster Management → Select cluster → Explore

2. Overview:
   - Cluster status
   - Node count y health
   - Resource usage (CPU, Memory)
   - Pod count por namespace
   - Events recientes

3. Nodes:
   - Lista de nodos con estado
   - CPU/Memory usage por nodo
   - Conditions (Ready, DiskPressure, MemoryPressure)
   - Taints y labels

4. Monitoring (si está instalado):
   - Gráficas de CPU, Memory, Network, Disk
   - Dashboards predefinidos
   - Métricas en tiempo real

5. Events:
   - Eventos del clúster en tiempo real
   - Filtrar por tipo (Warning, Error, Normal)
   - Ver logs de eventos

6. Workloads:
   - Estado de Deployments, StatefulSets, DaemonSets
   - Pod status y health
   - Resource usage por workload</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exportar métricas para sistemas externos</strong></p>
</div>
<div class="listingblock">
<div class="title">Integración con Datadog:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Instalar Datadog agent
apiVersion: v1
kind: Secret
metadata:
  name: datadog-secret
  namespace: datadog
type: Opaque
data:
  api-key: &lt;BASE64_ENCODED_DATADOG_API_KEY&gt;
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: datadog-agent
  namespace: datadog
spec:
  selector:
    matchLabels:
      app: datadog-agent
  template:
    metadata:
      labels:
        app: datadog-agent
    spec:
      serviceAccountName: datadog-agent
      containers:
      - name: agent
        image: gcr.io/datadoghq/agent:latest
        env:
        - name: DD_API_KEY
          valueFrom:
            secretKeyRef:
              name: datadog-secret
              key: api-key
        - name: DD_SITE
          value: "datadoghq.com"
        - name: DD_KUBERNETES_KUBELET_NODENAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: DD_COLLECT_KUBERNETES_EVENTS
          value: "true"
        - name: DD_APM_ENABLED
          value: "true"
        - name: DD_LOGS_ENABLED
          value: "true"
        - name: DD_PROCESS_AGENT_ENABLED
          value: "true"
        volumeMounts:
        - name: dockersocket
          mountPath: /var/run/docker.sock
          readOnly: true
        - name: procdir
          mountPath: /host/proc
          readOnly: true
        - name: cgroups
          mountPath: /host/sys/fs/cgroup
          readOnly: true
      volumes:
      - name: dockersocket
        hostPath:
          path: /var/run/docker.sock
      - name: procdir
        hostPath:
          path: /proc
      - name: cgroups
        hostPath:
          path: /sys/fs/cgroup</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Dashboard de salud general</strong></p>
</div>
<div class="listingblock">
<div class="title">Crear dashboard custom en Grafana:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{
  "dashboard": {
    "title": "Cluster Health Overview",
    "panels": [
      {
        "title": "Cluster Status",
        "type": "stat",
        "targets": [
          {
            "expr": "count(kube_node_status_condition{condition=\"Ready\",status=\"true\"})"
          }
        ]
      },
      {
        "title": "CPU Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "100 - (avg by (instance) (rate(node_cpu_seconds_total{mode=\"idle\"}[5m])) * 100)"
          }
        ]
      },
      {
        "title": "Memory Usage",
        "type": "graph",
        "targets": [
          {
            "expr": "(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100"
          }
        ]
      },
      {
        "title": "Pod Restarts (Last Hour)",
        "type": "stat",
        "targets": [
          {
            "expr": "sum(increase(kube_pod_container_status_restarts_total[1h]))"
          }
        ]
      },
      {
        "title": "API Server Requests",
        "type": "graph",
        "targets": [
          {
            "expr": "sum(rate(apiserver_request_total[5m])) by (verb)"
          }
        ]
      },
      {
        "title": "etcd Size",
        "type": "gauge",
        "targets": [
          {
            "expr": "etcd_mvcc_db_total_size_in_bytes / 1024 / 1024 / 1024"
          }
        ]
      }
    ]
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Mejores prácticas de monitoreo</strong></p>
</div>
<div class="listingblock">
<div class="title">Recomendaciones:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Definir SLIs (Service Level Indicators):
   - Latencia API: p99 &lt; 100ms
   - Disponibilidad: 99.9% uptime
   - Tasa de error: &lt; 0.1%

2. Configurar alertas inteligentes:
   - Evitar alert fatigue (no alertar por todo)
   - Usar umbrales basados en baseline
   - Agrupar alertas relacionadas
   - Definir severity levels (critical/warning/info)

3. Retención de métricas:
   - Alta resolución: 15 días
   - Resolución media: 90 días
   - Resolución baja: 1 año
   - Agregar datos viejos (downsampling)

4. Dashboards por rol:
   - Executive: Uptime, SLA, costs
   - Operations: Node health, resource usage
   - Developers: Application metrics, logs
   - Security: Audit logs, anomalies

5. Automatización:
   - Auto-scaling basado en métricas
   - Auto-remediation para problemas conocidos
   - Integración con ChatOps (Slack/Teams)
   - Runbooks automáticos</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_4_seguridad_y_gobernanza">Módulo 4: Seguridad y Gobernanza</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_4_1_gestión_de_usuarios_y_roles">4.1 Gestión de usuarios y roles</h3>
<div class="paragraph">
<p>Rancher proporciona un sistema completo de gestión de identidad y acceso (IAM) que integra autenticación externa con autorización granular basada en RBAC de Kubernetes.</p>
</div>
<div class="sect3">
<h4 id="_sistema_de_autenticación_y_autorización">Sistema de autenticación y autorización</h4>
<div class="paragraph">
<p><strong>Arquitectura de autenticación en Rancher</strong></p>
</div>
<div class="listingblock">
<div class="title">Flujo de autenticación y autorización:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-plantuml hljs" data-lang="plantuml">@startuml
!define RECTANGLE rectangle

skinparam backgroundColor transparent

actor Usuario
participant "Rancher UI/API" as Rancher
participant "Auth Provider\n(LDAP/SAML/OIDC)" as Auth
participant "Rancher RBAC" as RBAC
participant "Kubernetes API" as K8s

Usuario -&gt; Rancher: Login request
Rancher -&gt; Auth: Authenticate user
Auth -&gt; Auth: Verify credentials
Auth --&gt; Rancher: User identity + groups
Rancher -&gt; RBAC: Check user permissions
RBAC -&gt; RBAC: Evaluate roles\n(Global/Cluster/Project)
RBAC --&gt; Rancher: Permissions granted
Rancher -&gt; K8s: Proxy request with\nRancher service account
K8s --&gt; Rancher: Response
Rancher --&gt; Usuario: Access granted

note right of RBAC
  Multi-level authorization:
  1. Global (Rancher level)
  2. Cluster (K8s cluster level)
  3. Project (Namespace group level)
end note

@enduml</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Niveles de autenticación</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 36. Métodos de autenticación soportados:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Método</th>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Enterprise</th>
<th class="tableblock halign-left valign-top">MFA Support</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Username/Password</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Active Directory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Via AD</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FreeIPA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Via FreeIPA</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Azure AD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SAML/OIDC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Keycloak</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OIDC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Okta</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SAML</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GitHub</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OAuth</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Via GitHub</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Google OAuth</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OAuth</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Via Google</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SAML Generic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SAML 2.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Depends on IdP</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenLDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Configurar autenticación (revisión)</strong></p>
</div>
<div class="paragraph">
<p>Ya cubierto en módulo 2.3, pero recordatorio de configuración:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Via Rancher API
curl -k -X POST "${RANCHER_URL}/v3/activeDirectoryConfig" \
  -H "Authorization: Bearer ${API_TOKEN}" \
  -H 'Content-Type: application/json' \
  -d '{
    "enabled": true,
    "servers": ["ad.example.com"],
    "port": 636,
    "tls": true,
    "serviceAccountDistinguishedName": "CN=rancher,OU=Service Accounts,DC=example,DC=com",
    "serviceAccountPassword": "password",
    "userSearchBase": "OU=Users,DC=example,DC=com",
    "groupSearchBase": "OU=Groups,DC=example,DC=com"
  }'</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Autorización multi-nivel</strong></p>
</div>
<div class="paragraph">
<p>Rancher implementa autorización en tres niveles jerárquicos:</p>
</div>
<div class="listingblock">
<div class="title">Jerarquía de autorización:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-plantuml hljs" data-lang="plantuml">@startuml
!define RECTANGLE rectangle

skinparam backgroundColor transparent

RECTANGLE "Global Scope" as global {
  note
    - Acceso a Rancher completo
    - Gestión de usuarios
    - Gestión de auth providers
    - Gestión de clusters
  end note
}

RECTANGLE "Cluster Scope" as cluster {
  note
    - Acceso a un cluster específico
    - Gestión de nodos
    - Gestión de namespaces
    - Gestión de proyectos
    - Gestión de apps
  end note
}

RECTANGLE "Project Scope" as project {
  note
    - Acceso a grupo de namespaces
    - Gestión de workloads
    - Gestión de servicios
    - Gestión de secrets
  end note
}

RECTANGLE "Namespace Scope" as ns {
  note
    - RBAC nativo de Kubernetes
    - Roles y RoleBindings
  end note
}

global -down-&gt; cluster : contiene
cluster -down-&gt; project : contiene
project -down-&gt; ns : agrupa

@enduml</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_roles_globales_vs_roles_de_clúster">Roles globales vs roles de clúster</h4>
<div class="paragraph">
<p><strong>Roles Globales (Global Roles)</strong></p>
</div>
<div class="paragraph">
<p>Aplican a nivel de Rancher, controlando acceso a funcionalidades administrativas.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 37. Roles globales predefinidos:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Rol</th>
<th class="tableblock halign-left valign-top">Permisos</th>
<th class="tableblock halign-left valign-top">Uso recomendado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Administrator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Acceso completo a Rancher y todos los recursos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Administradores de plataforma</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Standard User</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Crear clústeres, gestionar propios recursos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usuarios normales, developers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">User-Base</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ver dashboard, acceso mínimo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usuarios con permisos específicos por cluster/project</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Restricted Admin</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Admin sin capacidad de modificar auth settings</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Admins delegados</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Ver roles globales:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Listar roles globales
kubectl get globalroles

# Ver detalles de un rol
kubectl get globalrole admin -o yaml

# Ver bindings (asignaciones) de roles globales
kubectl get globalrolebindings

# Ver quién tiene rol de administrator
kubectl get globalrolebindings -o json | \
  jq '.items[] | select(.globalRoleName=="admin") | {user: .userName, group: .groupPrincipalName}'</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Crear rol global personalizado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: management.cattle.io/v3
kind: GlobalRole
metadata:
  name: cluster-creator
spec:
  displayName: "Cluster Creator"
  description: "Can create and manage clusters but not modify global settings"
  rules:
  # Puede gestionar clusters
  - apiGroups:
    - "management.cattle.io"
    resources:
    - "clusters"
    verbs:
    - "*"

  # Puede ver cloud credentials
  - apiGroups:
    - "management.cattle.io"
    resources:
    - "cloudcredentials"
    verbs:
    - "get"
    - "list"

  # Puede ver node templates
  - apiGroups:
    - "management.cattle.io"
    resources:
    - "nodetemplates"
    verbs:
    - "*"

  # No puede modificar auth settings
  - apiGroups:
    - "management.cattle.io"
    resources:
    - "authconfigs"
    verbs:
    - "get"
    - "list"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Asignar rol global a usuario:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: management.cattle.io/v3
kind: GlobalRoleBinding
metadata:
  name: user-john-cluster-creator
spec:
  globalRoleName: cluster-creator
  userName: "local://u-xxxxx"  # User ID de Rancher
---
# O asignar a grupo
apiVersion: management.cattle.io/v3
kind: GlobalRoleBinding
metadata:
  name: group-devops-cluster-creator
spec:
  globalRoleName: cluster-creator
  groupPrincipalName: "activedirectory_group://CN=DevOps,OU=Groups,DC=example,DC=com"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Roles de Clúster (Cluster Roles)</strong></p>
</div>
<div class="paragraph">
<p>Controlan acceso a recursos dentro de un clúster específico.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 38. Roles de clúster predefinidos:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Rol</th>
<th class="tableblock halign-left valign-top">Permisos</th>
<th class="tableblock halign-left valign-top">Uso recomendado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cluster Owner</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Acceso completo al clúster</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Administradores del clúster</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cluster Member</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Acceso lectura a la mayoría de recursos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usuarios que necesitan visibilidad del cluster</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">View Only</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Solo lectura a recursos básicos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Auditors, monitoring teams</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Create Projects</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Crear y gestionar proyectos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Team leads</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Manage Cluster Members</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gestionar usuarios del clúster</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Administradores delegados</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Manage Nodes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gestionar nodos del clúster</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Operations team</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Ver roles de clúster:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Listar cluster role templates (templates de Rancher)
kubectl get clusterroletemplates

# Ver detalles
kubectl get clusterroletemplate cluster-owner -o yaml

# Ver asignaciones de roles en un clúster
kubectl get clusterroletemplatebindings -n &lt;cluster-id&gt;

# Ejemplo: Ver quién tiene acceso al clúster
kubectl get clusterroletemplatebindings -n c-m-xxxxx -o json | \
  jq '.items[] | {role: .roleTemplateName, user: .userName, group: .groupPrincipalName}'</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Crear rol de clúster personalizado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: management.cattle.io/v3
kind: RoleTemplate
metadata:
  name: readonly-cluster-viewer
spec:
  builtin: false
  clusterCreatorDefault: false
  context: cluster
  displayName: "Read-Only Cluster Viewer"
  description: "Can view all resources but cannot modify anything"
  rules:
  # Ver nodos
  - apiGroups:
    - ""
    resources:
    - "nodes"
    verbs:
    - "get"
    - "list"
    - "watch"

  # Ver namespaces
  - apiGroups:
    - ""
    resources:
    - "namespaces"
    verbs:
    - "get"
    - "list"
    - "watch"

  # Ver todos los recursos de apps
  - apiGroups:
    - "apps"
    resources:
    - "*"
    verbs:
    - "get"
    - "list"
    - "watch"

  # Ver servicios
  - apiGroups:
    - ""
    resources:
    - "services"
    - "endpoints"
    verbs:
    - "get"
    - "list"
    - "watch"

  # Ver eventos
  - apiGroups:
    - ""
    resources:
    - "events"
    verbs:
    - "get"
    - "list"
    - "watch"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Asignar rol de clúster a usuario:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: management.cattle.io/v3
kind: ClusterRoleTemplateBinding
metadata:
  name: john-viewer-binding
  namespace: c-m-xxxxx  # Cluster ID
spec:
  clusterName: c-m-xxxxx
  roleTemplateName: readonly-cluster-viewer
  userName: "local://u-yyyyy"
---
# O asignar a grupo de AD
apiVersion: management.cattle.io/v3
kind: ClusterRoleTemplateBinding
metadata:
  name: ops-team-viewer
  namespace: c-m-xxxxx
spec:
  clusterName: c-m-xxxxx
  roleTemplateName: readonly-cluster-viewer
  groupPrincipalName: "activedirectory_group://CN=OpsTeam,OU=Groups,DC=example,DC=com"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Roles de Proyecto (Project Roles)</strong></p>
</div>
<div class="paragraph">
<p>Los proyectos son grupos lógicos de namespaces. Roles de proyecto controlan acceso a estos grupos.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 39. Roles de proyecto predefinidos:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Rol</th>
<th class="tableblock halign-left valign-top">Permisos</th>
<th class="tableblock halign-left valign-top">Uso recomendado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Project Owner</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Acceso completo al proyecto y sus namespaces</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Product owners, team leads</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Project Member</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gestionar workloads, no cambiar configuración proyecto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Developers, SREs</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read Only</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Solo lectura de recursos del proyecto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">QA, support teams</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Create Namespaces</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Crear namespaces dentro del proyecto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Platform engineers</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Ver roles de proyecto:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Listar project role templates
kubectl get projectroletemplates

# Ver asignaciones en un proyecto
kubectl get projectroletemplatebindings -n &lt;project-id&gt;

# Ejemplo
kubectl get projectroletemplatebindings -n p-xxxxx -o json | \
  jq '.items[] | {role: .roleTemplateName, user: .userName}'</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Crear rol de proyecto personalizado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: management.cattle.io/v3
kind: RoleTemplate
metadata:
  name: deployer
spec:
  builtin: false
  context: project
  displayName: "Application Deployer"
  description: "Can deploy and manage applications but not modify project settings"
  rules:
  # Gestionar deployments
  - apiGroups:
    - "apps"
    resources:
    - "deployments"
    - "replicasets"
    - "statefulsets"
    - "daemonsets"
    verbs:
    - "*"

  # Gestionar pods
  - apiGroups:
    - ""
    resources:
    - "pods"
    - "pods/log"
    - "pods/exec"
    verbs:
    - "*"

  # Gestionar servicios
  - apiGroups:
    - ""
    resources:
    - "services"
    verbs:
    - "*"

  # Gestionar configmaps y secrets
  - apiGroups:
    - ""
    resources:
    - "configmaps"
    - "secrets"
    verbs:
    - "*"

  # Ver ingress (no modificar)
  - apiGroups:
    - "networking.k8s.io"
    resources:
    - "ingresses"
    verbs:
    - "get"
    - "list"
    - "watch"

  # Gestionar HPA
  - apiGroups:
    - "autoscaling"
    resources:
    - "horizontalpodautoscalers"
    verbs:
    - "*"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_políticas_de_rbac_avanzadas">Políticas de RBAC avanzadas</h4>
<div class="paragraph">
<p><strong>Herencia de roles</strong></p>
</div>
<div class="paragraph">
<p>Rancher soporta herencia de roles para simplificar gestión.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de rol con herencia:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: management.cattle.io/v3
kind: RoleTemplate
metadata:
  name: senior-developer
spec:
  builtin: false
  context: project
  displayName: "Senior Developer"

  # Heredar permisos de developer básico
  roleTemplateNames:
  - "deployer"  # Rol definido anteriormente

  # Añadir permisos adicionales
  rules:
  # Puede gestionar ingress (además de los permisos heredados)
  - apiGroups:
    - "networking.k8s.io"
    resources:
    - "ingresses"
    verbs:
    - "*"

  # Puede gestionar PVCs
  - apiGroups:
    - ""
    resources:
    - "persistentvolumeclaims"
    verbs:
    - "*"

  # Puede ver logs de auditoría
  - apiGroups:
    - "management.cattle.io"
    resources:
    - "auditlogs"
    verbs:
    - "get"
    - "list"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>RBAC condicional con atributos</strong></p>
</div>
<div class="paragraph">
<p>Usar labels y annotations para control granular.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo: Restringir acceso solo a ciertos namespaces:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Rol que solo puede acceder a namespaces con label team=frontend
apiVersion: management.cattle.io/v3
kind: RoleTemplate
metadata:
  name: frontend-team-member
spec:
  context: cluster
  displayName: "Frontend Team Member"
  rules:
  - apiGroups:
    - ""
    resources:
    - "namespaces"
    verbs:
    - "get"
    - "list"
    resourceNames: []  # Vacío para permitir listar

  # Acceso completo en namespaces con label correcto
  # (implementado via Project membership en Rancher)
  - apiGroups:
    - "*"
    resources:
    - "*"
    verbs:
    - "*"
    # Limitado por Project que agrupa solo namespaces con team=frontend

# Crear proyecto que agrupa namespaces frontend
---
apiVersion: management.cattle.io/v3
kind: Project
metadata:
  name: frontend-project
  namespace: c-m-xxxxx
spec:
  clusterName: c-m-xxxxx
  displayName: "Frontend Project"
  namespaceDefaultResourceQuota:
    limit:
      limitsCpu: "4000m"
      limitsMemory: "8Gi"

  # Namespace selector (solo namespaces con este label)
  namespaceLabels:
    team: frontend</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Service Accounts con RBAC</strong></p>
</div>
<div class="paragraph">
<p>Para automatización y CI/CD.</p>
</div>
<div class="listingblock">
<div class="title">Crear service account con permisos específicos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># 1. Service Account
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ci-deployer
  namespace: production

---
# 2. Role con permisos necesarios
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: deployment-manager
  namespace: production
rules:
- apiGroups:
  - "apps"
  resources:
  - "deployments"
  - "replicasets"
  verbs:
  - "get"
  - "list"
  - "create"
  - "update"
  - "patch"

- apiGroups:
  - ""
  resources:
  - "pods"
  - "pods/log"
  verbs:
  - "get"
  - "list"

- apiGroups:
  - ""
  resources:
  - "configmaps"
  - "secrets"
  verbs:
  - "get"
  - "list"

---
# 3. RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: ci-deployer-binding
  namespace: production
subjects:
- kind: ServiceAccount
  name: ci-deployer
  namespace: production
roleRef:
  kind: Role
  name: deployment-manager
  apiGroup: rbac.authorization.k8s.io

---
# 4. Obtener token del service account
# kubectl create token ci-deployer -n production --duration=87600h
# O extraer del secret (K8s &lt; 1.24)
# kubectl get secret -n production ci-deployer-token-xxxxx -o jsonpath='{.data.token}' | base64 -d</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>RBAC para APIs específicas</strong></p>
</div>
<div class="paragraph">
<p>Controlar acceso a APIs custom y CRDs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Rol para gestionar solo recursos de Rancher Apps
apiVersion: management.cattle.io/v3
kind: RoleTemplate
metadata:
  name: app-catalog-manager
spec:
  context: cluster
  displayName: "App Catalog Manager"
  rules:
  # Gestionar apps del catálogo
  - apiGroups:
    - "catalog.cattle.io"
    resources:
    - "apps"
    - "clusterrepos"
    verbs:
    - "*"

  # Ver releases de Helm
  - apiGroups:
    - "helm.cattle.io"
    resources:
    - "releases"
    verbs:
    - "get"
    - "list"
    - "watch"

  # No puede modificar releases directamente
  - apiGroups:
    - "helm.cattle.io"
    resources:
    - "releases"
    verbs:
    - "create"
    - "update"
    - "delete"
    resourceNames: []  # Vacío = ninguno</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Auditoría de permisos</strong></p>
</div>
<div class="paragraph">
<p>Verificar qué puede hacer un usuario.</p>
</div>
<div class="listingblock">
<div class="title">Comandos de auditoría:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Verificar qué puede hacer un usuario (kubectl auth can-i)
kubectl auth can-i --list --as=user@example.com

# Verificar permiso específico
kubectl auth can-i create deployments -n production --as=user@example.com

# Ver todos los permisos de un usuario en Rancher
# Via API
curl -k "${RANCHER_URL}/v3/users/u-xxxxx/globalrolebindings" \
  -H "Authorization: Bearer ${API_TOKEN}"

curl -k "${RANCHER_URL}/v3/clusterroletemplatebindings?userId=u-xxxxx" \
  -H "Authorization: Bearer ${API_TOKEN}"

# Herramienta para auditar RBAC
# https://github.com/FairwindsOps/rbac-lookup
kubectl rbac-lookup user@example.com

# O instalar rbac-manager
kubectl krew install rbac-lookup
kubectl rbac-lookup --kind user --name user@example.com</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_proyectos_y_namespaces">Gestión de proyectos y namespaces</h4>
<div class="paragraph">
<p><strong>Proyectos en Rancher</strong></p>
</div>
<div class="paragraph">
<p>Los proyectos son una abstracción de Rancher que agrupa múltiples namespaces para facilitar gestión de permisos y cuotas.</p>
</div>
<div class="listingblock">
<div class="title">Arquitectura de proyectos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-plantuml hljs" data-lang="plantuml">@startuml
!define RECTANGLE rectangle

skinparam backgroundColor transparent

RECTANGLE "Cluster" as cluster {
  RECTANGLE "Project: Frontend" as pf {
    RECTANGLE "Namespace: frontend-prod" as nfp
    RECTANGLE "Namespace: frontend-staging" as nfs
    RECTANGLE "Namespace: frontend-dev" as nfd
  }

  RECTANGLE "Project: Backend" as pb {
    RECTANGLE "Namespace: backend-api" as nba
    RECTANGLE "Namespace: backend-worker" as nbw
  }

  RECTANGLE "Project: Database" as pdb {
    RECTANGLE "Namespace: postgres" as npg
    RECTANGLE "Namespace: redis" as nrd
  }

  RECTANGLE "System Namespaces" as sys {
    RECTANGLE "kube-system"
    RECTANGLE "cattle-system"
  }
}

note right of pf
  Project = Grupo lógico
  - RBAC unificado
  - Resource quotas
  - Network policies
  - Pod Security Policies
end note

@enduml</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Crear proyecto</strong></p>
</div>
<div class="listingblock">
<div class="title">Via Rancher UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Projects/Namespaces → Create Project
2. Configurar:
   Name: frontend-project
   Description: Frontend applications

3. Resource Quotas:
   - CPU Limit: 10 cores
   - Memory Limit: 20Gi
   - Pods: 100
   - Services: 50
   - ConfigMaps: 50
   - Secrets: 50
   - PVCs: 20

4. Container Default Resource Limits:
   - CPU Request: 100m
   - CPU Limit: 500m
   - Memory Request: 128Mi
   - Memory Limit: 512Mi

5. Pod Security Policy:
   - Restricted (recomendado para apps)
   - O Baseline

6. Network Isolation:
   - Enable Network Policy
   - Default deny all ingress

7. Members:
   - Añadir usuarios/grupos con roles (Owner/Member/Read-Only)

8. Create</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Via YAML:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: management.cattle.io/v3
kind: Project
metadata:
  name: frontend-project
  namespace: c-m-xxxxx  # Cluster ID
spec:
  clusterName: c-m-xxxxx
  displayName: "Frontend Project"
  description: "Frontend applications and services"

  # Resource quotas a nivel de proyecto
  resourceQuota:
    limit:
      limitsCpu: "10000m"
      limitsMemory: "20Gi"
      requestsCpu: "5000m"
      requestsMemory: "10Gi"
      pods: "100"
      services: "50"
      configmaps: "50"
      secrets: "50"
      persistentvolumeclaims: "20"

  # Default resource limits para containers
  namespaceDefaultResourceQuota:
    limit:
      limitsCpu: "500m"
      limitsMemory: "512Mi"
      requestsCpu: "100m"
      requestsMemory: "128Mi"

  # Container default limits
  containerDefaultResourceLimit:
    limitsCpu: "500m"
    limitsMemory: "512Mi"
    requestsCpu: "100m"
    requestsMemory: "128Mi"

  # Pod Security Policy
  podSecurityPolicyTemplateId: "restricted"

  # Enable network policy
  enableProjectNetworkIsolation: true</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Gestionar namespaces en proyectos</strong></p>
</div>
<div class="listingblock">
<div class="title">Crear namespace en un proyecto:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Namespace
metadata:
  name: frontend-prod
  annotations:
    # Asociar a proyecto
    field.cattle.io/projectId: c-m-xxxxx:p-yyyyy
  labels:
    # Labels automáticos de Rancher
    field.cattle.io/projectId: p-yyyyy
    # Labels custom
    environment: production
    team: frontend
spec:
  finalizers:
  - kubernetes</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Mover namespace entre proyectos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Via Rancher UI:
# Cluster → Projects/Namespaces → Select namespace → Move

# Via kubectl:
kubectl annotate namespace frontend-staging \
  field.cattle.io/projectId=c-m-xxxxx:p-zzzzz --overwrite

kubectl label namespace frontend-staging \
  field.cattle.io/projectId=p-zzzzz --overwrite</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Resource Quotas por namespace</strong></p>
</div>
<div class="paragraph">
<p>Rancher hereda quotas del proyecto pero se pueden personalizar.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: ResourceQuota
metadata:
  name: namespace-quota
  namespace: frontend-prod
spec:
  hard:
    # Compute
    requests.cpu: "4"
    requests.memory: "8Gi"
    limits.cpu: "8"
    limits.memory: "16Gi"

    # Storage
    requests.storage: "100Gi"
    persistentvolumeclaims: "10"

    # Objects
    pods: "50"
    services: "20"
    services.loadbalancers: "2"
    services.nodeports: "5"
    configmaps: "30"
    secrets: "30"
    replicationcontrollers: "20"

    # Extended resources
    requests.nvidia.com/gpu: "2"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Limit Ranges por namespace</strong></p>
</div>
<div class="paragraph">
<p>Definir límites default para containers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: LimitRange
metadata:
  name: default-limits
  namespace: frontend-prod
spec:
  limits:
  # Limits para containers
  - type: Container
    default:
      cpu: "500m"
      memory: "512Mi"
    defaultRequest:
      cpu: "100m"
      memory: "128Mi"
    max:
      cpu: "2"
      memory: "4Gi"
    min:
      cpu: "50m"
      memory: "64Mi"

  # Limits para pods
  - type: Pod
    max:
      cpu: "4"
      memory: "8Gi"

  # Limits para PVCs
  - type: PersistentVolumeClaim
    max:
      storage: "100Gi"
    min:
      storage: "1Gi"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Network Policies por proyecto</strong></p>
</div>
<div class="paragraph">
<p>Rancher puede crear network policies automáticas para aislar proyectos.</p>
</div>
<div class="listingblock">
<div class="title">Network Policy automática de proyecto:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Generada automáticamente por Rancher cuando
# enableProjectNetworkIsolation: true

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: np-default
  namespace: frontend-prod
spec:
  podSelector: {}
  policyTypes:
  - Ingress
  - Egress

  ingress:
  # Permitir desde mismo namespace
  - from:
    - podSelector: {}

  # Permitir desde otros namespaces del mismo proyecto
  - from:
    - namespaceSelector:
        matchLabels:
          field.cattle.io/projectId: p-yyyyy

  egress:
  # Permitir a mismo namespace
  - to:
    - podSelector: {}

  # Permitir a otros namespaces del mismo proyecto
  - to:
    - namespaceSelector:
        matchLabels:
          field.cattle.io/projectId: p-yyyyy

  # Permitir DNS
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
    ports:
    - protocol: UDP
      port: 53

  # Permitir tráfico externo (internet)
  - to:
    - namespaceSelector: {}
    ports:
    - protocol: TCP
      port: 443
    - protocol: TCP
      port: 80</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Best practices para gestión de usuarios</strong></p>
</div>
<div class="listingblock">
<div class="title">Recomendaciones:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Autenticación:
   - Usar IdP externo (LDAP/SAML/OIDC) en producción
   - Nunca usar usuarios locales en producción (excepto admin de emergencia)
   - Habilitar MFA cuando sea posible
   - Rotar contraseñas regularmente

2. Autorización:
   - Principio de menor privilegio (least privilege)
   - Usar grupos de AD/IdP en lugar de usuarios individuales
   - Documentar qué grupos tienen qué accesos
   - Revisar permisos trimestralmente

3. Roles:
   - Crear roles custom para necesidades específicas
   - Usar herencia para reducir duplicación
   - Nombrar roles descriptivamente
   - Documentar propósito de cada rol

4. Proyectos:
   - Un proyecto por aplicación/equipo
   - Configurar resource quotas apropiadas
   - Habilitar network isolation
   - Usar naming convention: &lt;team&gt;-&lt;app&gt;-&lt;env&gt;

5. Auditoría:
   - Habilitar audit logging (ver módulo 4.3)
   - Revisar logs de acceso regularmente
   - Monitorear cambios en permisos
   - Alertar sobre acciones privilegiadas

6. Service Accounts:
   - Usar SA para CI/CD, no usuarios
   - Limitar permisos de SA al mínimo necesario
   - Rotar tokens de SA
   - No usar SA por defecto</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Script de auditoría de usuarios</strong></p>
</div>
<div class="listingblock">
<div class="title">Herramienta para auditar accesos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
# Auditoría de usuarios y permisos en Rancher

echo "=== Rancher User Audit ==="
echo "Timestamp: $(date)"
echo ""

# 1. Usuarios con rol global de admin
echo "1. Global Administrators:"
kubectl get globalrolebindings -o json | \
  jq -r '.items[] | select(.globalRoleName=="admin") |
  "  - User: \(.userName // "N/A"), Group: \(.groupPrincipalName // "N/A")"'
echo ""

# 2. Usuarios por clúster
echo "2. Cluster Access Summary:"
for cluster in $(kubectl get clusters.management.cattle.io -o json | jq -r '.items[].metadata.name'); do
  echo "  Cluster: $cluster"
  kubectl get clusterroletemplatebindings -n $cluster -o json | \
    jq -r '.items[] | "    - \(.roleTemplateName): \(.userName // .groupPrincipalName)"' | \
    sort | uniq
  echo ""
done

# 3. Proyectos y sus miembros
echo "3. Project Membership:"
for project in $(kubectl get projects.management.cattle.io -A -o json | jq -r '.items[].metadata.name'); do
  ns=$(kubectl get projects.management.cattle.io -A -o json | \
    jq -r ".items[] | select(.metadata.name==\"$project\") | .metadata.namespace")
  echo "  Project: $project (Cluster: $ns)"
  kubectl get projectroletemplatebindings -n $project -o json 2&gt;/dev/null | \
    jq -r '.items[]? | "    - \(.roleTemplateName): \(.userName // .groupPrincipalName)"' | \
    sort | uniq || echo "    No members"
  echo ""
done

# 4. Service Accounts con ClusterRoleBindings
echo "4. Service Accounts with Cluster Roles:"
kubectl get clusterrolebindings -o json | \
  jq -r '.items[] | select(.subjects[]?.kind=="ServiceAccount") |
  "  - SA: \(.subjects[0].name) in namespace \(.subjects[0].namespace) -&gt; Role: \(.roleRef.name)"'
echo ""

# 5. Usuarios sin actividad reciente (requiere audit logs)
echo "5. Inactive Users (last 30 days):"
echo "  (Requires audit log analysis - not implemented in basic script)"

echo ""
echo "=== Audit Complete ==="</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_4_2_políticas_de_seguridad">4.2 Políticas de seguridad</h3>
<div class="paragraph">
<p>La seguridad en Kubernetes requiere múltiples capas de protección. Rancher facilita la implementación de políticas de seguridad a través de Pod Security Standards, Network Policies, gestión de secrets y admission controllers como OPA Gatekeeper.</p>
</div>
<div class="sect3">
<h4 id="_pod_security_standards">Pod Security Standards</h4>
<div class="paragraph">
<p>Los Pod Security Standards (PSS) reemplazan las Pod Security Policies (PSP) deprecadas desde Kubernetes 1.25.</p>
</div>
<div class="paragraph">
<p><strong>Niveles de Pod Security</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 40. Pod Security Standards levels:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Nivel</th>
<th class="tableblock halign-left valign-top">Restricciones</th>
<th class="tableblock halign-left valign-top">Uso recomendado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Privileged</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sin restricciones, permite cualquier configuración</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pods de sistema, CNI, storage drivers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Baseline</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Previene escalaciones de privilegios conocidas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aplicaciones que necesitan algunas capacidades elevadas</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Restricted</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fuertemente restringido, hardening completo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aplicaciones stateless, microservicios (recomendado)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Comparación detallada de niveles</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 41. Restricciones por nivel:</caption>
<colgroup>
<col style="width: 40%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Característica</th>
<th class="tableblock halign-left valign-top">Privileged</th>
<th class="tableblock halign-left valign-top">Baseline</th>
<th class="tableblock halign-left valign-top">Restricted</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Host namespaces (hostNetwork, hostPID, hostIPC)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Permitido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ No permitido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ No permitido</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Privileged containers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Permitido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ No permitido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ No permitido</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Capabilities (ALL)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Permitido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ Solo lista limitada</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ Solo NET_BIND_SERVICE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HostPath volumes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Permitido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ No permitido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ No permitido</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Host ports</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Permitido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ No permitido</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ No permitido</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AppArmor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Cualquiera</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Cualquiera</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ Solo runtime/default, localhost/*</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SELinux</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Cualquiera</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Cualquiera</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ Solo predefinidos</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/proc mount</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Cualquiera</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Cualquiera</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ Solo default</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Seccomp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Sin restricción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Sin restricción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ Obligatorio (RuntimeDefault, Localhost)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Run as user</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Cualquier UID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Cualquier UID</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ No puede ser root (UID != 0)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Volume types</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✓ Todos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ Solo seguros</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">✗ Solo seguros + restricciones adicionales</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Configurar PSS en Rancher</strong></p>
</div>
<div class="listingblock">
<div class="title">Habilitar PSS a nivel de namespace:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    # Enforce restricted en este namespace
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/enforce-version: latest

    # Warn si viola baseline
    pod-security.kubernetes.io/warn: baseline
    pod-security.kubernetes.io/warn-version: latest

    # Audit si viola privileged
    pod-security.kubernetes.io/audit: privileged
    pod-security.kubernetes.io/audit-version: latest</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Configurar PSS a nivel de clúster (Rancher):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Via Rancher Cluster Config
apiVersion: provisioning.cattle.io/v1
kind: Cluster
metadata:
  name: production-cluster
spec:
  rkeConfig:
    machineSelectorConfig:
      - config:
          # Habilitar admission controller
          kube-apiserver-arg:
            - "admission-control-config-file=/etc/rancher/rke2/admission-config.yaml"

          # Archivo de configuración
          kube-apiserver-extra-mount:
            - "/etc/rancher/rke2/admission-config.yaml:/etc/rancher/rke2/admission-config.yaml:ro"

# Contenido de admission-config.yaml
---
apiVersion: apiserver.config.k8s.io/v1
kind: AdmissionConfiguration
plugins:
- name: PodSecurity
  configuration:
    apiVersion: pod-security.admission.config.k8s.io/v1
    kind: PodSecurityConfiguration
    defaults:
      enforce: "restricted"
      enforce-version: "latest"
      audit: "restricted"
      audit-version: "latest"
      warn: "restricted"
      warn-version: "latest"
    exemptions:
      usernames: []
      runtimeClasses: []
      namespaces:
      - kube-system
      - kube-public
      - kube-node-lease
      - cattle-system
      - cattle-fleet-system
      - cattle-monitoring-system</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Ejemplos de pods según nivel de seguridad</strong></p>
</div>
<div class="listingblock">
<div class="title">Pod Restricted (más seguro):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: secure-app
  namespace: production
spec:
  securityContext:
    # Prohibir escalación de privilegios
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  containers:
  - name: app
    image: myapp:1.0

    securityContext:
      # No privilegios
      privileged: false
      # No permitir escalación
      allowPrivilegeEscalation: false
      # Eliminar todas las capabilities
      capabilities:
        drop:
        - ALL
      # Filesystem read-only
      readOnlyRootFilesystem: true
      # Run as non-root
      runAsNonRoot: true
      runAsUser: 1000

    # Usar volúmenes seguros
    volumeMounts:
    - name: tmp
      mountPath: /tmp
    - name: cache
      mountPath: /app/cache

  volumes:
  - name: tmp
    emptyDir: {}
  - name: cache
    emptyDir: {}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Pod Baseline (menos restricciones):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: baseline-app
  namespace: staging
spec:
  securityContext:
    runAsUser: 1000
    fsGroup: 1000

  containers:
  - name: app
    image: myapp:1.0

    securityContext:
      privileged: false
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
        add:
        - NET_BIND_SERVICE  # Permitido en baseline
        - CHOWN            # Permitido en baseline

    volumeMounts:
    - name: data
      mountPath: /data

  volumes:
  - name: data
    persistentVolumeClaim:
      claimName: app-data</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Pod Privileged (sistema):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: system-pod
  namespace: kube-system
spec:
  hostNetwork: true
  hostPID: true

  containers:
  - name: system-agent
    image: system-agent:1.0

    securityContext:
      privileged: true
      capabilities:
        add:
        - ALL

    volumeMounts:
    - name: host-root
      mountPath: /host

  volumes:
  - name: host-root
    hostPath:
      path: /
      type: Directory</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_network_policies">Network Policies</h4>
<div class="paragraph">
<p>Las Network Policies controlan el tráfico de red entre pods y servicios.</p>
</div>
<div class="paragraph">
<p><strong>Conceptos básicos</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 42. Tipos de Network Policies:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Función</th>
<th class="tableblock halign-left valign-top">Ejemplo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ingress</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controla tráfico entrante al pod</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Solo permitir desde frontend a backend</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Egress</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controla tráfico saliente del pod</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Permitir a database, bloquear internet</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Combined</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Controla ambos direcciones</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Microsegmentación completa</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Policy 1: Deny All (default deny)</strong></p>
</div>
<div class="paragraph">
<p>Base recomendada para zero-trust networking.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Denegar TODO el tráfico ingress en el namespace
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-ingress
  namespace: production
spec:
  podSelector: {}  # Aplica a todos los pods
  policyTypes:
  - Ingress
  # No hay regla ingress = denegar todo

---
# Denegar TODO el tráfico egress en el namespace
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-egress
  namespace: production
spec:
  podSelector: {}
  policyTypes:
  - Egress
  # No hay regla egress = denegar todo</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Policy 2: Allow desde frontend a backend</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: backend-allow-frontend
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: backend
      tier: api

  policyTypes:
  - Ingress

  ingress:
  # Permitir desde frontend
  - from:
    - podSelector:
        matchLabels:
          app: frontend
          tier: web
    ports:
    - protocol: TCP
      port: 8080

  # Permitir health checks desde ingress controller
  - from:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: ingress-nginx
    ports:
    - protocol: TCP
      port: 8080
      path: /health</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Policy 3: Allow a database</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-to-database
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: backend

  policyTypes:
  - Egress

  egress:
  # Permitir a PostgreSQL
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432

  # Permitir a Redis
  - to:
    - podSelector:
        matchLabels:
          app: redis
    ports:
    - protocol: TCP
      port: 6379

  # Permitir DNS
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
    - podSelector:
        matchLabels:
          k8s-app: kube-dns
    ports:
    - protocol: UDP
      port: 53</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Policy 4: Allow internet egress selectivo</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-external-apis
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: backend
      internet-access: "true"

  policyTypes:
  - Egress

  egress:
  # Permitir HTTPS a internet (excepto rangos privados)
  - to:
    - ipBlock:
        cidr: 0.0.0.0/0
        except:
        - 10.0.0.0/8
        - 172.16.0.0/12
        - 192.168.0.0/16
    ports:
    - protocol: TCP
      port: 443

  # Permitir HTTP (solo si es necesario)
  - to:
    - ipBlock:
        cidr: 0.0.0.0/0
        except:
        - 10.0.0.0/8
        - 172.16.0.0/12
        - 192.168.0.0/16
    ports:
    - protocol: TCP
      port: 80

  # Permitir DNS
  - to:
    - namespaceSelector: {}
    - podSelector:
        matchLabels:
          k8s-app: kube-dns
    ports:
    - protocol: UDP
      port: 53</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Policy 5: Microsegmentación por namespace</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: namespace-isolation
  namespace: production
spec:
  podSelector: {}

  policyTypes:
  - Ingress
  - Egress

  ingress:
  # Solo permitir desde mismo namespace
  - from:
    - podSelector: {}

  # Permitir desde ingress namespace
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx

  egress:
  # Permitir a mismo namespace
  - to:
    - podSelector: {}

  # Permitir a shared services namespace
  - to:
    - namespaceSelector:
        matchLabels:
          name: shared-services

  # Permitir DNS y metrics
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 443  # metrics server</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Verificar Network Policies</strong></p>
</div>
<div class="listingblock">
<div class="title">Comandos de verificación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Listar network policies
kubectl get networkpolicies -A

# Ver detalles de una policy
kubectl describe networkpolicy backend-allow-frontend -n production

# Test de conectividad
# Crear pod de test
kubectl run test-source --image=nicolaka/netshoot -n production --rm -it -- bash

# Dentro del pod:
# Test conectividad a backend (debería fallar si no hay policy)
curl http://backend-service:8080

# Test conectividad a internet
curl -I https://google.com

# Test DNS
nslookup backend-service

# Tool para visualizar network policies
# https://github.com/containership/networkpolicytool
kubectl create -f https://raw.githubusercontent.com/containership/networkpolicytool/master/deploy.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Rancher Network Policy en UI</strong></p>
</div>
<div class="listingblock">
<div class="title">Crear policy via Rancher UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Projects → Select Project → Resources → Network Policies
2. Add Policy
3. Configurar:
   Name: backend-ingress-policy
   Target Pods: app=backend

   Ingress Rules:
   - Add Rule
     - Source Type: Pod Selector
     - Label: app=frontend
     - Port: 8080
     - Protocol: TCP

   Egress Rules:
   - Add Rule
     - Destination Type: Pod Selector
     - Label: app=postgres
     - Port: 5432
     - Protocol: TCP

4. Create</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_secrets_y_certificados">Gestión de secrets y certificados</h4>
<div class="paragraph">
<p><strong>Tipos de Secrets en Kubernetes</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 43. Tipos de secrets:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Uso</th>
<th class="tableblock halign-left valign-top">Ejemplo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opaque</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Datos genéricos (default)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">API keys, passwords</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/tls</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Certificados TLS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ingress certificates</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/dockerconfigjson</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Credenciales de registry</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pull images privadas</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/service-account-token</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tokens de service account</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Autenticación API</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/basic-auth</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Autenticación básica</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTP basic auth</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/ssh-auth</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Claves SSH</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Git over SSH</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Crear secrets</strong></p>
</div>
<div class="listingblock">
<div class="title">Secret genérico (Opaque):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Desde literales
kubectl create secret generic app-secrets \
  --from-literal=db-password='SuperSecure123!' \
  --from-literal=api-key='sk-1234567890abcdef' \
  -n production

# Desde archivos
kubectl create secret generic app-config \
  --from-file=config.json=./config.json \
  --from-file=credentials=./creds.txt \
  -n production

# Desde YAML
cat &lt;&lt;EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: production
type: Opaque
stringData:  # stringData no necesita base64
  db-password: "SuperSecure123!"
  api-key: "sk-1234567890abcdef"
data:  # data debe estar en base64
  db-host: cG9zdGdyZXMuc3ZjLmNsdXN0ZXIubG9jYWw=  # postgres.svc.cluster.local
EOF</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Secret TLS:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Desde certificados existentes
kubectl create secret tls myapp-tls \
  --cert=path/to/tls.crt \
  --key=path/to/tls.key \
  -n production

# YAML
apiVersion: v1
kind: Secret
metadata:
  name: myapp-tls
  namespace: production
type: kubernetes.io/tls
data:
  tls.crt: |
    LS0tLS1CRUdJTi...  # Base64 del certificado
  tls.key: |
    LS0tLS1CRUdJTi...  # Base64 de la key privada</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Secret de registry:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Para pull de imágenes privadas
kubectl create secret docker-registry regcred \
  --docker-server=registry.example.com \
  --docker-username=myuser \
  --docker-password=mypassword \
  --docker-email=user@example.com \
  -n production

# Usar en pod
apiVersion: v1
kind: Pod
metadata:
  name: private-app
spec:
  imagePullSecrets:
  - name: regcred
  containers:
  - name: app
    image: registry.example.com/myapp:1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Usar secrets en pods</strong></p>
</div>
<div class="listingblock">
<div class="title">Como variables de entorno:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: app-with-secrets
spec:
  containers:
  - name: app
    image: myapp:1.0

    env:
    # Single secret value
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: app-secrets
          key: db-password

    # All secrets as env vars
    envFrom:
    - secretRef:
        name: app-secrets
        prefix: APP_  # Keys prefijadas con APP_</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Como volumen montado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: app-with-secret-volume
spec:
  containers:
  - name: app
    image: myapp:1.0

    volumeMounts:
    - name: secret-volume
      mountPath: /etc/secrets
      readOnly: true

    # Secrets disponibles como archivos:
    # /etc/secrets/db-password
    # /etc/secrets/api-key

  volumes:
  - name: secret-volume
    secret:
      secretName: app-secrets
      defaultMode: 0400  # Read-only por owner
      items:  # Opcional: seleccionar keys específicas
      - key: db-password
        path: database/password
        mode: 0400</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cifrado de secrets en etcd</strong></p>
</div>
<div class="paragraph">
<p>Por defecto, secrets se almacenan en base64 (no cifrados) en etcd.</p>
</div>
<div class="listingblock">
<div class="title">Habilitar encryption at rest:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Crear encryption config
apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
    - secrets
    providers:
    # AES-CBC encryption
    - aescbc:
        keys:
        - name: key1
          secret: &lt;BASE64_ENCODED_32_BYTE_KEY&gt;
    # Fallback a identity (sin cifrado) para leer secrets viejos
    - identity: {}

# Generar key aleatoria
head -c 32 /dev/urandom | base64

# Configurar en API server (RKE2)
# /etc/rancher/rke2/config.yaml
kube-apiserver-arg:
  - "encryption-provider-config=/var/lib/rancher/rke2/server/encryption-config.yaml"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Rotar secrets</strong></p>
</div>
<div class="listingblock">
<div class="title">Proceso de rotación de secrets:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
# Script de rotación de secret

SECRET_NAME="app-secrets"
NAMESPACE="production"

echo "Rotando secret: $SECRET_NAME en namespace: $NAMESPACE"

# 1. Generar nuevo password
NEW_PASSWORD=$(openssl rand -base64 32)

# 2. Crear nuevo secret
kubectl create secret generic ${SECRET_NAME}-new \
  --from-literal=db-password="$NEW_PASSWORD" \
  --dry-run=client -o yaml | kubectl apply -f -

# 3. Actualizar aplicación para usar nuevo secret
kubectl set env deployment/backend \
  --from=secret/${SECRET_NAME}-new \
  -n $NAMESPACE

# 4. Esperar rollout
kubectl rollout status deployment/backend -n $NAMESPACE

# 5. Verificar aplicación funciona
kubectl get pods -n $NAMESPACE -l app=backend

# 6. Eliminar secret viejo
kubectl delete secret $SECRET_NAME -n $NAMESPACE

# 7. Renombrar nuevo secret
kubectl get secret ${SECRET_NAME}-new -n $NAMESPACE -o yaml | \
  sed "s/${SECRET_NAME}-new/${SECRET_NAME}/g" | \
  kubectl apply -f -

kubectl delete secret ${SECRET_NAME}-new -n $NAMESPACE

echo "Rotación completada"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>External Secrets Operator</strong></p>
</div>
<div class="paragraph">
<p>Para integración con vaults externos (AWS Secrets Manager, HashiCorp Vault, Azure Key Vault).</p>
</div>
<div class="listingblock">
<div class="title">Instalar External Secrets Operator:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm repo add external-secrets https://charts.external-secrets.io
helm repo update

helm install external-secrets \
  external-secrets/external-secrets \
  -n external-secrets-system \
  --create-namespace</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Configurar con AWS Secrets Manager:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Secret Store
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-manager
  namespace: production
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1
      auth:
        secretRef:
          accessKeyIDSecretRef:
            name: aws-credentials
            key: access-key-id
          secretAccessKeySecretRef:
            name: aws-credentials
            key: secret-access-key

---
# External Secret
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: app-secrets
  namespace: production
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: SecretStore

  target:
    name: app-secrets  # Nombre del secret K8s a crear
    creationPolicy: Owner

  data:
  - secretKey: db-password
    remoteRef:
      key: production/database
      property: password

  - secretKey: api-key
    remoteRef:
      key: production/api
      property: key</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cert-manager para certificados</strong></p>
</div>
<div class="paragraph">
<p>Gestión automática de certificados TLS.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de Certificate:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: myapp-tls
  namespace: production
spec:
  secretName: myapp-tls-secret
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
  - myapp.example.com
  - api.myapp.example.com

  # Renovación automática
  renewBefore: 720h  # 30 días antes

---
# ClusterIssuer para Let's Encrypt
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: admin@example.com
    privateKeySecretRef:
      name: letsencrypt-prod-key
    solvers:
    - http01:
        ingress:
          class: nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_de_opa_gatekeeper">Configuración de OPA Gatekeeper</h4>
<div class="paragraph">
<p>OPA (Open Policy Agent) Gatekeeper permite definir políticas de seguridad y compliance como código.</p>
</div>
<div class="paragraph">
<p><strong>Instalar Gatekeeper</strong></p>
</div>
<div class="listingblock">
<div class="title">Instalación via Helm:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm repo add gatekeeper https://open-policy-agent.github.io/gatekeeper/charts
helm repo update

helm install gatekeeper gatekeeper/gatekeeper \
  --namespace gatekeeper-system \
  --create-namespace \
  --set replicas=3 \
  --set auditInterval=60

# Verificar instalación
kubectl get pods -n gatekeeper-system
kubectl get crd | grep gatekeeper</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Conceptos de Gatekeeper</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 44. Componentes principales:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Componente</th>
<th class="tableblock halign-left valign-top">Función</th>
<th class="tableblock halign-left valign-top">Ejemplo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ConstraintTemplate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Define la lógica de la política (Rego)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Template para validar labels</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constraint</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instancia de una template con parámetros</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Requerir label "owner" en todos los namespaces</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Config</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuración de sincronización de datos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sincronizar lista de namespaces</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assign/Mutation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Modificar recursos automáticamente</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Añadir labels por defecto</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Policy 1: Requerir labels obligatorios</strong></p>
</div>
<div class="listingblock">
<div class="title">ConstraintTemplate:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srequiredlabels
spec:
  crd:
    spec:
      names:
        kind: K8sRequiredLabels
      validation:
        openAPIV3Schema:
          type: object
          properties:
            labels:
              type: array
              items:
                type: string

  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequiredlabels

        violation[{"msg": msg, "details": {"missing_labels": missing}}] {
          provided := {label | input.review.object.metadata.labels[label]}
          required := {label | label := input.parameters.labels[_]}
          missing := required - provided
          count(missing) &gt; 0
          msg := sprintf("Missing required labels: %v", [missing])
        }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Constraint (usar la template):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequiredLabels
metadata:
  name: namespace-must-have-owner
spec:
  match:
    kinds:
    - apiGroups: [""]
      kinds: ["Namespace"]

  parameters:
    labels:
    - "owner"
    - "environment"
    - "cost-center"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Policy 2: Prohibir contenedores privilegiados</strong></p>
</div>
<div class="listingblock">
<div class="title">ConstraintTemplate:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8spsprivilegedcontainer
spec:
  crd:
    spec:
      names:
        kind: K8sPSPPrivilegedContainer

  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8spsprivilegedcontainer

        violation[{"msg": msg, "details": {}}] {
          c := input_containers[_]
          c.securityContext.privileged
          msg := sprintf("Privileged container is not allowed: %v", [c.name])
        }

        input_containers[c] {
          c := input.review.object.spec.containers[_]
        }

        input_containers[c] {
          c := input.review.object.spec.initContainers[_]
        }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Constraint:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sPSPPrivilegedContainer
metadata:
  name: no-privileged-containers
spec:
  match:
    kinds:
    - apiGroups: [""]
      kinds: ["Pod"]
    excludedNamespaces:
    - kube-system
    - cattle-system</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Policy 3: Limitar registries permitidos</strong></p>
</div>
<div class="listingblock">
<div class="title">ConstraintTemplate:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8sallowedrepos
spec:
  crd:
    spec:
      names:
        kind: K8sAllowedRepos
      validation:
        openAPIV3Schema:
          type: object
          properties:
            repos:
              type: array
              items:
                type: string

  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8sallowedrepos

        violation[{"msg": msg}] {
          container := input_containers[_]
          satisfied := [good | repo = input.parameters.repos[_] ; good = startswith(container.image, repo)]
          not any(satisfied)
          msg := sprintf("Container image %v does not come from approved registry", [container.image])
        }

        input_containers[c] {
          c := input.review.object.spec.containers[_]
        }

        input_containers[c] {
          c := input.review.object.spec.initContainers[_]
        }</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Constraint:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sAllowedRepos
metadata:
  name: allowed-docker-registries
spec:
  match:
    kinds:
    - apiGroups: [""]
      kinds: ["Pod"]
    namespaces:
    - production

  parameters:
    repos:
    - "registry.example.com/"
    - "docker.io/library/"
    - "gcr.io/myproject/"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Policy 4: Requerir resource limits</strong></p>
</div>
<div class="listingblock">
<div class="title">ConstraintTemplate y Constraint:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: k8srequireresourcelimits
spec:
  crd:
    spec:
      names:
        kind: K8sRequireResourceLimits

  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequireresourcelimits

        violation[{"msg": msg}] {
          container := input_containers[_]
          not container.resources.limits.cpu
          msg := sprintf("Container %v does not have CPU limit set", [container.name])
        }

        violation[{"msg": msg}] {
          container := input_containers[_]
          not container.resources.limits.memory
          msg := sprintf("Container %v does not have memory limit set", [container.name])
        }

        input_containers[c] {
          c := input.review.object.spec.containers[_]
        }

---
apiVersion: constraints.gatekeeper.sh/v1beta1
kind: K8sRequireResourceLimits
metadata:
  name: containers-must-have-limits
spec:
  match:
    kinds:
    - apiGroups: [""]
      kinds: ["Pod"]
    namespaces:
    - production
    - staging</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Mutation: Añadir labels automáticamente</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: mutations.gatekeeper.sh/v1alpha1
kind: Assign
metadata:
  name: add-default-labels
spec:
  applyTo:
  - groups: [""]
    kinds: ["Pod"]
    versions: ["v1"]

  match:
    scope: Namespaced
    namespaces:
    - production

  location: "metadata.labels.managed-by"
  parameters:
    assign:
      value: "gatekeeper"

---
# Añadir annotations
apiVersion: mutations.gatekeeper.sh/v1alpha1
kind: Assign
metadata:
  name: add-security-annotation
spec:
  applyTo:
  - groups: [""]
    kinds: ["Pod"]
    versions: ["v1"]

  location: "metadata.annotations.security-scan"
  parameters:
    assign:
      value: "required"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Verificar políticas de Gatekeeper</strong></p>
</div>
<div class="listingblock">
<div class="title">Comandos de verificación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Listar constraint templates
kubectl get constrainttemplates

# Listar constraints
kubectl get constraints

# Ver violaciones de una constraint
kubectl get k8srequiredlabels namespace-must-have-owner -o yaml

# Ver audit de violaciones
kubectl get constraints -o json | \
  jq '.items[] | {name: .metadata.name, violations: .status.totalViolations}'

# Test de política (dry-run)
cat &lt;&lt;EOF | kubectl apply --dry-run=server -f -
apiVersion: v1
kind: Pod
metadata:
  name: test-privileged
spec:
  containers:
  - name: nginx
    image: nginx
    securityContext:
      privileged: true
EOF
# Debería ser bloqueado si hay policy

# Ver logs de Gatekeeper
kubectl logs -n gatekeeper-system -l control-plane=controller-manager

# Métricas de Gatekeeper
kubectl port-forward -n gatekeeper-system svc/gatekeeper-webhook-service 8888:443
curl -k https://localhost:8888/metrics</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Biblioteca de políticas predefinidas</strong></p>
</div>
<div class="paragraph">
<p>Gatekeeper tiene una biblioteca de políticas comunes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Clonar repositorio de políticas
git clone https://github.com/open-policy-agent/gatekeeper-library.git

# Instalar políticas comunes
cd gatekeeper-library/library

# Ejemplo: Instalar política de replica limits
kubectl apply -f pod-security-policy/replica-limits/

# Ejemplo: Instalar política de allowed repos
kubectl apply -f general/allowedrepos/</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Best practices para políticas de seguridad</strong></p>
</div>
<div class="listingblock">
<div class="title">Recomendaciones:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Pod Security Standards:
   - Usar "restricted" por defecto
   - Solo "privileged" para system namespaces
   - Documentar excepciones
   - Auditar pods que no cumplen

2. Network Policies:
   - Comenzar con deny-all
   - Whitelist explícito (zero-trust)
   - Una policy por microservicio
   - Documentar flujos de tráfico
   - Testing regular

3. Secrets:
   - Nunca hardcodear en código
   - Usar external secrets manager (Vault, AWS SM)
   - Habilitar encryption at rest
   - Rotar regularmente (90 días)
   - Auditar accesos
   - Limitar scope (namespace-level)

4. Certificados:
   - Usar cert-manager para automatización
   - Renovación automática (30 días antes)
   - Wildcard certs solo si es necesario
   - Monitorear expiración
   - Backup de keys privadas

5. OPA Gatekeeper:
   - Empezar en modo audit (no enforce)
   - Políticas progresivas (warn → enforce)
   - Testing en staging primero
   - Documentar cada política
   - Revisar violaciones regularmente
   - Biblioteca de políticas estándar</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_5_gestión_de_aplicaciones">Módulo 5: Gestión de Aplicaciones</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_5_1_rancher_apps_marketplace">5.1 Rancher Apps &amp; Marketplace</h3>
<div class="paragraph">
<p>Rancher Apps &amp; Marketplace simplifica el despliegue de aplicaciones mediante un catálogo integrado de Helm charts. Proporciona una experiencia unificada para descubrir, instalar y gestionar aplicaciones en clústeres Kubernetes.</p>
</div>
<div class="sect3">
<h4 id="_catálogo_de_aplicaciones_integrado">Catálogo de aplicaciones integrado</h4>
<div class="paragraph">
<p>Rancher incluye varios catálogos predefinidos con aplicaciones populares y certificadas.</p>
</div>
<div class="paragraph">
<p><strong>Catálogos disponibles en Rancher</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 45. Catálogos predeterminados:</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 16.6666%;">
<col style="width: 33.3335%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Catálogo</th>
<th class="tableblock halign-left valign-top">Descripción</th>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Apps destacadas</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rancher Charts</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aplicaciones curadas y probadas por Rancher</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Built-in</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Monitoring, Logging, Longhorn, Istio</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Partner Charts</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apps de partners certificados de Rancher</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Built-in</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Portworx, Kasten, Sysdig</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Helm Stable (legacy)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Charts estables de Helm 2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Legacy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deprecado, migrar a nuevos repos</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Artifact Hub</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Catálogo público de Helm charts</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">External</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cualquier chart público</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Arquitectura del marketplace</strong></p>
</div>
<div class="listingblock">
<div class="title">Flujo de instalación de apps:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-plantuml hljs" data-lang="plantuml">@startuml
!define RECTANGLE rectangle

skinparam backgroundColor transparent

actor Usuario
participant "Rancher UI" as UI
participant "Rancher Apps" as Apps
database "Chart Repository\n(Helm Repo)" as Repo
participant "Helm Controller" as Helm
participant "Kubernetes API" as K8s

Usuario -&gt; UI: Seleccionar app del catálogo
UI -&gt; Apps: Request install
Apps -&gt; Repo: Download chart
Repo --&gt; Apps: Chart files
Apps -&gt; Helm: Install release
Helm -&gt; K8s: Create resources
K8s --&gt; Helm: Resources created
Helm --&gt; Apps: Release installed
Apps --&gt; UI: Installation complete
UI --&gt; Usuario: App ready

note right of Helm
  Helm v3 controller
  Release namespace
  Custom values
  Version tracking
end note

@enduml</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Explorar el marketplace</strong></p>
</div>
<div class="listingblock">
<div class="title">Via Rancher UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Apps → Charts
2. Ver categorías:
   - Featured: Apps destacadas
   - Database: PostgreSQL, MySQL, MongoDB, Redis
   - Monitoring: Prometheus, Grafana, Rancher Monitoring
   - Logging: Loki, Elasticsearch, Fluentd
   - Storage: Longhorn, Rook, MinIO
   - Networking: Traefik, NGINX, Istio
   - Security: Falco, Vault, Cert-Manager
   - CI/CD: ArgoCD, Jenkins, GitLab Runner

3. Buscar apps:
   - Barra de búsqueda
   - Filtros por categoría
   - Ordenar por popularidad/nombre

4. Ver detalles de app:
   - README
   - Versions disponibles
   - Requirements
   - Values (configuración)
   - Dependencies</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Añadir repositorios de charts</strong></p>
</div>
<div class="listingblock">
<div class="title">Añadir repo via UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Apps → Repositories
2. Create
3. Configurar:
   Name: my-charts
   Index URL: https://charts.example.com/index.yaml

   Opciones:
   - Git Repo: Para charts en Git
   - HTTP(S): Para charts en servidor web
   - OCI: Para charts en registry OCI (Harbor, GHCR)

4. Authentication (si necesario):
   - HTTP Basic Auth
   - Bearer Token
   - SSH Key (Git)

5. Create</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Añadir repo via YAML:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: catalog.cattle.io/v1
kind: ClusterRepo
metadata:
  name: my-charts
spec:
  # HTTP(S) repository
  url: https://charts.example.com

  # O Git repository
  gitRepo: https://github.com/myorg/charts.git
  gitBranch: main

  # Autenticación HTTP Basic
  clientSecret:
    name: my-charts-auth
    namespace: cattle-system

  # Refresh interval
  forceUpdate: false

  # Insecure skip TLS verify (no recomendado)
  insecure: false

  # CA cert (si es necesario)
  caBundle: |
    -----BEGIN CERTIFICATE-----
    MIIDXTCCAkWgAwIBAgIJAKJ...
    -----END CERTIFICATE-----

---
# Secret para autenticación
apiVersion: v1
kind: Secret
metadata:
  name: my-charts-auth
  namespace: cattle-system
type: kubernetes.io/basic-auth
stringData:
  username: myuser
  password: mypassword</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Añadir repo OCI (Harbor/GHCR):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: catalog.cattle.io/v1
kind: ClusterRepo
metadata:
  name: harbor-charts
spec:
  # OCI registry
  url: oci://harbor.example.com/charts

  # Autenticación
  clientSecret:
    name: harbor-registry-creds
    namespace: cattle-system

---
apiVersion: v1
kind: Secret
metadata:
  name: harbor-registry-creds
  namespace: cattle-system
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: eyJhdXRocyI6eyJoYXJib3IuZXhhbXBsZS5jb20iOnsidXNlcm5hbWUiOiJhZG1pbiIsInBhc3N3b3JkIjoiSGFyYm9yMTIzNDUiLCJhdXRoIjoiWVdSdGFXNDZTR0Z5WW05eU1USXpORFU9In19fQ==</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_instalación_de_aplicaciones_desde_helm_charts">Instalación de aplicaciones desde Helm charts</h4>
<div class="paragraph">
<p><strong>Instalar app desde el marketplace</strong></p>
</div>
<div class="listingblock">
<div class="title">Proceso de instalación paso a paso:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Ejemplo: Instalar PostgreSQL

1. Cluster → Apps → Charts
2. Buscar "postgresql"
3. Seleccionar "PostgreSQL" (Bitnami)
4. Click "Install"

5. Configuración básica:
   - Name: postgres-prod
   - Namespace: database (crear si no existe)
   - Project: Database Project
   - Description: Production PostgreSQL database

6. Chart Options:
   Tab "Values YAML":
   Editar configuración en YAML o usar form

7. Configuración importante:

   Global:
     postgresql.postgresqlUsername: postgres
     postgresql.postgresqlPassword: &lt;secure-password&gt;
     postgresql.postgresqlDatabase: myapp

   Persistence:
     persistence.enabled: true
     persistence.storageClass: fast-ssd
     persistence.size: 100Gi

   Resources:
     resources.requests.memory: 2Gi
     resources.requests.cpu: 1000m
     resources.limits.memory: 4Gi
     resources.limits.cpu: 2000m

   Replication:
     replication.enabled: true
     replication.readReplicas: 2

   Metrics:
     metrics.enabled: true
     metrics.serviceMonitor.enabled: true

8. Review and Install
9. Ver progreso en Apps → Installed Apps</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Configuración avanzada con values.yaml</strong></p>
</div>
<div class="listingblock">
<div class="title">Ejemplo completo de values para PostgreSQL:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Global
global:
  postgresql:
    postgresqlUsername: postgres
    postgresqlPassword: "SuperSecurePassword123!"
    postgresqlDatabase: myapp

# Image
image:
  registry: docker.io
  repository: bitnami/postgresql
  tag: 15.5.0
  pullPolicy: IfNotPresent

# Replication
replication:
  enabled: true
  readReplicas: 2
  synchronousCommit: "on"
  numSynchronousReplicas: 1

# Persistence
persistence:
  enabled: true
  storageClass: "fast-ssd"
  accessModes:
  - ReadWriteOnce
  size: 100Gi
  annotations:
    volume.beta.kubernetes.io/storage-class: fast-ssd

# Resources
resources:
  requests:
    memory: 2Gi
    cpu: 1000m
  limits:
    memory: 4Gi
    cpu: 2000m

# PostgreSQL configuration
postgresqlConfiguration:
  max_connections: "200"
  shared_buffers: "512MB"
  effective_cache_size: "2GB"
  maintenance_work_mem: "256MB"
  checkpoint_completion_target: "0.9"
  wal_buffers: "16MB"
  default_statistics_target: "100"
  random_page_cost: "1.1"
  work_mem: "10MB"

# Backup
backup:
  enabled: true
  schedule: "0 2 * * *"  # Daily at 2 AM
  retention: 7
  storageClass: "standard"

# Metrics
metrics:
  enabled: true
  serviceMonitor:
    enabled: true
    namespace: cattle-monitoring-system
  resources:
    requests:
      memory: 256Mi
      cpu: 100m
    limits:
      memory: 512Mi
      cpu: 200m

# Security
securityContext:
  enabled: true
  fsGroup: 1001
  runAsUser: 1001

containerSecurityContext:
  enabled: true
  runAsUser: 1001
  runAsNonRoot: true

# Network policy
networkPolicy:
  enabled: true
  allowExternal: false
  explicitNamespacesSelector:
    matchLabels:
      name: backend

# Service
service:
  type: ClusterIP
  port: 5432
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-internal: "true"

# Readiness and liveness probes
livenessProbe:
  enabled: true
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1

readinessProbe:
  enabled: true
  initialDelaySeconds: 5
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 6
  successThreshold: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Instalar con CLI (kubectl)</strong></p>
</div>
<div class="listingblock">
<div class="title">Usando Helm directamente:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Añadir repositorio
helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update

# Buscar charts
helm search repo postgresql

# Inspeccionar chart
helm show chart bitnami/postgresql
helm show values bitnami/postgresql &gt; postgresql-values.yaml

# Editar valores
vim postgresql-values.yaml

# Dry-run (test)
helm install postgres-prod bitnami/postgresql \
  --namespace database \
  --create-namespace \
  --values postgresql-values.yaml \
  --dry-run --debug

# Instalar
helm install postgres-prod bitnami/postgresql \
  --namespace database \
  --create-namespace \
  --values postgresql-values.yaml \
  --version 12.12.10

# Verificar instalación
helm list -n database
helm status postgres-prod -n database
kubectl get all -n database</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Instalar apps con dependencias</strong></p>
</div>
<div class="paragraph">
<p>Algunas apps requieren otras apps instaladas primero.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo: Instalar app que requiere cert-manager:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># 1. Instalar cert-manager primero
helm repo add jetstack https://charts.jetstack.io
helm install cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --version v1.14.0 \
  --set installCRDs=true

# Esperar a que esté listo
kubectl wait --for=condition=Available --timeout=300s \
  -n cert-manager deployment --all

# 2. Ahora instalar app que depende de cert-manager
helm install myapp myrepo/myapp \
  --namespace myapp \
  --create-namespace \
  --set certManager.enabled=true</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Troubleshooting instalación</strong></p>
</div>
<div class="listingblock">
<div class="title">Comandos de diagnóstico:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver estado de release
helm status myapp -n myapp

# Ver historial de releases
helm history myapp -n myapp

# Ver valores actuales
helm get values myapp -n myapp

# Ver todos los valores (incluidos defaults)
helm get values myapp -n myapp --all

# Ver manifest generado
helm get manifest myapp -n myapp

# Ver hooks de pre/post install
helm get hooks myapp -n myapp

# Ver notas de instalación
helm get notes myapp -n myapp

# Ver logs de pods de la app
kubectl logs -n myapp -l app=myapp --tail=100

# Ver eventos del namespace
kubectl get events -n myapp --sort-by='.lastTimestamp'

# Describe pods con problemas
kubectl describe pod -n myapp &lt;pod-name&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_versiones_y_actualizaciones">Gestión de versiones y actualizaciones</h4>
<div class="paragraph">
<p><strong>Ver versiones disponibles</strong></p>
</div>
<div class="listingblock">
<div class="title">Listar versiones de un chart:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Via Helm
helm search repo postgresql --versions | head -20

# Via Rancher UI
# Apps → Charts → PostgreSQL → Versions dropdown

# Ver changelog entre versiones
helm show readme bitnami/postgresql --version 12.12.10</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Actualizar aplicación</strong></p>
</div>
<div class="listingblock">
<div class="title">Update via Rancher UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Apps → Installed Apps
2. Seleccionar app (postgres-prod)
3. Click "Upgrade"
4. Opciones:
   - Change Version: Seleccionar nueva versión
   - Edit Values: Modificar configuración
   - Review Diff: Ver cambios en valores

5. Upgrade Strategy:
   - Rolling Update (default)
   - Recreate (downtime)

6. Click "Upgrade"
7. Monitorear rollout</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Update via Helm CLI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver versión actual
helm list -n database

# Actualizar a nueva versión (mantener valores)
helm upgrade postgres-prod bitnami/postgresql \
  --namespace database \
  --version 13.0.0 \
  --reuse-values

# Actualizar con nuevos valores
helm upgrade postgres-prod bitnami/postgresql \
  --namespace database \
  --version 13.0.0 \
  --values postgresql-values-updated.yaml

# Dry-run para ver cambios
helm upgrade postgres-prod bitnami/postgresql \
  --namespace database \
  --version 13.0.0 \
  --reuse-values \
  --dry-run --debug

# Actualizar solo valores (misma versión)
helm upgrade postgres-prod bitnami/postgresql \
  --namespace database \
  --reuse-values \
  --set resources.requests.memory=4Gi

# Forzar upgrade (aunque no hay cambios)
helm upgrade postgres-prod bitnami/postgresql \
  --namespace database \
  --reuse-values \
  --force

# Wait hasta que esté ready
helm upgrade postgres-prod bitnami/postgresql \
  --namespace database \
  --version 13.0.0 \
  --reuse-values \
  --wait --timeout 10m</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Rollback a versión anterior</strong></p>
</div>
<div class="listingblock">
<div class="title">Rollback via Rancher UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Apps → Installed Apps
2. Seleccionar app
3. Click en menú (⋮) → Rollback
4. Seleccionar revisión:
   - Ver historial de revisiones
   - Ver diff de valores
5. Confirm Rollback</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Rollback via Helm:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver historial
helm history postgres-prod -n database

# Output:
# REVISION  UPDATED                   STATUS      CHART              DESCRIPTION
# 1         Mon Oct 30 10:00:00 2025  superseded  postgresql-12.12.10 Install complete
# 2         Mon Oct 30 14:00:00 2025  superseded  postgresql-13.0.0   Upgrade complete
# 3         Mon Oct 30 16:00:00 2025  deployed    postgresql-13.1.0   Upgrade complete

# Rollback a revisión anterior
helm rollback postgres-prod -n database

# Rollback a revisión específica
helm rollback postgres-prod 2 -n database

# Dry-run
helm rollback postgres-prod 2 -n database --dry-run

# Forzar rollback
helm rollback postgres-prod 2 -n database --force

# Wait hasta completar
helm rollback postgres-prod 2 -n database --wait --timeout 5m</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Estrategias de actualización</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 46. Tabla de estrategias:</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 16.6666%;">
<col style="width: 33.3335%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Estrategia</th>
<th class="tableblock halign-left valign-top">Descripción</th>
<th class="tableblock halign-left valign-top">Downtime</th>
<th class="tableblock halign-left valign-top">Uso</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rolling Update</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Actualizar pods gradualmente</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aplicaciones stateless (recomendado)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recreate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eliminar todos los pods, crear nuevos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aplicaciones stateful con constraints</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Blue-Green</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Desplegar versión nueva, switchear tráfico</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rollback instantáneo requerido</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Canary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Desplegar a % de usuarios, incrementar gradualmente</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Testing en producción, apps críticas</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Políticas de actualización automática</strong></p>
</div>
<div class="listingblock">
<div class="title">Auto-update con Rancher Fleet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: fleet.cattle.io/v1alpha1
kind: GitRepo
metadata:
  name: apps-repo
  namespace: fleet-default
spec:
  repo: https://github.com/myorg/fleet-apps
  branch: main

  # Auto-update cada 15 minutos
  pollingInterval: 15m

  targets:
  - name: production
    clusterSelector:
      matchLabels:
        environment: production

  # Helm chart options
  helmRepoURLRegex: "https://charts.bitnami.com/.*"

  # Auto-update strategy
  forceNamespace: ""

  # Diff options
  diff:
    comparePatches:
    - apiVersion: apps/v1
      kind: Deployment
      operations:
      - {"op":"remove", "path":"/spec/template/metadata/annotations"}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_creación_de_repositorios_personalizados">Creación de repositorios personalizados</h4>
<div class="paragraph">
<p><strong>Estructura de un repositorio Helm</strong></p>
</div>
<div class="listingblock">
<div class="title">Estructura de directorios:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">my-charts/
├── index.yaml              # Índice del repositorio
├── myapp-1.0.0.tgz        # Chart empaquetado
├── myapp-1.1.0.tgz
├── postgres-custom-1.0.0.tgz
└── charts/                 # Charts fuente (opcional)
    ├── myapp/
    │   ├── Chart.yaml
    │   ├── values.yaml
    │   ├── templates/
    │   │   ├── deployment.yaml
    │   │   ├── service.yaml
    │   │   └── ingress.yaml
    │   └── README.md
    └── postgres-custom/
        ├── Chart.yaml
        ├── values.yaml
        └── templates/</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Crear un chart desde cero</strong></p>
</div>
<div class="listingblock">
<div class="title">Crear estructura de chart:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Crear esqueleto del chart
helm create myapp

# Estructura generada
myapp/
├── Chart.yaml          # Metadata del chart
├── values.yaml         # Valores por defecto
├── charts/             # Dependencias
├── templates/          # Templates de K8s
│   ├── deployment.yaml
│   ├── service.yaml
│   ├── ingress.yaml
│   ├── serviceaccount.yaml
│   ├── _helpers.tpl   # Helpers de template
│   ├── hpa.yaml
│   ├── NOTES.txt      # Notas post-instalación
│   └── tests/         # Tests del chart
│       └── test-connection.yaml
└── .helmignore        # Archivos a ignorar

# Editar Chart.yaml
cat &gt; myapp/Chart.yaml &lt;&lt;EOF
apiVersion: v2
name: myapp
description: A Helm chart for MyApp microservice
type: application
version: 1.0.0
appVersion: "1.0.0"

maintainers:
- name: Platform Team
  email: platform@example.com

keywords:
- microservice
- api
- backend

home: https://github.com/myorg/myapp
sources:
- https://github.com/myorg/myapp

icon: https://example.com/logo.png

dependencies:
- name: postgresql
  version: "12.x.x"
  repository: https://charts.bitnami.com/bitnami
  condition: postgresql.enabled
- name: redis
  version: "17.x.x"
  repository: https://charts.bitnami.com/bitnami
  condition: redis.enabled
EOF</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Editar values.yaml:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Default values for myapp
replicaCount: 3

image:
  repository: myregistry.example.com/myapp
  pullPolicy: IfNotPresent
  tag: ""  # Overrides the image tag (default: Chart appVersion)

imagePullSecrets:
- name: registry-secret

nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations: {}
  name: ""

podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "8080"
  prometheus.io/path: "/metrics"

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: true

service:
  type: ClusterIP
  port: 80
  targetPort: 8080

ingress:
  enabled: true
  className: "nginx"
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "100"
  hosts:
  - host: myapp.example.com
    paths:
    - path: /
      pathType: Prefix
  tls:
  - secretName: myapp-tls
    hosts:
    - myapp.example.com

resources:
  limits:
    cpu: 1000m
    memory: 1Gi
  requests:
    cpu: 200m
    memory: 256Mi

autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app
            operator: In
            values:
            - myapp
        topologyKey: kubernetes.io/hostname

# Application config
config:
  logLevel: info
  database:
    host: postgres
    port: 5432
    name: myapp
  redis:
    host: redis
    port: 6379

# PostgreSQL dependency
postgresql:
  enabled: true
  auth:
    username: myapp
    password: ""  # Will be generated
    database: myapp
  primary:
    persistence:
      size: 10Gi

# Redis dependency
redis:
  enabled: true
  auth:
    enabled: true
    password: ""  # Will be generated
  master:
    persistence:
      size: 8Gi</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Empaquetar y publicar chart</strong></p>
</div>
<div class="listingblock">
<div class="title">Empaquetar chart:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Validar chart
helm lint myapp/

# Empaquetar
helm package myapp/
# Output: myapp-1.0.0.tgz

# Generar índice del repositorio
helm repo index . --url https://charts.example.com

# Ver index.yaml generado
cat index.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de index.yaml:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
entries:
  myapp:
  - apiVersion: v2
    appVersion: 1.0.0
    created: "2025-10-30T10:00:00.000000000Z"
    description: A Helm chart for MyApp microservice
    digest: 3a2b1c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d3e4f5a6b7c8d9e0f1a2b
    home: https://github.com/myorg/myapp
    keywords:
    - microservice
    - api
    - backend
    maintainers:
    - email: platform@example.com
      name: Platform Team
    name: myapp
    sources:
    - https://github.com/myorg/myapp
    urls:
    - https://charts.example.com/myapp-1.0.0.tgz
    version: 1.0.0</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Opción 1: Publicar en servidor web estático</strong></p>
</div>
<div class="listingblock">
<div class="title">Usando nginx:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Subir charts a servidor web
scp *.tgz index.yaml user@charts.example.com:/var/www/charts/

# Configurar nginx
cat &gt; /etc/nginx/sites-available/charts &lt;&lt;EOF
server {
    listen 80;
    server_name charts.example.com;

    root /var/www/charts;

    location / {
        autoindex on;
        try_files \$uri \$uri/ =404;
    }

    # CORS headers (opcional)
    add_header Access-Control-Allow-Origin *;
}
EOF

ln -s /etc/nginx/sites-available/charts /etc/nginx/sites-enabled/
nginx -t
systemctl reload nginx

# Añadir a Rancher
helm repo add mycompany https://charts.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Opción 2: Publicar en Harbor</strong></p>
</div>
<div class="paragraph">
<p>Harbor soporta Helm charts nativamente.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Login a Harbor
helm registry login harbor.example.com -u admin

# Push chart
helm push myapp-1.0.0.tgz oci://harbor.example.com/charts

# Añadir repo en Rancher
# Apps → Repositories → Create
# Type: OCI
# URL: oci://harbor.example.com/charts</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Opción 3: Publicar en GitHub Pages</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Estructura del repositorio Git
my-charts/
├── charts/           # Charts fuente
│   └── myapp/
├── docs/            # GitHub Pages (publicado)
│   ├── index.yaml
│   ├── myapp-1.0.0.tgz
│   └── myapp-1.1.0.tgz
└── .github/
    └── workflows/
        └── release.yaml

# GitHub Action para automatizar release
cat &gt; .github/workflows/release.yaml &lt;&lt;EOF
name: Release Charts

on:
  push:
    branches:
      - main
    paths:
      - 'charts/**'

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Configure Git
      run: |
        git config user.name "\$GITHUB_ACTOR"
        git config user.email "\$GITHUB_ACTOR@users.noreply.github.com"

    - name: Install Helm
      uses: azure/setup-helm@v3

    - name: Run chart-releaser
      uses: helm/chart-releaser-action@v1.5.0
      env:
        CR_TOKEN: "\${{ secrets.GITHUB_TOKEN }}"
EOF

# Habilitar GitHub Pages en settings del repo
# Source: gh-pages branch

# URL del repo: https://myorg.github.io/my-charts</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Opción 4: ChartMuseum (servidor dedicado)</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Instalar ChartMuseum
helm repo add chartmuseum https://chartmuseum.github.io/charts
helm install chartmuseum chartmuseum/chartmuseum \
  --namespace chartmuseum \
  --create-namespace \
  --set env.open.DISABLE_API=false \
  --set env.open.ALLOW_OVERWRITE=true \
  --set persistence.enabled=true \
  --set persistence.size=10Gi \
  --set ingress.enabled=true \
  --set ingress.hosts[0].name=charts.example.com

# Push chart a ChartMuseum
curl --data-binary "@myapp-1.0.0.tgz" \
  https://charts.example.com/api/charts

# Añadir repo
helm repo add mycompany https://charts.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>CI/CD para charts</strong></p>
</div>
<div class="listingblock">
<div class="title">Pipeline GitLab CI completo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># .gitlab-ci.yml
stages:
  - validate
  - package
  - publish

variables:
  CHART_NAME: myapp
  CHART_REPO: https://charts.example.com

validate:
  stage: validate
  image: alpine/helm:latest
  script:
    - helm lint charts/$CHART_NAME/
    - helm template charts/$CHART_NAME/ &gt; /dev/null
  rules:
    - changes:
      - charts/**/*

package:
  stage: package
  image: alpine/helm:latest
  script:
    - helm package charts/$CHART_NAME/
    - helm repo index . --url $CHART_REPO
  artifacts:
    paths:
      - "*.tgz"
      - index.yaml
    expire_in: 1 week
  rules:
    - changes:
      - charts/**/*
      if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

publish:
  stage: publish
  image: curlimages/curl:latest
  script:
    - |
      for chart in *.tgz; do
        curl --fail -u $CHART_USER:$CHART_PASSWORD \
          --data-binary "@$chart" \
          $CHART_REPO/api/charts
      done
  rules:
    - changes:
      - charts/**/*
      if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  dependencies:
    - package</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Best practices para charts</strong></p>
</div>
<div class="listingblock">
<div class="title">Recomendaciones:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Versionado:
   - Seguir Semantic Versioning (MAJOR.MINOR.PATCH)
   - Version en Chart.yaml != appVersion
   - Changelog en cada release
   - Tags Git para cada versión

2. Values:
   - Valores sensatos por defecto
   - Documentar cada valor en values.yaml
   - values-production.yaml para overrides
   - No hardcodear secrets

3. Templates:
   - Usar _helpers.tpl para código reutilizable
   - Validar inputs con required/fail
   - Labels consistentes (app.kubernetes.io/*)
   - Annotations para metadata

4. Testing:
   - helm lint en CI
   - helm template para validar
   - Tests en templates/tests/
   - Probar en staging antes de prod

5. Documentación:
   - README.md completo
   - NOTES.txt con instrucciones post-install
   - Ejemplos de values
   - Troubleshooting guide

6. Seguridad:
   - No incluir secrets en values
   - Usar external secrets
   - SecurityContext en pods
   - NetworkPolicy por defecto
   - Escaneo de vulnerabilidades</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5_2_workloads_y_servicios">5.2 Workloads y servicios</h3>
<div class="paragraph">
<p>Rancher proporciona una interfaz unificada para gestionar todos los tipos de workloads de Kubernetes (Deployments, StatefulSets, DaemonSets), services, ingress y configuración (ConfigMaps y Secrets).</p>
</div>
<div class="sect3">
<h4 id="_gestión_de_deployments_statefulsets_y_daemonsets">Gestión de Deployments, StatefulSets y DaemonSets</h4>
<div class="paragraph">
<p><strong>Conceptos generales</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 47. Tabla comparativa de workload types:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Workload</th>
<th class="tableblock halign-left valign-top">Stateless</th>
<th class="tableblock halign-left valign-top">Replicas</th>
<th class="tableblock halign-left valign-top">Permanencia</th>
<th class="tableblock halign-left valign-top">Uso</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deployment</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Múltiples</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aplicaciones web, APIs, backends stateless</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">StatefulSet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Múltiples</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bases de datos, cache, sistemas de ficheros</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DaemonSet</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Depende</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 por nodo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Logging, monitoring, networking</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Job</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Depende</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Temporal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tareas batch, backups, scripts</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CronJob</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Depende</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Temporal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Temporal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tareas programadas</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Crear y gestionar Deployments</strong></p>
</div>
<div class="listingblock">
<div class="title">Via Rancher UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Workloads → Deployments
2. Create
3. Configurar:
   Name: nginx-app
   Namespace: default
   Replicas: 3

   Container Image:
   - Image: nginx:1.25
   - Pull Policy: IfNotPresent

   Port Mapping:
   - Name: http
   - Port: 8080
   - Container Port: 80

   Resources:
   - Requests CPU: 100m
   - Requests Memory: 128Mi
   - Limits CPU: 500m
   - Limits Memory: 512Mi

4. Security:
   - Security Context
   - Read-only filesystem: true
   - Run as non-root: true

5. Health:
   - Liveness Probe
   - Readiness Probe
   - Startup Probe

6. Scheduling:
   - Node selectors
   - Affinity rules
   - Tolerations

7. Create</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">YAML Deployment completo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-app
  namespace: default
  labels:
    app.kubernetes.io/name: nginx
    app.kubernetes.io/version: "1.25"
    app.kubernetes.io/component: web
  annotations:
    description: "Production NGINX web server"
spec:
  replicas: 3

  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0

  selector:
    matchLabels:
      app: nginx
      tier: web

  template:
    metadata:
      labels:
        app: nginx
        tier: web
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"

    spec:
      serviceAccountName: nginx-sa

      # Pod security
      securityContext:
        runAsNonRoot: true
        runAsUser: 101
        fsGroup: 101

      # Pod affinity para distribuir replicas
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - nginx
              topologyKey: kubernetes.io/hostname

      # Node selectors
      nodeSelector:
        workload: web
        disk: fast-ssd

      # Tolerations
      tolerations:
      - key: gpu
        operator: Equal
        value: "true"
        effect: NoSchedule

      # Init containers
      initContainers:
      - name: init-permissions
        image: busybox:1.35
        command: ['sh', '-c', 'chmod 777 /var/cache/nginx']
        volumeMounts:
        - name: cache
          mountPath: /var/cache/nginx

      # Contenedores
      containers:
      - name: nginx
        image: nginx:1.25
        imagePullPolicy: IfNotPresent

        # Ports
        ports:
        - name: http
          containerPort: 80
          protocol: TCP
        - name: metrics
          containerPort: 8080
          protocol: TCP

        # Environment variables
        env:
        - name: ENVIRONMENT
          value: "production"
        - name: LOG_LEVEL
          value: "info"

        # Env desde ConfigMap
        envFrom:
        - configMapRef:
            name: nginx-config

        # Env desde Secret
        - secretRef:
            name: nginx-secrets

        # Recursos
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi

        # Probes (ver sección de Health Checks)
        livenessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3

        readinessProbe:
          httpGet:
            path: /ready
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 2

        startupProbe:
          httpGet:
            path: /startup
            port: http
          failureThreshold: 30
          periodSeconds: 1

        # Security context del contenedor
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL

        # Volúmenes
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx/conf.d
          readOnly: true
        - name: cache
          mountPath: /var/cache/nginx
        - name: tmp
          mountPath: /var/run
        - name: logs
          mountPath: /var/log/nginx

      # Volúmenes
      volumes:
      - name: nginx-config
        configMap:
          name: nginx-conf
          defaultMode: 0644
      - name: cache
        emptyDir: {}
      - name: tmp
        emptyDir: {}
      - name: logs
        emptyDir:
          sizeLimit: 1Gi

      # Image pull secrets
      imagePullSecrets:
      - name: docker-secret

      # DNS config
      dnsPolicy: ClusterFirst

      # Termination grace period
      terminationGracePeriodSeconds: 30</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Actualizar Deployment</strong></p>
</div>
<div class="listingblock">
<div class="title">Via Rancher UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Workloads → Deployments
2. Seleccionar deployment: nginx-app
3. Click en menú (⋮) → Edit YAML
4. Modificar especificación
5. Save

O Edit Config:
1. Seleccionar deployment
2. Click "Edit"
3. Cambiar imagen, replicas, etc.
4. Save</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Via kubectl:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Actualizar imagen
kubectl set image deployment/nginx-app \
  nginx=nginx:1.26 \
  -n default \
  --record

# Ver rollout status
kubectl rollout status deployment/nginx-app -n default

# Ver historial de rollouts
kubectl rollout history deployment/nginx-app -n default

# Rollback
kubectl rollout undo deployment/nginx-app -n default

# Rollback a revisión específica
kubectl rollout undo deployment/nginx-app --to-revision=2 -n default

# Pausar rollout
kubectl rollout pause deployment/nginx-app -n default

# Reanudar rollout
kubectl rollout resume deployment/nginx-app -n default

# Escalar replicas
kubectl scale deployment/nginx-app --replicas=5 -n default</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>StatefulSets - Aplicaciones con estado</strong></p>
</div>
<div class="paragraph">
<p>StatefulSets son para aplicaciones que requieren:
- Identificadores únicos y estables
- Almacenamiento persistente
- Orden de deployment y escalado
- Acceso de red estable</p>
</div>
<div class="listingblock">
<div class="title">YAML StatefulSet (PostgreSQL):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres-cluster
  namespace: databases
spec:
  serviceName: postgres-svc  # Requerido para StatefulSets
  replicas: 3

  selector:
    matchLabels:
      app: postgres
      cluster: primary

  template:
    metadata:
      labels:
        app: postgres
        cluster: primary
    spec:
      securityContext:
        fsGroup: 999

      terminationGracePeriodSeconds: 60

      containers:
      - name: postgres
        image: postgres:15.5-bullseye

        ports:
        - name: postgresql
          containerPort: 5432
          protocol: TCP

        env:
        - name: POSTGRES_DB
          value: "app_db"

        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: password

        # Initial data setup
        - name: POSTGRES_INITDB_ARGS
          value: |
            --max_connections=200
            --shared_buffers=512MB
            --effective_cache_size=2GB

        resources:
          requests:
            cpu: 500m
            memory: 1Gi
          limits:
            cpu: 2000m
            memory: 4Gi

        livenessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - pg_isready -U postgres
          initialDelaySeconds: 30
          periodSeconds: 10
          failureThreshold: 3

        readinessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - pg_isready -U postgres
          initialDelaySeconds: 5
          periodSeconds: 5
          failureThreshold: 2

        # Volúmenes para cada réplica
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data
          subPath: postgres
        - name: config
          mountPath: /etc/postgresql
          readOnly: true

      # Volúmenes de configuración
      volumes:
      - name: config
        configMap:
          name: postgres-config

  # Volúmenes persistentes (uno por réplica)
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: "fast-ssd"
      resources:
        requests:
          storage: 100Gi

---
# Headless Service requerido para StatefulSet
apiVersion: v1
kind: Service
metadata:
  name: postgres-svc
  namespace: databases
spec:
  clusterIP: None  # Headless
  selector:
    app: postgres
  ports:
  - name: postgresql
    port: 5432
    targetPort: postgresql
  publishNotReadyAddresses: true  # Para init</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>DaemonSets - Ejecutar en cada nodo</strong></p>
</div>
<div class="paragraph">
<p>DaemonSets se usan para:
- Node monitoring (Prometheus, Datadog)
- Log collection (Fluentd, Filebeat)
- Network plugins (Calico, Flannel)
- Storage agents (Ceph, Longhorn)</p>
</div>
<div class="listingblock">
<div class="title">YAML DaemonSet (Node exporter):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: node-exporter
  namespace: monitoring
  labels:
    app: node-exporter
spec:
  selector:
    matchLabels:
      app: node-exporter

  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1

  template:
    metadata:
      labels:
        app: node-exporter
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9100"

    spec:
      hostNetwork: true
      hostPID: true
      hostIPC: true

      serviceAccountName: node-exporter

      # Ejecutar en todos los nodos (incluyendo master)
      tolerations:
      - effect: NoSchedule
        operator: Exists
      - effect: NoExecute
        operator: Exists

      containers:
      - name: node-exporter
        image: quay.io/prometheus/node-exporter:v1.7.0

        args:
        - --path.procfs=/host/proc
        - --path.sysfs=/host/sys
        - --path.rootfs=/rootfs
        - --collector.filesystem.mount-points-exclude=^/(sys|proc|dev|host|etc)($$|/)
        - --web.listen-address=:9100

        ports:
        - name: metrics
          containerPort: 9100
          hostPort: 9100

        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 200m
            memory: 256Mi

        securityContext:
          privileged: true

        volumeMounts:
        - name: proc
          mountPath: /host/proc
          readOnly: true
        - name: sys
          mountPath: /host/sys
          readOnly: true
        - name: rootfs
          mountPath: /rootfs
          readOnly: true

      volumes:
      - name: proc
        hostPath:
          path: /proc
      - name: sys
        hostPath:
          path: /sys
      - name: rootfs
        hostPath:
          path: /</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_de_services_e_ingress">Configuración de Services e Ingress</h4>
<div class="paragraph">
<p><strong>Services - Exponiendo aplicaciones</strong></p>
</div>
<div class="paragraph">
<p>Existen 4 tipos de Services:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 48. Tabla de tipos de Services:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Acceso</th>
<th class="tableblock halign-left valign-top">IP</th>
<th class="tableblock halign-left valign-top">Uso</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ClusterIP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Interno</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sí</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comunicación entre pods</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NodePort</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Externo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Nodo:Puerto</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Acceso externo simple</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LoadBalancer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Externo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LB IP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cloud providers, acceso externo escalable</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ExternalName</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Externo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CNAME</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Servicios externos</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">YAML Service (ClusterIP):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Service
metadata:
  name: nginx-svc
  namespace: default
  labels:
    app: nginx
  annotations:
    description: "Internal nginx service"
spec:
  type: ClusterIP

  # Puede ser None (headless) para StatefulSets
  clusterIP: 10.96.0.10

  selector:
    app: nginx
    tier: web

  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  - name: https
    port: 443
    targetPort: 8443
    protocol: TCP

  # Sticky sessions
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 10800

  # IP internas adicionales
  clusterIPs:
  - 10.96.0.10

  # Pub IP (si es needed)
  externalIPs:
  - 192.168.1.100

  # Protocolos IPv4/IPv6
  ipFamilyPolicy: SingleStack
  ipFamilies:
  - IPv4

  # Health check externo
  externalTrafficPolicy: Local
  healthCheckNodePort: 30000</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">YAML Service (NodePort):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Service
metadata:
  name: app-nodeport
  namespace: default
spec:
  type: NodePort

  selector:
    app: myapp

  ports:
  - name: http
    port: 80            # Puerto interno del cluster
    targetPort: 8080    # Puerto en el pod
    nodePort: 30080     # Puerto en el nodo (30000-32767)
    protocol: TCP</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">YAML Service (LoadBalancer):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Service
metadata:
  name: app-lb
  namespace: default
  annotations:
    # Para AWS
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "http"
spec:
  type: LoadBalancer

  selector:
    app: myapp

  ports:
  - name: http
    port: 80
    targetPort: 8080

  # Para retener IP del cliente
  externalTrafficPolicy: Local

  # Load balancer IP (si es soportado)
  loadBalancerIP: "10.0.0.100"

  # Restricción de acceso
  loadBalancerSourceRanges:
  - 10.0.0.0/8
  - 192.168.0.0/16</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Ingress - Enrutamiento HTTP(S)</strong></p>
</div>
<div class="listingblock">
<div class="title">YAML Ingress (NGINX Ingress Controller):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  namespace: default
  annotations:
    # NGINX annotations
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"

    # CORS
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-origin: "*"

    # Auth básico
    nginx.ingress.kubernetes.io/auth-type: "basic"
    nginx.ingress.kubernetes.io/auth-secret: "basic-auth"
    nginx.ingress.kubernetes.io/auth-realm: "Authentication Required"
spec:
  ingressClassName: nginx

  # TLS/SSL
  tls:
  - hosts:
    - app.example.com
    - api.example.com
    secretName: app-tls-cert  # Generado por cert-manager

  - hosts:
    - admin.example.com
    secretName: admin-tls-cert

  rules:
  # Host principal
  - host: app.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app-svc
            port:
              number: 80

      - path: /api
        pathType: Prefix
        backend:
          service:
            name: api-svc
            port:
              number: 8080

  # Subdomain api
  - host: api.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: api-svc
            port:
              number: 8080

      - path: /v2
        pathType: Prefix
        backend:
          service:
            name: api-v2-svc
            port:
              number: 8080

  # Admin panel
  - host: admin.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: admin-svc
            port:
              number: 3000

  # Wildcard
  - host: "*.apps.example.com"
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app-router-svc
            port:
              number: 8080

---
# Certificate para HTTPS (cert-manager)
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: app-tls-cert
  namespace: default
spec:
  secretName: app-tls-cert
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  dnsNames:
  - app.example.com
  - api.example.com

---
# ClusterIssuer para Let's Encrypt
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: admin@example.com
    privateKeySecretRef:
      name: letsencrypt-prod
    solvers:
    - http01:
        ingress:
          class: nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Gestionar Services e Ingress via Rancher UI</strong></p>
</div>
<div class="listingblock">
<div class="title">Crear Service:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Services → Services (ClusterIP)
2. Create

Configurar:
- Name: nginx-svc
- Namespace: default
- Ports:
  * Port: 80
  * Target Port: 8080
  * Protocol: TCP

- Selectors:
  * app: nginx
  * tier: web

3. Create</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Crear Ingress:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Services → Ingress
2. Create

Configurar:
- Name: app-ingress
- Namespace: default
- Ingress Class: nginx
- Rules:
  * Host: app.example.com
  * Path: /
  * Path Type: Prefix
  * Target Service: app-svc
  * Port: 80

- SSL/TLS:
  * Create Certificate
  * Domain: app.example.com
  * Issuer: letsencrypt-prod

3. Create</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_configmaps_y_secrets">Gestión de ConfigMaps y Secrets</h4>
<div class="paragraph">
<p><strong>ConfigMaps - Datos de configuración no sensibles</strong></p>
</div>
<div class="paragraph">
<p>ConfigMaps almacenan datos de configuración en pares clave-valor.</p>
</div>
<div class="listingblock">
<div class="title">YAML ConfigMap (aplicación web):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: default
  labels:
    app: myapp
data:
  # Valores simples
  environment: production
  log_level: info
  max_connections: "200"

  # Ficheros
  app.conf: |
    server {
      listen 8080;
      server_name app.example.com;

      location / {
        proxy_pass http://backend:8000;
        proxy_set_header X-Real-IP $remote_addr;
      }
    }

  database.properties: |
    db.host=postgres
    db.port=5432
    db.pool.size=20
    db.timeout=30000

  settings.json: |
    {
      "api": {
        "endpoint": "https://api.example.com",
        "timeout": 30000,
        "retries": 3
      },
      "features": {
        "cache": true,
        "cdn": true
      }
    }

---
# Uso en Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
spec:
  template:
    spec:
      containers:
      - name: app
        image: myapp:1.0

        # Opción 1: Montar como volumen
        volumeMounts:
        - name: config
          mountPath: /etc/config
          readOnly: true

      volumes:
      - name: config
        configMap:
          name: app-config
          defaultMode: 0644
          items:
          - key: app.conf
            path: nginx.conf
          - key: database.properties
            path: db.properties

---
# O inyectar como variables de entorno
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
spec:
  template:
    spec:
      containers:
      - name: app
        image: myapp:1.0

        # Opción 2: Como env vars
        envFrom:
        - configMapRef:
            name: app-config

        # O selectivamente
        env:
        - name: LOG_LEVEL
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: log_level

        - name: ENVIRONMENT
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: environment</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Secrets - Datos sensibles</strong></p>
</div>
<div class="paragraph">
<p>Secrets almacenan información sensible (contraseñas, tokens, certificados).</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 49. Tipos de Secrets:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Tipo</th>
<th class="tableblock halign-left valign-top">Clave</th>
<th class="tableblock halign-left valign-top">Contenido</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Opaque</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">string</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Datos arbitrarios (default)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/service-account-token</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">token, ca.crt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Service account token</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/dockercfg</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">.dockercfg</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Credenciales Docker (deprecated)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/dockerconfigjson</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">.dockerconfigjson</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Credenciales Docker JSON</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/basic-auth</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">username, password</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Basic HTTP authentication</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/ssh-auth</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ssh-privatekey</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SSH authentication</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/tls</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">tls.crt, tls.key</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Certificados TLS</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">bootstrap.kubernetes.io/token</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">token-id, token-secret</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bootstrap token</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">YAML Secret (aplicación):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: default
type: Opaque
stringData:
  # Datos en texto plano (convertido a base64)
  database_password: "SuperSecurePassword123!"
  api_key: "sk-1234567890abcdef"
  jwt_secret: "your-jwt-secret-key-here"

---
# Secret de Docker (pull images)
apiVersion: v1
kind: Secret
metadata:
  name: docker-registry
  namespace: default
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: eyJhdXRocyI6eyJyZWdpc3RyeS5leGFtcGxlLmNvbSI6eyJ1c2VybmFtZSI6Im15dXNlciIsInBhc3N3b3JkIjoibXlwYXNzd29yZCIsImF1dGgiOiJibVY1Ymk1bGVHRnRjR3hsTG1SdmJRPT0ifX19

---
# Secret TLS
apiVersion: v1
kind: Secret
metadata:
  name: app-tls
  namespace: default
type: kubernetes.io/tls
data:
  tls.crt: |
    LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUN1akNDQWFvQ0NRQ3lZRzBVWklCRURUQU5CZ2txaGtpRzl3MEJBUXNGQURBdU1Rc3dDUVlEVlFRR0V3SkRCVEVOTUFzR0ExVUVDaE1FVW1GdVkyaHZNQ0FYRFRFNU1EWXpPVEV5TXpRME9Wb1hEVEV4TURZek9URXlNelEwT1Zvd0x6RUxNQWtHQTFVRUJoTUNRMFV4RHpBTkJnTlZCQWNUQm1GdFkyaHBiakNDQVNJd0RRWUpLb1pJaHZjTkFRRUZCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFLQzFTZFhwbjFrSHJDMU5TNWhKYjBiaFJlYzBZRjhpQ25reEd6a3dISEJTVWxGQ1pXNWpiR0ZzYkdWeVEzQjVRV2RCT1UxWWFuSkpha0Y1VGs1UmFGRnNRbEZqTW1SbVYyMDFUMFYzUkhSaGJucFRWRmMyTkU0NVNreE5SMk13V1cxT2Fsa3lSbmxrVjBFNVZsRlpNMHhEU205SE9XRkZhMjl5UjJkaGJHRlRkV2N4V1MweGEzUnVZMEZUYTBKb1VXdDNSRlJZU1hSV2JraDNXVEI0YjBSVFlVMUZlbU5zYkZSWFlqRlJlVGd3V1cxR2FGUnNVbkJrU0VFOVBRMENnZ0VCQUw2dElQSkY2dWdHRDVhZGd4VWFteFJaMUoxY25ORwp8IGRvdHMgZm9yIGJyZXZpdHkgfApjSFJ2T21GdGMyaHZjMlV1YjNKbk9rbHVSMlY1SWl3aVpHVm1ZWFZzZENJNkluSnZiM1E2T1RZMElpd2lSV1poYkhWbElqb2lRbXhoZG1WeUlpd2lSbU56VW1WeWNtOXlJams1TlN3aWRISjFjbk51YzJOaGJHaHZjMlVpT2pCOVhYMD0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=
  tls.key: |
    LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUVwQUlCQUtDQVFFQW9yVkoyZW1mV1Flc0xVMVRtRWx2UkdGRjV6UmdYeElLZVRFYk9UQWNjRkpTVVVKbGIKbU5zWVd4c1ZYSkRjSGxCWjBFNVRWaHFlbWwwVGs1UmFGRnNRbEZqTW1SbVYyMDFUMFYzUkhSaGJucFRWRmMyTgpFNDVTa3hOUjJNd1cxME9hbGt5Um5sa1YwRTVWbEZaTTB4RFNtOUhPV0ZGYTI5eVIyZGhiR0ZUZFdjeFlTMHgKYTNSdVkwRlRhMEpvVVd0M1JGUllTWFJXYmtOM1dUQjRiMFJUWVUxRmVtTnNiRlJYWWpGUmVUZ3dXVzFHYUZScwpVbkJrU0VFOVBRSURBUUFCQW9JQkFRQ2luUUpjUlNBU1BYNHVkWGcyVWlKMUdkdGpSNnczUDBNMVdSMm1SZGcyCnN4MlYzZ3pMc2x3dWFkeFN0L1pUZFJydHhXL2dhdkRYUGg1UUZ0R1AzYTZacEdHWWtrbmdlRUhSMWwrQnNJMHgKb0hhWC91RVJlWjUrdFRGYVBXRmhhQU5BVkF3Z0w1b3BFOFRYL202dWN1clhTanBmZkZzQjBXRWZkR0F3MzBDMQphQW1wdkZWRW5EWGdVQ1FxTWZsSjFKVmZpelhjbGQ2S0JsNFpkTDh2OEJQb2VjUXRHZVpDVi91UlR6eEsyUlhYCmRNQ0wxTFNLdWlIQjdlWlAweUppdGZvL2k2QzJmVkV4aFpEVWlCdVJOQ1djSEc1QkR2YUhCeUFnT1lzSkRqUlkKTkdoalJRSkJBb0dCQUw2QWlRRDBIVEJkMWhlcFVRczBCaWFaZ1VyOStSZE5aMjh4bS9QaUtMeFJ6NVFQZ29jNgpHM3VSdzBtYzhOSXFzV28wRmF6eHNxRmphNHFJQWJUWGdXN1MrVkVtMVJJVWd5Vnd3TkZmdDJpQm9PMVRjUGc0CjBmRTFxUmhrbzA3TlJXNU9iSURJdkRJZFZMWFJ3SlMyV3gwZUtpcjAwdGQwSFZZQjBxRCtvWzh1K0FvR0JBTnEKMFB4Q0VVRUowc090dmhNb2xwKzN6VjhWdGtWUzBqTHdoT0YvVkswTU9BQUZuNGxvQTdxOXpscmFqRUpCNVN0eApGVnpqUHYzQjJUdUdXVHgyWjJNcGNTRHYyVkJmVkFKQm5oOGFqMC9YOTJFak14N1dKMVN2WEVnTTlwSmJrN1UKeTBhWm93d3FaK0I2T2d3dW55c0ZQb0o3NEZGVlBWbGttRVczQVBIOENnWUVBaTJJanpPVTAxb1gxbjdjQkl2CnRPYjIvdTJSaTZkcW9xOFFkRzFGYmpFVStPaHBpdGl5TFlqdFJ6b2lkcFJRK2dIM3QreFdNMjBaTDk5bnBwRWkKVzI3RHBIOGQzRFh1V0lKQ0o1UlJQKzkzN09sWFhoMFhzTWMyMVhyYUhPMzBNMmo1YlhSU2YyZ2JPVEcyTzBSdQphaEJWTm80ZENxRWJaVzlGNmhTcUozOFAva3N1Q2dZQm5RVTVFT29uQ3RqSHBFRFM1Z3ZHdC9PeHl3KzJmckp5CmVhbHU2MmdKRWUxMU91WDVmOXFxak92VmxMM3ZrMjRSUkQxVkN2dWgycFlMMjlXSGVaMDB1aEFFak9aaVJUNloKMVJpUE00TEJSakdYQVdGTEFhMVppKzh1dWN6ZER5cHhSdmdUSFRXak5nV2k5UUZ6cUpqUVZsb3NKSm16dUVnTQpmMkhQZmdiMXJ0UVFKQmdEZHVNNkZXamMvMjVnWnBiZTR4WnBwRWN0K3RCWjZuTnBNa1RkSXpzaVpMODJjMkJJCnpEMGVZNUJsdWJ0WEg2MnlLRkZrQkQycEVVQWYxQzVUakkyTjFoS3dzOStTVnB4U2lKTW5scjhTN1ljNVNGa0EKRzJQS3VyajdYdGJvbW0vb01VTTJKb08rbEt5dWc0WkFDeFRxdXRNdkxSajVZUjBaQW1kNTBJQjFrQW89Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K

---
# Uso en Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app
spec:
  template:
    spec:
      containers:
      - name: app
        image: myapp:1.0

        env:
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database_password

        - name: API_KEY
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: api_key

      # Para pull de imágenes privadas
      imagePullSecrets:
      - name: docker-registry</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Gestionar ConfigMaps y Secrets via Rancher UI</strong></p>
</div>
<div class="listingblock">
<div class="title">Crear ConfigMap:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Config → ConfigMaps
2. Create
3. Configurar:
   - Name: app-config
   - Namespace: default
   - Data:
     * Key: environment
       Value: production
     * Key: log_level
       Value: info

4. Create</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Crear Secret:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Config → Secrets
2. Create
3. Configurar:
   - Name: app-secrets
   - Namespace: default
   - Type: Opaque
   - Data:
     * Key: database_password
       Value: SecurePassword123
     * Key: api_key
       Value: sk-1234567890

4. Create</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Mejores prácticas para Secrets</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Usar Secret Management externo:
   - Hashicorp Vault
   - AWS Secrets Manager
   - Azure Key Vault
   - Google Secret Manager

2. Encriptación:
   - Encriptar secrets en etcd
   - RBAC para limitar acceso
   - Audit logs para cambios

3. Rotación:
   - Rotar secrets regularmente
   - Automatizar con operadores
   - Sin downtime

4. No commitear secrets:
   - .gitignore para secrets
   - Usar sealed-secrets o external-secrets
   - Renovación frecuente</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_health_checks_y_probes">Health checks y probes</h4>
<div class="paragraph">
<p><strong>Tipos de probes</strong></p>
</div>
<div class="paragraph">
<p>Kubernetes proporciona 3 tipos de health checks:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 50. Tabla de probes:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 20%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Probe</th>
<th class="tableblock halign-left valign-top">Propósito</th>
<th class="tableblock halign-left valign-top">Acción</th>
<th class="tableblock halign-left valign-top">Timing</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Liveness</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">¿El contenedor está vivo?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reiniciar si fallan N veces</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Periódicamente durante toda la vida</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Readiness</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">¿Puede recibir tráfico?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Remover de endpoints si fallan</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Periódicamente durante toda la vida</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Startup</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">¿La app está iniciando?</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Falla si no inicia en tiempo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Solo al inicio</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Liveness Probe - Detectar contenedores muertos</strong></p>
</div>
<div class="paragraph">
<p>Reinicia un contenedor que está colgado pero sigue ejecutando.</p>
</div>
<div class="listingblock">
<div class="title">YAML con Liveness Probe:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: app-pod
spec:
  containers:
  - name: app
    image: myapp:1.0

    # Opción 1: HTTP GET
    livenessProbe:
      httpGet:
        path: /health
        port: 8080
        httpHeaders:
        - name: X-Custom-Header
          value: Awesome

      initialDelaySeconds: 30  # Esperar 30s antes de empezar
      periodSeconds: 10        # Cada 10s
      timeoutSeconds: 5        # Timeout de respuesta
      successThreshold: 1      # 1 éxito = OK
      failureThreshold: 3      # 3 fallos = fallo del probe

---
# Opción 2: TCP Socket check
apiVersion: v1
kind: Pod
metadata:
  name: db-pod
spec:
  containers:
  - name: postgres
    image: postgres:15

    livenessProbe:
      tcpSocket:
        port: 5432
      initialDelaySeconds: 15
      periodSeconds: 20

---
# Opción 3: Exec (comando)
apiVersion: v1
kind: Pod
metadata:
  name: redis-pod
spec:
  containers:
  - name: redis
    image: redis:7

    livenessProbe:
      exec:
        command:
        - redis-cli
        - ping
      initialDelaySeconds: 5
      periodSeconds: 5</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Readiness Probe - Preparado para tráfico</strong></p>
</div>
<div class="paragraph">
<p>Permite que el pod reciba tráfico solo cuando está completamente listo.</p>
</div>
<div class="listingblock">
<div class="title">YAML con Readiness Probe:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
spec:
  template:
    spec:
      containers:
      - name: app
        image: nginx:1.25

        # Readiness: ¿Puedo recibir tráfico?
        readinessProbe:
          httpGet:
            path: /ready
            port: 80
          initialDelaySeconds: 5    # Más rápido que liveness
          periodSeconds: 5
          timeoutSeconds: 3
          successThreshold: 1
          failureThreshold: 2       # Menos fallos permitidos

        # Liveness: ¿Estoy vivo?
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Startup Probe - Esperar a que inicie</strong></p>
</div>
<div class="paragraph">
<p>Para aplicaciones que tardan mucho en iniciar.</p>
</div>
<div class="listingblock">
<div class="title">YAML con Startup Probe:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: slow-startup-app
spec:
  containers:
  - name: app
    image: myapp:slowstart

    # Startup: ¿Ya está iniciado? (timeout corto, muchos intentos)
    startupProbe:
      httpGet:
        path: /startup
        port: 8080
      failureThreshold: 30      # 30 intentos
      periodSeconds: 1          # Cada 1 segundo
      # Total: 30 segundos máximo para iniciar

    # Readiness: ¿Puedo recibir tráfico? (solo si startup pasó)
    readinessProbe:
      httpGet:
        path: /ready
        port: 8080
      initialDelaySeconds: 0    # Sin delay (startup ya pasó)
      periodSeconds: 5
      failureThreshold: 2

    # Liveness: ¿Estoy vivo? (solo si startup pasó)
    livenessProbe:
      httpGet:
        path: /health
        port: 8080
      initialDelaySeconds: 0
      periodSeconds: 10
      failureThreshold: 3</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Probes avanzados</strong></p>
</div>
<div class="listingblock">
<div class="title">YAML con configuración avanzada:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: advanced-app
spec:
  template:
    spec:
      containers:
      - name: app
        image: myapp:1.0

        # Health check con headers personalizados
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8080
            scheme: HTTPS  # Para HTTPS
            httpHeaders:
            - name: X-Health-Check
              value: "true"
            - name: Authorization
              value: "Bearer token123"

          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3

        # Readiness con múltiples chequeos
        readinessProbe:
          exec:
            command:
            - /bin/sh
            - -c
            - |
              curl -f http://localhost:8080/ready || exit 1
              # Y verificar dependencias
              [ -f /tmp/dependencies-ready ] || exit 1

          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 2

        # Lifecycle hooks (ejecución de comandos)
        lifecycle:
          # Pre-stop: Prepararse antes de terminar
          preStop:
            exec:
              command: ["/bin/sh", "-c", "sleep 15"]

          # Post-start: Ejecutar después de iniciar
          postStart:
            exec:
              command:
              - /bin/sh
              - -c
              - |
                # Esperar a que la app esté lista
                until curl -f http://localhost:8080/health; do
                  sleep 1
                done
                echo "App started successfully"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Monitoreo de probes en Rancher</strong></p>
</div>
<div class="listingblock">
<div class="title">Ver estado de probes via Rancher UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Workloads → Deployments
2. Seleccionar deployment
3. Ver sección "Pod Status":
   - Pod name: app-7d4f5d7d8d-abc12
   - Status: Running
   - Ready: 1/1

4. Click en pod para ver detalles:
   - Conditions:
     * Initialized: True
     * Ready: True
     * ContainersReady: True
     * PodScheduled: True

   - Container Status:
     * ready: true
     * restartCount: 0
     * state: Running

5. Ver eventos:
   - Click en pod → Events tab
   - Ver cambios de estado
   - Detectar problemas de probes</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Debugging de probes con kubectl:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver condiciones del pod
kubectl describe pod &lt;pod-name&gt; -n &lt;namespace&gt;
# Buscar:
# - Conditions
# - Events (últimos cambios)
# - Probe failure messages

# Ver logs del contenedor
kubectl logs &lt;pod-name&gt; -n &lt;namespace&gt;

# Ver logs anteriores (si crashed)
kubectl logs &lt;pod-name&gt; -n &lt;namespace&gt; --previous

# Ejecutar comandos en el contenedor
kubectl exec -it &lt;pod-name&gt; -n &lt;namespace&gt; -- /bin/sh

# Dentro del contenedor, probar probes manualmente:
curl http://localhost:8080/health
curl http://localhost:8080/ready

# Ver cambios en tiempo real
kubectl get pod &lt;pod-name&gt; -n &lt;namespace&gt; -w

# Ver métricas
kubectl top pod &lt;pod-name&gt; -n &lt;namespace&gt;
kubectl top node</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Best practices para probes</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Startup Probe:
   - Usar para apps con inicio lento
   - failureThreshold: 30 (típico)
   - periodSeconds: 1
   - Combinar con readiness/liveness

2. Readiness Probe:
   - Verificar si está listo para servir
   - Más sensible que liveness
   - Usar HTTP 200 como success
   - Timeout corto (3-5s)

3. Liveness Probe:
   - Detectar deadlocks o infinitos loops
   - Menos sensible que readiness
   - initialDelaySeconds &gt;= 30 para apps lentas
   - failureThreshold: 3

4. Endpoints de salud:
   - /health: Basic liveness
   - /ready: Readiness check
   - /live: Detailed liveness status
   - Retornar datos mínimos

5. Evitar:
   - No usar probes muy agresivos
   - No dejarlos sin timeout
   - No ignorar failureThreshold
   - No conectar a bases de datos en readiness</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_5_3_almacenamiento_y_networking">5.3 Almacenamiento y networking</h3>
<div class="paragraph">
<p>Rancher proporciona herramientas avanzadas para gestionar almacenamiento persistente y configurar networking en Kubernetes.</p>
</div>
<div class="sect3">
<h4 id="_configuración_de_storage_classes">Configuración de Storage Classes</h4>
<div class="paragraph">
<p>StorageClasses automatizan el aprovisionamiento de volúmenes persistentes basado en requerimientos de aplicación.</p>
</div>
<div class="paragraph">
<p><strong>Concepto de StorageClass</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 51. Tabla de StorageClasses comunes:</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 33.3335%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Nombre</th>
<th class="tableblock halign-left valign-top">Provisioner</th>
<th class="tableblock halign-left valign-top">Características</th>
<th class="tableblock halign-left valign-top">Uso</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fast-ssd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ebs.csi.aws.com</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SSD GP3, IOPS hasta 16,000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bases de datos, aplicaciones críticas</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">standard</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/aws-ebs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EBS GP2, IOPS 3,000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Almacenamiento general</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">local</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">kubernetes.io/local</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local node storage (no replicado)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Caches, datos temporales</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">longhorn</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">longhorn-system</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Distributed storage Kubernetes-native</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Backup, replicación, snapshots</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cephfs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ceph.csi.ceph.io</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ceph distributed storage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enterprise storage</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Crear StorageClass</strong></p>
</div>
<div class="listingblock">
<div class="title">YAML StorageClass (AWS EBS):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: fast-ssd
provisioner: ebs.csi.aws.com
reclaimPolicy: Delete          # Delete | Retain | Recycle
allowVolumeExpansion: true     # Permitir expansión después de creación
volumeBindingMode: WaitForFirstConsumer  # WaitForFirstConsumer | Immediate

parameters:
  type: gp3
  iops: "3000"
  throughput: "125"
  encrypted: "true"
  kms_key_id: "arn:aws:kms:us-east-1:123456789012:key/abc123"

---
# StorageClass estándar
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: standard
provisioner: kubernetes.io/aws-ebs
reclaimPolicy: Delete
allowVolumeExpansion: true
volumeBindingMode: Immediate

parameters:
  type: gp2
  iops: "1000"
  encrypted: "false"

---
# StorageClass local (high-performance)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-nvme
provisioner: kubernetes.io/local
reclaimPolicy: Delete
allowVolumeExpansion: false
volumeBindingMode: WaitForFirstConsumer

---
# StorageClass Longhorn (replicado)
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: longhorn-replicated
provisioner: driver.longhorn.io
reclaimPolicy: Delete
allowVolumeExpansion: true

parameters:
  numberOfReplicas: "3"
  staleReplicaTimeout: "2880"  # 48 horas
  fromBackup: ""
  fstype: "ext4"
  migratable: "false"
  repeatedFailureTTL: "604800"  # 7 días</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Via Rancher UI</strong></p>
</div>
<div class="listingblock">
<div class="title">Crear StorageClass:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Storage → Storage Classes
2. Create
3. Configurar:
   - Name: fast-ssd
   - Provisioner: ebs.csi.aws.com
   - Reclaim Policy: Delete
   - Allow Volume Expansion: Checked
   - Volume Binding Mode: WaitForFirstConsumer

4. Parameters:
   - type: gp3
   - iops: 3000
   - throughput: 125
   - encrypted: true

5. Create</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_persistent_volumes">Gestión de Persistent Volumes</h4>
<div class="paragraph">
<p><strong>Persistent Volumes vs Persistent Volume Claims</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>PersistentVolume (PV)</strong>: Recurso de storage en el cluster</p>
</li>
<li>
<p><strong>PersistentVolumeClaim (PVC)</strong>: Solicitud de storage por una aplicación</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Flujo de aprovisionamiento:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-plantuml hljs" data-lang="plantuml">@startuml
!define RECTANGLE rectangle

skinparam backgroundColor transparent

actor Pod
participant "PVC" as PVC
database "StorageClass" as SC
participant "Provisioner" as Prov
database "PV" as PV
database "Physical Storage\n(AWS EBS, etc)" as Storage

Pod -&gt; PVC: Request 100Gi
PVC -&gt; SC: Match StorageClass
SC -&gt; Prov: Create volume
Prov -&gt; Storage: Provision 100Gi volume
Storage --&gt; Prov: Volume created
Prov -&gt; PV: Create PV
PV -&gt; PVC: Bind PV to PVC
PVC --&gt; Pod: Volume ready
Pod -&gt; Storage: Mount volume

note right of SC
  StorageClass defines
  - Provisioner
  - Parameters
  - Reclaim policy
end note

@enduml</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Crear Persistent Volume Claim</strong></p>
</div>
<div class="listingblock">
<div class="title">YAML PersistentVolumeClaim:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-data
  namespace: databases
spec:
  accessModes:
    - ReadWriteOnce  # Solo un nodo puede leer/escribir
  storageClassName: fast-ssd
  resources:
    requests:
      storage: 100Gi

---
# Expandible
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: app-logs
  namespace: applications
spec:
  accessModes:
    - ReadWriteMany  # Múltiples nodos pueden leer/escribir
  storageClassName: longhorn-replicated
  resources:
    requests:
      storage: 50Gi

---
# Acceso de solo lectura
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: shared-data
  namespace: applications
spec:
  accessModes:
    - ReadOnlyMany  # Múltiples nodos solo lectura
  storageClassName: standard
  resources:
    requests:
      storage: 200Gi

---
# Usar PVC en Deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  namespace: databases
spec:
  template:
    spec:
      containers:
      - name: postgres
        image: postgres:15
        volumeMounts:
        - name: data
          mountPath: /var/lib/postgresql/data

      volumes:
      - name: data
        persistentVolumeClaim:
          claimName: postgres-data

---
# Expandir PVC (si allowVolumeExpansion: true)
# Editar el PVC y cambiar storage
# kubectl patch pvc postgres-data -p '{"spec":{"resources":{"requests":{"storage":"200Gi"}}}}'</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Monitoreo de PVCs</strong></p>
</div>
<div class="listingblock">
<div class="title">Via Rancher UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Storage → Persistent Volumes
2. Ver lista de PVCs:
   - Name
   - Namespace
   - Status (Bound | Pending | Lost)
   - Capacity
   - Access Modes
   - StorageClass
   - Age

3. Click en PVC para ver detalles:
   - Bound to: Qué PV está usando
   - Used: Espacio utilizado (aproximado)
   - Events: Cambios recientes

4. Acciones:
   - Delete PVC (libera espacio)
   - Edit YAML</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Monitoreo con kubectl:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver PVCs
kubectl get pvc -A

# Ver PVs
kubectl get pv

# Describe PVC (detalles completos)
kubectl describe pvc postgres-data -n databases

# Ver uso actual de espacio (si está soportado)
kubectl exec &lt;pod-name&gt; -n databases -- df -h

# Ver PVs y PVCs asociados
kubectl get pv,pvc -n databases

# Expandir PVC
kubectl patch pvc postgres-data -p '{"spec":{"resources":{"requests":{"storage":"200Gi"}}}}'

# Ver eventos de PVC
kubectl get events -n databases --field-selector involvedObject.name=postgres-data</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Backup de volúmenes (Longhorn)</strong></p>
</div>
<div class="paragraph">
<p>Si usa Longhorn StorageClass, puede hacer backups de volúmenes.</p>
</div>
<div class="listingblock">
<div class="title">YAML para backup de Longhorn:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: longhorn.io/v1beta1
kind: Backup
metadata:
  name: postgres-backup-001
  namespace: longhorn-system
spec:
  backupTarget: s3://backups.example.com/longhorn/
  snapshotName: postgres-data-snapshot
  volumeName: postgres-data
  storageClassName: longhorn-replicated

---
# Restore desde backup
apiVersion: longhorn.io/v1beta1
kind: Restore
metadata:
  name: postgres-restore-001
  namespace: longhorn-system
spec:
  backupURL: s3://backups.example.com/longhorn/postgres-data-snapshot
  backupTarget: s3://backups.example.com/longhorn/
  volumeName: postgres-data-restored
  storageClassName: longhorn-replicated</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_de_networking_avanzada">Configuración de networking avanzada</h4>
<div class="paragraph">
<p><strong>Network Policies - Restricción de tráfico</strong></p>
</div>
<div class="paragraph">
<p>Network Policies controlan el tráfico ingress/egress entre pods.</p>
</div>
<div class="listingblock">
<div class="title">YAML NetworkPolicy (deny-all + allow específicos):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Denegar todo tráfico
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: production
spec:
  podSelector: {}  # Aplica a todos los pods
  policyTypes:
  - Ingress
  - Egress

---
# Permitir DNS (requerido para que funcione cualquier cosa)
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-dns
  namespace: production
spec:
  podSelector: {}
  policyTypes:
  - Egress
  egress:
  - to:
    - namespaceSelector: {}
    ports:
    - protocol: UDP
      port: 53

---
# Permitir tráfico frontend -&gt; backend
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: frontend
    ports:
    - protocol: TCP
      port: 8080

---
# Permitir ingress externo -&gt; frontend
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-ingress-to-frontend
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: frontend
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 80
    - protocol: TCP
      port: 443

---
# Backend -&gt; Base de datos
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-backend-to-db
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: postgres
  policyTypes:
  - Ingress
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: backend
    ports:
    - protocol: TCP
      port: 5432

---
# Permitir egress a APIs externas
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-external-apis
  namespace: production
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
  - Egress
  egress:
  # DNS
  - to:
    - namespaceSelector: {}
    ports:
    - protocol: UDP
      port: 53

  # HTTPS to external APIs
  - to:
    - ipBlock:
        cidr: 0.0.0.0/0
        except:
        - 169.254.169.254/32  # AWS metadata (bloquear)
        - 10.0.0.0/8          # Internal (bloquear)
    ports:
    - protocol: TCP
      port: 443

  # Allow to database (internal)
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Service Mesh con Istio - Observabilidad de networking</strong></p>
</div>
<div class="paragraph">
<p>Service Mesh proporciona control granular del tráfico, observabilidad y seguridad.</p>
</div>
<div class="listingblock">
<div class="title">Instalar Istio (via Rancher):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># 1. Instalar desde Rancher UI
# Cluster → Apps → Charts
# Buscar "Istio"
# Configurar:
# - Enable monitoring
# - Tracing (Jaeger)
# - Observability

# O via Helm
helm repo add istio https://istio-release.storage.googleapis.com/charts
helm install istio-base istio/base \
  --namespace istio-system --create-namespace
helm install istiod istio/istiod \
  --namespace istio-system

# Verificar instalación
kubectl get ns -L istio-injection
kubectl get pods -n istio-system</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Habilitar Istio en namespace:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    istio-injection: enabled  # Inyectar Envoy sidecars automáticamente</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">YAML Istio VirtualService (enrutamiento avanzado):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: app-routes
  namespace: production
spec:
  hosts:
  - app.example.com
  - app-internal

  http:
  # Enrutar por header
  - match:
    - headers:
        user-type:
          exact: admin
    route:
    - destination:
        host: backend
        port:
          number: 8080
      weight: 100
    timeout: 10s
    retries:
      attempts: 3
      perTryTimeout: 2s

  # Canary deployment (90% stable, 10% new version)
  - match:
    - uri:
        prefix: /api
    route:
    - destination:
        host: backend
        subset: v1
      weight: 90
    - destination:
        host: backend
        subset: v2
      weight: 10
    timeout: 5s

  # Default route
  - route:
    - destination:
        host: backend
        port:
          number: 8080
      weight: 100

---
# Destination Rule (definir subsets)
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: backend-dr
  namespace: production
spec:
  host: backend
  trafficPolicy:
    connectionPool:
      http:
        http1MaxPendingRequests: 100
        http2MaxRequests: 1000
        maxRequestsPerConnection: 2
    outlierDetection:
      consecutive5xxErrors: 5
      interval: 30s
      baseEjectionTime: 30s
      maxEjectionPercent: 50
      minEjectionDuration: 30s

  subsets:
  - name: v1
    labels:
      version: v1
  - name: v2
    labels:
      version: v2

---
# Observabilidad: ServiceEntry (servicios externos)
apiVersion: networking.istio.io/v1beta1
kind: ServiceEntry
metadata:
  name: external-api
  namespace: production
spec:
  hosts:
  - api.example.com
  ports:
  - number: 443
    name: https
    protocol: HTTPS
  location: MESH_EXTERNAL
  resolution: DNS

---
# PeerAuthentication (mTLS - mutual TLS)
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: production
spec:
  mtls:
    mode: STRICT  # Requerir mTLS entre todos los pods

---
# AuthorizationPolicy (control de acceso)
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: backend-policy
  namespace: production
spec:
  selector:
    matchLabels:
      app: backend

  rules:
  # Permitir frontend -&gt; backend
  - from:
    - source:
        principals: ["cluster.local/ns/production/sa/frontend"]
    to:
    - operation:
        methods: ["GET", "POST"]
        paths: ["/api/*"]

  # Permitir Prometheus -&gt; metrics
  - from:
    - source:
        principals: ["cluster.local/ns/monitoring/sa/prometheus"]
    to:
    - operation:
        methods: ["GET"]
        paths: ["/metrics"]</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Observabilidad de Istio</strong></p>
</div>
<div class="paragraph">
<p>Istio proporciona observabilidad completa del tráfico entre servicios.</p>
</div>
<div class="listingblock">
<div class="title">Herramientas de observabilidad:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Kiali (visualización de service mesh):
   - Grafo de servicios en tiempo real
   - Métricas de tráfico
   - Rastreo de errores
   - Validación de configuración

   URL: http://kiali.example.com
   Usuarios/Passwords: admin/admin (por defecto)

2. Jaeger (distributed tracing):
   - Rastreo de requestsa través de servicios
   - Latencia entre servicios
   - Análisis de errores

   URL: http://jaeger.example.com

3. Prometheus + Grafana:
   - Métricas de Istio
   - Dashboards personalizados
   - Alertas

4. Grafana Dashboards:
   - Istio Service Dashboard
   - Istio Workload Dashboard
   - Mesh Dashboard</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Verificar instalación de observabilidad:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Verificar servicios de observabilidad
kubectl get svc -n istio-system | grep -E 'kiali|jaeger|prometheus|grafana'

# Port-forward a Kiali
kubectl port-forward -n istio-system svc/kiali 20000:20000
# Acceder: http://localhost:20000

# Port-forward a Jaeger
kubectl port-forward -n istio-system svc/jaeger 16686:16686
# Acceder: http://localhost:16686

# Port-forward a Grafana
kubectl port-forward -n istio-system svc/grafana 3000:3000
# Acceder: http://localhost:3000

# Ver logs de Envoy (sidecar de Istio)
kubectl logs -n production &lt;pod-name&gt; -c istio-proxy

# Ejecutar debug en Envoy proxy
kubectl exec -it -n production &lt;pod-name&gt; -c istio-proxy -- \
  /usr/local/bin/envoy -c /etc/istio/proxy/envoy-rev0.json --drain-time-s 5</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_avanzada_de_networking">Configuración avanzada de networking</h4>
<div class="paragraph">
<p><strong>DNS y service discovery</strong></p>
</div>
<div class="listingblock">
<div class="title">Configuración de resolución de nombres:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Coredns ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: coredns
  namespace: kube-system
data:
  Corefile: |
    .:53 {
        errors
        health {
           lameduck 5s
        }
        ready
        kubernetes cluster.local in-addr.arpa ip6.arpa {
           pods insecure
           fallthrough in-addr.arpa ip6.arpa
        }
        prometheus :9153
        forward . /etc/resolv.conf
        cache 30
        loop
        reload
        loadbalance
    }

---
# ExternalDNS (sincronizar con cloud DNS)
apiVersion: v1
kind: ServiceAccount
metadata:
  name: external-dns
  namespace: kube-system

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: external-dns
rules:
- apiGroups: [""]
  resources: ["services","endpoints","pods"]
  verbs: ["get","watch","list"]
- apiGroups: ["extensions","networking.k8s.io"]
  resources: ["ingresses"]
  verbs: ["get","watch","list"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: external-dns-viewer
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: external-dns
subjects:
- kind: ServiceAccount
  name: external-dns
  namespace: kube-system

---
# Deployment de External DNS
apiVersion: apps/v1
kind: Deployment
metadata:
  name: external-dns
  namespace: kube-system
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: external-dns
  template:
    metadata:
      labels:
        app: external-dns
    spec:
      serviceAccountName: external-dns
      containers:
      - name: external-dns
        image: registry.k8s.io/external-dns/external-dns:v0.13.2
        args:
        - --source=service
        - --source=ingress
        - --provider=aws  # o google, azure, etc.
        - --registry=txt
        - --txt-owner-id=my-cluster
        - --aws-zone-type=public
        - --log-level=debug</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>CNI Plugins avanzados</strong></p>
</div>
<div class="paragraph">
<p>Rancher soporta varios CNI (Container Network Interface) plugins.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 52. Opciones de CNI:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">CNI</th>
<th class="tableblock halign-left valign-top">Características</th>
<th class="tableblock halign-left valign-top">Caso de uso</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Flannel</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simple, overlay network</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Desarrollo, pequeños clusters</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calico</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Network policies, BGP routing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Seguridad, routing avanzado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cilium</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">eBPF-based, observabilidad</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Seguridad, performance</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Weave</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mesh networking, encryption</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Multi-cloud, security</p></td>
</tr>
</tbody>
</table>
<div class="listingblock">
<div class="title">Configurar Calico (en RKE2):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Durante creación del cluster
# Set CNI: Calico

# O instalar después
helm repo add projectcalico https://projectcalico.docs.tigera.io/charts
helm install calico projectcalico/tigera-operator \
  --namespace tigera-operator \
  --create-namespace

# Verificar
kubectl get pods -n calico-system
kubectl get nodes -o wide | grep -i calico

# Configurar políticas de red
# Ver sección anterior de NetworkPolicies</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Configurar Cilium (para eBPF):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Instalar Cilium
helm repo add cilium https://helm.cilium.io
helm install cilium cilium/cilium \
  --namespace kube-system \
  --set kubeProxyReplacement=strict \
  --set l7Proxy=true \
  --set encryption.enabled=true

# Verificar instalación
cilium status
cilium connectivity test

# Observabilidad de Cilium
helm install hubble cilium/hubble \
  --namespace kube-system \
  --set ui.enabled=true

# Acceder a Hubble UI
kubectl port-forward -n kube-system svc/hubble-ui 8081:80
# http://localhost:8081</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Best practices para storage y networking</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Storage:
1. Usar StorageClasses apropiadas por requerimiento
2. Implementar snapshots para backup
3. Monitorear uso de disco
4. Política de expansión automática
5. Encriptación en reposo

Networking:
1. Implementar NetworkPolicies (deny by default)
2. Usar Service Mesh para observabilidad
3. Configurar rate limiting
4. Implementar mTLS
5. Monitoreo de tráfico
6. DNS seguro (DNSSEC)
7. Egress filtering</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_6_monitoreo_y_observabilidad">Módulo 6: Monitoreo y Observabilidad</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_6_1_rancher_monitoring">6.1 Rancher Monitoring</h3>
<div class="paragraph">
<p>Rancher incluye un stack de monitoring completo basado en Prometheus y Grafana que proporciona visibilidad en tiempo real de clusters, nodos y aplicaciones.</p>
</div>
<div class="sect3">
<h4 id="_instalación_y_configuración_de_monitoring_stack">Instalación y configuración de monitoring stack</h4>
<div class="paragraph">
<p><strong>Arquitectura de Rancher Monitoring</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 53. Componentes del stack de monitoring:</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 40%;">
<col style="width: 40%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Componente</th>
<th class="tableblock halign-left valign-top">Propósito</th>
<th class="tableblock halign-left valign-top">Namespace</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Prometheus</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recopilación y almacenamiento de métricas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cattle-monitoring-system</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Grafana</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Visualización y dashboards</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cattle-monitoring-system</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alertmanager</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gestión de alertas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cattle-monitoring-system</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PrometheusOperator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Automatizar configuración de Prometheus</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cattle-monitoring-system</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">kube-state-metrics</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Métricas de objetos Kubernetes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cattle-monitoring-system</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">node-exporter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Métricas de nodos</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cattle-monitoring-system</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Blackbox-exporter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Monitoreo de endpoints HTTP(S)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">cattle-monitoring-system</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Instalar Rancher Monitoring</strong></p>
</div>
<div class="listingblock">
<div class="title">Via Rancher UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Apps → Charts
2. Buscar "Monitoring"
3. Seleccionar "Rancher Monitoring" (promtail stack)
4. Click "Install"

5. Configuración básica:
   Name: rancher-monitoring
   Namespace: cattle-monitoring-system

   Chart Options:

   Prometheus:
   - Enable: true
   - Retention: 24h (o personalizado)
   - Storage: 50Gi
   - StorageClass: fast-ssd

   Grafana:
   - Enable: true
   - Persistence: 10Gi
   - Admin password: &lt;secure-password&gt;

   Alertmanager:
   - Enable: true
   - Storage: 5Gi

   kube-state-metrics:
   - Enable: true

   node-exporter:
   - Enable: true

   prometheus-operator:
   - Enable: true

6. Review and Install
7. Esperar a que todos los pods estén running</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Verificar instalación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver pods
kubectl get pods -n cattle-monitoring-system

# Esperado:
# alertmanager-rancher-monitoring-alertmanager-0          2/2     Running
# grafana-rancher-monitoring-grafana-*                      1/1     Running
# prometheus-rancher-monitoring-prometheus-0               2/2     Running
# rancher-monitoring-kube-state-metrics-*                  1/1     Running
# rancher-monitoring-node-exporter-*                       1/1     Running
# rancher-monitoring-prometheus-operator-*                 1/1     Running

# Ver servicios
kubectl get svc -n cattle-monitoring-system

# Port forward a Prometheus
kubectl port-forward -n cattle-monitoring-system \
  svc/rancher-monitoring-prometheus 9090:9090

# Port forward a Grafana
kubectl port-forward -n cattle-monitoring-system \
  svc/rancher-monitoring-grafana 3000:3000

# Port forward a Alertmanager
kubectl port-forward -n cattle-monitoring-system \
  svc/rancher-monitoring-alertmanager 9093:9093</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">YAML Helm values personalizado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># values-monitoring.yaml
prometheus:
  prometheusSpec:
    # Retention policy
    retention: 30d
    retentionSize: "50GB"

    # Storage
    storageSpec:
      volumeClaimTemplate:
        spec:
          storageClassName: fast-ssd
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 100Gi

    # Resources
    resources:
      requests:
        cpu: 500m
        memory: 2Gi
      limits:
        cpu: 2000m
        memory: 4Gi

    # Scrape interval
    scrapeInterval: 30s
    evaluationInterval: 30s

    # External labels
    externalLabels:
      cluster: production
      environment: prod

    # Query logging
    queryLogFile: /prometheus/query.log

    # Remote storage (opcional)
    remoteWrite:
    - url: https://remote-prometheus.example.com/api/v1/write
      basicAuth:
        username: myuser
        password: mypassword
      writeRelabelConfigs:
      - sourceLabels: [__name__]
        regex: node_.*
        action: keep

grafana:
  replicas: 2

  persistence:
    enabled: true
    storageClassName: standard
    size: 10Gi

  adminPassword: ${GRAFANA_PASSWORD}

  datasources:
    datasources.yaml:
      apiVersion: 1
      datasources:
      - name: Prometheus
        type: prometheus
        url: http://rancher-monitoring-prometheus:9090
        access: proxy
        isDefault: true

  env:
    GF_SECURITY_ADMIN_USER: admin
    GF_SECURITY_DISABLE_GRAVATAR: "true"
    GF_EXPLORE_ENABLED: "true"

alertmanager:
  alertmanagerSpec:
    storage:
      volumeClaimTemplate:
        spec:
          storageClassName: standard
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 5Gi

kubeStateMetrics:
  enabled: true
  replicas: 1

nodeExporter:
  enabled: true
  tolerations:
  - effect: NoSchedule
    operator: Exists
  - effect: NoExecute
    operator: Exists</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_métricas_de_clúster_y_aplicaciones">Métricas de clúster y aplicaciones</h4>
<div class="paragraph">
<p><strong>Métricas predeterminadas</strong></p>
</div>
<div class="paragraph">
<p>Rancher Monitoring recopila automáticamente métricas de:
- <strong>Nodos</strong>: CPU, memoria, disco, red
- <strong>Pods</strong>: CPU, memoria, red
- <strong>Kubelet</strong>: API calls, volúmenes
- <strong>API Server</strong>: latencia, requests
- <strong>etcd</strong>: latencia de escritura/lectura</p>
</div>
<div class="listingblock">
<div class="title">Queries PromQL comunes:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text"># CPU usage por nodo
node_cpu_seconds_total{job="node-exporter"}

# Memoria disponible
node_memory_MemAvailable_bytes{job="node-exporter"}

# CPU usage por pod
sum(rate(container_cpu_usage_seconds_total[5m])) by (pod_name)

# Memoria usage por pod
sum(container_memory_usage_bytes) by (pod_name)

# Network I/O
rate(container_network_receive_bytes_total[5m])
rate(container_network_transmit_bytes_total[5m])

# Disk I/O
rate(node_disk_io_time_seconds_total[5m])

# Uptime del cluster
process_resident_memory_bytes

# API Server latency
histogram_quantile(0.95, rate(apiserver_request_duration_seconds_bucket[5m]))

# Pod restart count
container_last_seen{pod_name=~".*"}

# PVC usage
kubelet_volume_stats_available_bytes / kubelet_volume_stats_capacity_bytes</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>ServiceMonitor - Monitorear aplicaciones personalizadas</strong></p>
</div>
<div class="paragraph">
<p>ServiceMonitor permite que Prometheus descubra y scrappee automáticamente aplicaciones.</p>
</div>
<div class="listingblock">
<div class="title">YAML ServiceMonitor (aplicación personalizada):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Service
metadata:
  name: myapp-metrics
  namespace: production
  labels:
    app: myapp
spec:
  ports:
  - name: metrics
    port: 8080
    targetPort: 8080
  selector:
    app: myapp

---
# ServiceMonitor para scrappear las métricas
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: myapp-monitor
  namespace: production
  labels:
    release: rancher-monitoring
spec:
  selector:
    matchLabels:
      app: myapp

  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics

    # Relabeling (opcional)
    relabelings:
    - sourceLabels: [__meta_kubernetes_pod_name]
      targetLabel: pod
    - sourceLabels: [__meta_kubernetes_namespace]
      targetLabel: namespace

    # Scrape relabeling
    metricRelabelings:
    - sourceLabels: [__name__]
      regex: 'myapp_.*'
      action: keep

---
# PrometheusRule para alertas
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: myapp-alerts
  namespace: production
  labels:
    prometheus: kube-prometheus
    release: rancher-monitoring
spec:
  groups:
  - name: myapp.rules
    interval: 30s
    rules:
    - alert: MyAppHighCPU
      expr: sum(rate(myapp_cpu_usage[5m])) &gt; 0.8
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "MyApp CPU usage is high"
        description: "CPU usage: {{ $value }}"

    - alert: MyAppDown
      expr: up{job="myapp-metrics"} == 0
      for: 2m
      labels:
        severity: critical
      annotations:
        summary: "MyApp is down"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exponer métricas desde aplicación</strong></p>
</div>
<div class="paragraph">
<p>Ejemplo de aplicación Python con Prometheus client:</p>
</div>
<div class="listingblock">
<div class="title">Python + Prometheus:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">from prometheus_client import Counter, Histogram, Gauge, start_http_server
import time

# Definir métricas
request_count = Counter('myapp_requests_total', 'Total requests', ['method', 'endpoint'])
request_duration = Histogram('myapp_request_duration_seconds', 'Request duration')
active_connections = Gauge('myapp_active_connections', 'Active connections')

# Iniciar server HTTP en puerto 8080
start_http_server(8080)

# En tu aplicación:
@app.route('/api/users')
def get_users():
    request_count.labels(method='GET', endpoint='/users').inc()

    with request_duration.time():
        # Tu lógica
        users = fetch_users()

    return users

# Actualizar gauge de conexiones activas
active_connections.set(current_connections())

# Las métricas se exponen en /metrics (automático)
# http://app:8080/metrics</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Node.js + Prometheus:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">const express = require('express');
const client = require('prom-client');

const app = express();

// Definir métricas
const httpRequestDuration = new client.Histogram({
  name: 'myapp_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [0.1, 0.5, 1, 2, 5]
});

const requestCounter = new client.Counter({
  name: 'myapp_requests_total',
  help: 'Total HTTP requests',
  labelNames: ['method', 'route', 'status_code']
});

// Middleware para medir
app.use((req, res, next) =&gt; {
  const start = Date.now();

  res.on('finish', () =&gt; {
    const duration = (Date.now() - start) / 1000;
    httpRequestDuration
      .labels(req.method, req.route?.path || req.path, res.statusCode)
      .observe(duration);

    requestCounter
      .labels(req.method, req.route?.path || req.path, res.statusCode)
      .inc();
  });

  next();
});

// Exponer métricas
app.get('/metrics', async (req, res) =&gt; {
  res.set('Content-Type', client.register.contentType);
  res.end(await client.register.metrics());
});

app.listen(8080);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_alertas_y_notificaciones">Alertas y notificaciones</h4>
<div class="paragraph">
<p><strong>Configurar Alertmanager</strong></p>
</div>
<div class="paragraph">
<p>Alertmanager gestiona alertas, realiza deduplicación y enrutamiento.</p>
</div>
<div class="listingblock">
<div class="title">YAML Alertmanager configuration:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Secret
metadata:
  name: alertmanager-config
  namespace: cattle-monitoring-system
type: Opaque
stringData:
  alertmanager.yml: |
    global:
      resolve_timeout: 5m
      slack_api_url: 'https://hooks.slack.com/services/YOUR/WEBHOOK/URL'
      pagerduty_url: 'https://events.pagerduty.com/v2/enqueue'

    route:
      # Receptor por defecto
      receiver: 'default-receiver'
      group_by: ['alertname', 'cluster', 'service']
      group_wait: 10s
      group_interval: 10s
      repeat_interval: 12h

      # Sub-rutas
      routes:
      # Alertas críticas -&gt; PagerDuty
      - match:
          severity: critical
        receiver: pagerduty-receiver
        repeat_interval: 1h

      # Alertas de backend
      - match:
          component: backend
        receiver: backend-team
        group_wait: 5s
        group_interval: 5s

    receivers:
    # Slack default
    - name: 'default-receiver'
      slack_configs:
      - channel: '#alerts'
        title: 'Alert: {{ .GroupLabels.alertname }}'
        text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'
        send_resolved: true

    # Backend team Slack
    - name: 'backend-team'
      slack_configs:
      - channel: '#backend-alerts'
        title: '[{{ .Status | toUpper }}] {{ .GroupLabels.alertname }}'
        text: 'Cluster: {{ .GroupLabels.cluster }}'

    # PagerDuty
    - name: 'pagerduty-receiver'
      pagerduty_configs:
      - service_key: 'YOUR-PAGERDUTY-SERVICE-KEY'
        description: '{{ .GroupLabels.alertname }}'
        details:
          firing: '{{ range .Alerts.Firing }}{{ .Labels.instance }},{{ end }}'

    # Email
    - name: 'email-receiver'
      email_configs:
      - to: 'ops@example.com'
        from: 'alerts@example.com'
        smarthost: 'smtp.example.com:587'
        auth_username: 'alerts@example.com'
        auth_password: 'password'
        headers:
          Subject: '[{{ .GroupLabels.severity | toUpper }}] {{ .GroupLabels.alertname }}'

    # Webhook personalizado
    - name: 'webhook-receiver'
      webhook_configs:
      - url: 'https://hooks.example.com/alerts'
        send_resolved: true

    inhibit_rules:
    # Suprimir alertas non-críticas si hay críticas
    - source_match:
        severity: critical
      target_match:
        severity: warning
      equal: ['alertname', 'instance']

    # Suprimir alertas si el nodo está down
    - source_match:
        alertname: NodeDown
      target_match_re:
        alertname: '.*'
      equal: ['instance']</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Crear PrometheusRules (alertas personalizadas)</strong></p>
</div>
<div class="listingblock">
<div class="title">YAML PrometheusRule completo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: cluster-alerts
  namespace: cattle-monitoring-system
  labels:
    prometheus: kube-prometheus
    release: rancher-monitoring
spec:
  groups:
  - name: cluster.rules
    interval: 30s
    rules:
    # Node alerts
    - alert: NodeNotReady
      expr: kube_node_status_condition{condition="Ready",status="true"} == 0
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "Node {{ $labels.node }} is not ready"
        description: "Node has been unready for more than 5 minutes"

    - alert: NodeHighCPU
      expr: 100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) &gt; 80
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "Node {{ $labels.instance }} CPU usage is high"
        description: "CPU usage: {{ $value }}%"

    - alert: NodeHighMemory
      expr: (1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes)) * 100 &gt; 85
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "Node {{ $labels.instance }} memory usage is high"
        description: "Memory usage: {{ $value }}%"

    - alert: NodeDiskPressure
      expr: kube_node_status_condition{condition="DiskPressure",status="true"} == 1
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "Node {{ $labels.node }} has disk pressure"

    # Pod alerts
    - alert: PodCrashLooping
      expr: rate(kube_pod_container_status_restarts_total[15m]) &gt; 0.1
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "Pod {{ $labels.pod }} in namespace {{ $labels.namespace }} is crash looping"
        description: "Restart rate: {{ $value }}"

    - alert: PodNotHealthy
      expr: min_over_time(sum by (namespace, pod) (kube_pod_status_phase{phase=~"Pending|Unknown|Failed"})[15m:1m]) &gt; 0
      for: 15m
      labels:
        severity: warning
      annotations:
        summary: "Pod {{ $labels.pod }} in namespace {{ $labels.namespace }} is not healthy"

    - alert: ContainerWaiting
      expr: sum by (pod, namespace) (kube_pod_container_status_waiting) &gt; 0
      for: 1h
      labels:
        severity: warning
      annotations:
        summary: "Container in pod {{ $labels.pod }} has been waiting for more than 1 hour"

    # Deployment alerts
    - alert: DeploymentGenerationMismatch
      expr: kube_deployment_status_observed_generation{namespace=~".*"} != kube_deployment_metadata_generation{namespace=~".*"}
      for: 15m
      labels:
        severity: warning
      annotations:
        summary: "Deployment {{ $labels.deployment }} generation mismatch"

    - alert: DeploymentReplicasMismatch
      expr: |
        kube_deployment_spec_replicas != kube_deployment_status_replicas_available
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "Deployment {{ $labels.deployment }} replicas mismatch"
        description: "Desired: {{ $value }}"

    # PVC alerts
    - alert: PersistentVolumeInodeFull
      expr: (kubelet_volume_stats_inodes_used / kubelet_volume_stats_inodes) &gt; 0.95
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "PVC {{ $labels.persistentvolumeclaim }} inodes almost full"
        description: "Usage: {{ $value | humanizePercentage }}"

    - alert: PersistentVolumeFull
      expr: (kubelet_volume_stats_used_bytes / kubelet_volume_stats_capacity_bytes) &gt; 0.9
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: "PVC {{ $labels.persistentvolumeclaim }} almost full"
        description: "Usage: {{ $value | humanizePercentage }}"

    # API Server alerts
    - alert: KubeApiServerLatency
      expr: histogram_quantile(0.99, rate(apiserver_request_duration_seconds_bucket{job="kube-apiserver"}[5m])) &gt; 1
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "API Server latency is high"
        description: "p99 latency: {{ $value }}s"

    - alert: KubeControllerManagerDown
      expr: up{job="kube-controller-manager"} == 0
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "Kube Controller Manager is down"

    - alert: KubeSchedulerDown
      expr: up{job="kube-scheduler"} == 0
      for: 5m
      labels:
        severity: critical
      annotations:
        summary: "Kube Scheduler is down"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Gestionar alertas via UI</strong></p>
</div>
<div class="listingblock">
<div class="title">En Rancher UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Monitoring → Alert Rules
   - Ver todas las alertas activas
   - Estado: Firing | Resolved
   - Severidad: critical | warning | info

2. Filtrar por:
   - Namespace
   - Severidad
   - Estado

3. Ir a Alertmanager:
   - Cluster → Monitoring → Alert Manager
   - Ver rutas de alertas
   - Ver inhibiciones activas

4. Test de alertas:
   kubectl exec -n cattle-monitoring-system \
     prometheus-rancher-monitoring-prometheus-0 -- \
     amtool alert add TestAlert severity=warning</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dashboards_personalizados">Dashboards personalizados</h4>
<div class="paragraph">
<p><strong>Dashboards predefinidos</strong></p>
</div>
<div class="paragraph">
<p>Rancher incluye dashboards preconstruidos:
- Cluster Monitoring
- Node Exporter
- Kubernetes API Server
- Etcd
- Kubelet
- Controller Manager</p>
</div>
<div class="listingblock">
<div class="title">Ver dashboards:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Monitoring → Dashboards
2. O en Grafana UI:
   - http://grafana.example.com (port-forward)
   - Login: admin / &lt;password&gt;
   - Home → Dashboards</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Crear dashboard personalizado</strong></p>
</div>
<div class="listingblock">
<div class="title">Via Grafana UI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Grafana → Create → Dashboard
2. Add new panel
3. Configurar:
   - Title: CPU Usage by Node
   - Data source: Prometheus
   - PromQL Query:
     100 - (avg by (instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)

4. Visualization:
   - Type: Graph / Gauge / Stat / Table
   - Color scheme: Green-Yellow-Red
   - Thresholds: 60, 80

5. Alert:
   - Threshold: 80
   - No data: Alerting
   - Execution errors: Alerting

6. Save Dashboard</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">YAML ConfigMap con dashboard:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: custom-dashboard
  namespace: cattle-monitoring-system
  labels:
    grafana_dashboard: "1"
data:
  custom-dashboard.json: |
    {
      "dashboard": {
        "title": "Custom Application Monitoring",
        "timezone": "browser",
        "panels": [
          {
            "title": "Request Rate",
            "targets": [
              {
                "expr": "rate(myapp_requests_total[5m])",
                "legendFormat": "{{ method }} {{ endpoint }}"
              }
            ],
            "type": "graph"
          },
          {
            "title": "Request Duration",
            "targets": [
              {
                "expr": "histogram_quantile(0.95, rate(myapp_request_duration_seconds_bucket[5m]))",
                "legendFormat": "p95"
              },
              {
                "expr": "histogram_quantile(0.99, rate(myapp_request_duration_seconds_bucket[5m]))",
                "legendFormat": "p99"
              }
            ],
            "type": "graph"
          },
          {
            "title": "Error Rate",
            "targets": [
              {
                "expr": "rate(myapp_errors_total[5m])",
                "legendFormat": "{{ error_type }}"
              }
            ],
            "type": "graph"
          },
          {
            "title": "Active Connections",
            "targets": [
              {
                "expr": "myapp_active_connections"
              }
            ],
            "type": "gauge"
          }
        ]
      }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exportar e importar dashboards</strong></p>
</div>
<div class="listingblock">
<div class="title">Export dashboard como JSON:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># En Grafana UI:
1. Dashboard → Settings (gear icon)
2. Click "Save as JSON"
3. Copiar JSON

# O via API:
curl -H "Authorization: Bearer $GRAFANA_TOKEN" \
  http://localhost:3000/api/dashboards/db/cluster-monitoring \
  | jq .dashboard &gt; dashboard.json</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Importar dashboard:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># En Grafana UI:
1. Create → Import
2. Pegar JSON o URL
3. Seleccionar data source (Prometheus)
4. Save

# O via API:
curl -X POST \
  -H "Authorization: Bearer $GRAFANA_TOKEN" \
  -H "Content-Type: application/json" \
  -d @dashboard.json \
  http://localhost:3000/api/dashboards/db</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Variables en dashboards</strong></p>
</div>
<div class="paragraph">
<p>Las variables permiten crear dashboards dinámicos.</p>
</div>
<div class="listingblock">
<div class="title">Crear variable de namespace:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Dashboard → Settings → Variables
2. New Variable
3. Configurar:
   Name: namespace
   Query: label_values(kube_pod_labels, namespace)
   Refresh: On dashboard load
   Selection: Multi-select

4. Usar en queries:
   sum by (pod) (rate(container_cpu_usage_seconds_total{namespace=~"$namespace"}[5m]))

5. En el dashboard, el selector aparecerá en la parte superior</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Alerting en Grafana</strong></p>
</div>
<div class="paragraph">
<p>Grafana puede enviar alertas directamente sin Alertmanager.</p>
</div>
<div class="listingblock">
<div class="title">Configurar alerting:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Dashboard → Panel → Alert tab
2. Configurar:
   - Alert name: High CPU
   - Evaluate every: 1m
   - For: 5m

3. Conditions:
   - When: avg()
   - Of: query A
   - Is above: 80

4. No data and execution failures:
   - Alerting
   - OK

5. Notification channels:
   - Send to: Slack / Email / PagerDuty / Webhook

6. Annotations:
   - Summary: CPU usage is high
   - Runbook: https://wiki.example.com/high-cpu

7. Save</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Best practices para monitoring</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Métricas:
   - Usar labels consistentes
   - No explotar cardinalidad (evitar user IDs como label)
   - Retención apropiada por criticidad
   - Usar histogramas para latencia

2. Alertas:
   - Alertas accionables (no ruido)
   - Incluir runbook en descripción
   - Severidad clara (critical/warning/info)
   - Distinct alerts por problema

3. Dashboards:
   - Una métrica = un panel
   - Titles claros y descriptivos
   - Variables para flexibilidad
   - Documentar en panels

4. Escalado:
   - Retention basado en importancia
   - Remote storage para larga duración
   - Federation para multi-cluster
   - High-availability Prometheus</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_6_2_logging">6.2 Logging</h3>
<div class="paragraph">
<p>Logging centralizado proporciona visibilidad completa de eventos en aplicaciones y el cluster. Rancher integra herramientas como Elasticsearch, Fluentd y Kibana para gestión de logs a escala.</p>
</div>
<div class="sect3">
<h4 id="_configuración_de_logging_centralizado">Configuración de logging centralizado</h4>
<div class="paragraph">
<p><strong>Arquitectura de logging</strong></p>
</div>
<div class="listingblock">
<div class="title">Flujo de logs en Kubernetes:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-plantuml hljs" data-lang="plantuml">@startuml
!define RECTANGLE rectangle

skinparam backgroundColor transparent

actor "Containers\n(stdout/stderr)" as Containers
participant "Kubelet" as Kubelet
database "Container Logs\n(/var/log/containers)" as Logs
participant "Fluentd/Filebeat" as Forwarder
database "Buffer" as Buffer
database "Elasticsearch\nor S3/GCS" as Store
participant "Kibana\nor UI" as UI
actor "User" as User

Containers -&gt; Kubelet: Write logs
Kubelet -&gt; Logs: Save logs
Forwarder -&gt; Logs: Collect logs
Forwarder -&gt; Buffer: Parse &amp; buffer
Buffer -&gt; Store: Forward logs
Store --&gt; UI: Indexed data
UI --&gt; User: Search &amp; visualize

note right of Forwarder
  Parse, filter, transform
  Add metadata (pod, ns, node)
  Batch &amp; compress
end note

@enduml</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Opciones de logging en Rancher</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 54. Tabla de soluciones de logging:</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 33.3335%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Solución</th>
<th class="tableblock halign-left valign-top">Provisioner</th>
<th class="tableblock halign-left valign-top">Características</th>
<th class="tableblock halign-left valign-top">Mejor para</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elasticsearch + Kibana</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elastic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Full-featured, scalable, costoso</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enterprise, analytics avanzado</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loki + Promtail</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Grafana</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lightweight, no indexación completa</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Startups, observabilidad simple</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Splunk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Splunk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enterprise-grade, caro</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Large enterprises</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S3/CloudStorage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cloud provider</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cheap, batch processing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Compliance, long-term storage</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Datadog/New Relic</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">SaaS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Managed, caro</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Startups con $ disponible</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Instalar stack de logging (Elasticsearch + Fluentd + Kibana)</strong></p>
</div>
<div class="listingblock">
<div class="title">Via Rancher UI - Instalar Elasticsearch:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Cluster → Apps → Charts
2. Buscar "Elasticsearch"
3. Instalar versión recomendada (por ej., Bitnami)
4. Configurar:
   - Replicas: 3 (para HA)
   - Storage: 100Gi minimum
   - Resources: 2Gi RAM minimum por node

5. Create</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">YAML Elasticsearch Stack (completo):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Namespace para logging
apiVersion: v1
kind: Namespace
metadata:
  name: logging
  labels:
    name: logging

---
# Elasticsearch
apiVersion: elasticsearch.k8s.elastic.co/v1
kind: Elasticsearch
metadata:
  name: elasticsearch
  namespace: logging
spec:
  version: 8.11.0

  nodeSets:
  - name: data
    count: 3
    config:
      node.store.allow_mmap: false
      node.roles: ["master", "data", "ingest"]
      xpack.security.enabled: true
    podTemplate:
      spec:
        containers:
        - name: elasticsearch
          resources:
            requests:
              memory: 2Gi
              cpu: 500m
            limits:
              memory: 4Gi
              cpu: 2000m
        affinity:
          podAntiAffinity:
            preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchExpressions:
                  - key: elasticsearch.k8s.elastic.co/statefulset-name
                    operator: In
                    values:
                    - elasticsearch-data
                topologyKey: kubernetes.io/hostname
    volumeClaimTemplates:
    - metadata:
        name: elasticsearch-data
      spec:
        accessModes:
        - ReadWriteOnce
        resources:
          requests:
            storage: 100Gi
        storageClassName: fast-ssd

---
# Kibana
apiVersion: kibana.k8s.elastic.co/v1
kind: Kibana
metadata:
  name: kibana
  namespace: logging
spec:
  version: 8.11.0
  count: 2
  elasticsearchRef:
    name: elasticsearch
  config:
    xpack.security.enabled: true
    xpack.reporting.enabled: false
    kibana.defaultAppId: discover
  podTemplate:
    spec:
      containers:
      - name: kibana
        resources:
          requests:
            memory: 1Gi
            cpu: 100m
          limits:
            memory: 2Gi
            cpu: 500m
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: kibana.k8s.elastic.co/name
                  operator: In
                  values:
                  - kibana
              topologyKey: kubernetes.io/hostname

---
# Ingress para Kibana
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: kibana-ingress
  namespace: logging
  annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/auth-type: basic
    nginx.ingress.kubernetes.io/auth-secret: basic-auth
spec:
  ingressClassName: nginx
  tls:
  - hosts:
    - kibana.example.com
    secretName: kibana-tls
  rules:
  - host: kibana.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: kibana
            port:
              number: 5601</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_integración_con_elasticsearch_y_fluentd">Integración con Elasticsearch y Fluentd</h4>
<div class="paragraph">
<p><strong>Instalar Fluent Bit (alternativa lightweight a Fluentd)</strong></p>
</div>
<div class="listingblock">
<div class="title">YAML Fluent Bit DaemonSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: ServiceAccount
metadata:
  name: fluent-bit
  namespace: logging

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: fluent-bit
rules:
- apiGroups: [""]
  resources:
  - pods
  - namespaces
  verbs:
  - get
  - list
  - watch

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: fluent-bit
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: fluent-bit
subjects:
- kind: ServiceAccount
  name: fluent-bit
  namespace: logging

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
  namespace: logging
data:
  fluent-bit.conf: |
    [SERVICE]
        Daemon Off
        Flush 5
        Log_Level info
        Parsers_File parsers.conf
        HTTP_Server On
        HTTP_Listen 0.0.0.0
        HTTP_Port 2020
        Health_Check On

    [INPUT]
        Name tail
        Path /var/log/containers/*.log
        Parser docker
        Tag kubernetes.*
        Refresh_Interval 5
        Mem_Buf_Limit 50MB
        Skip_Long_Lines On

    [INPUT]
        Name systemd
        Tag host.*
        Systemd_Filter _SYSTEMD_UNIT=kubelet.service
        Read_From_Tail On

    [FILTER]
        Name kubernetes
        Match kubernetes.*
        Kube_URL https://kubernetes.default.svc:443
        Kube_CA_File /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
        Kube_Token_File /var/run/secrets/kubernetes.io/serviceaccount/token
        Kube_Tag_Prefix kubernetes.var.log.containers.
        Merge_Log On
        Keep_Log Off
        K8S-Logging.Parser On
        K8S-Logging.Exclude On

    [FILTER]
        Name modify
        Match *
        Add cluster_name production
        Add environment production

    [OUTPUT]
        Name es
        Match kubernetes.*
        Host elasticsearch.logging.svc.cluster.local
        Port 9200
        HTTP_User elastic
        HTTP_Passwd ${ELASTICSEARCH_PASSWORD}
        Logstash_Format On
        Logstash_Prefix kubernetes-${HOSTNAME}
        Time_Key @timestamp
        Type _doc
        Retry_Limit 10
        tls On
        tls.verify Off

    [OUTPUT]
        Name es
        Match host.*
        Host elasticsearch.logging.svc.cluster.local
        Port 9200
        HTTP_User elastic
        HTTP_Passwd ${ELASTICSEARCH_PASSWORD}
        Logstash_Format On
        Logstash_Prefix host-logs
        Time_Key @timestamp
        Type _doc
        tls On
        tls.verify Off

  parsers.conf: |
    [PARSER]
        Name docker
        Format json
        Time_Key time
        Time_Format %Y-%m-%dT%H:%M:%S.%L%z
        Time_Keep On

    [PARSER]
        Name syslog
        Format regex
        Regex ^\&lt;(?&lt;pri&gt;[0-9]+)\&gt;(?&lt;time&gt;[^ ]* [^ ]* [^ ]*) (?&lt;host&gt;[^ ]*) (?&lt;ident&gt;[a-zA-Z0-9_\/\.\-]*)(?:\[(?&lt;pid&gt;[0-9]+)\])?(?:[^\:]*\:)? *(?&lt;message&gt;.*)$
        Time_Key time
        Time_Format %b %d %H:%M:%S

---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: fluent-bit
  namespace: logging
  labels:
    app: fluent-bit
spec:
  selector:
    matchLabels:
      app: fluent-bit
  template:
    metadata:
      labels:
        app: fluent-bit
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "2020"
        prometheus.io/path: "/api/v1/metrics/prometheus"
    spec:
      serviceAccountName: fluent-bit
      terminationGracePeriodSeconds: 30

      tolerations:
      - effect: NoSchedule
        operator: Exists
      - effect: NoExecute
        operator: Exists

      containers:
      - name: fluent-bit
        image: fluent/fluent-bit:2.1.8

        ports:
        - name: http
          containerPort: 2020

        env:
        - name: ELASTICSEARCH_PASSWORD
          valueFrom:
            secretKeyRef:
              name: elasticsearch-credentials
              key: password

        resources:
          requests:
            memory: 100Mi
            cpu: 50m
          limits:
            memory: 500Mi
            cpu: 200m

        volumeMounts:
        - name: varlog
          mountPath: /var/log
          readOnly: true
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
        - name: config
          mountPath: /fluent-bit/etc/
          readOnly: true

      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
      - name: config
        configMap:
          name: fluent-bit-config

---
# Service para scraping de Prometheus
apiVersion: v1
kind: Service
metadata:
  name: fluent-bit
  namespace: logging
  labels:
    app: fluent-bit
spec:
  type: ClusterIP
  selector:
    app: fluent-bit
  ports:
  - name: http
    port: 2020
    targetPort: 2020</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Alternativa: Fluentd (más flexible)</strong></p>
</div>
<div class="listingblock">
<div class="title">YAML Fluentd StatefulSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: fluentd-config
  namespace: logging
data:
  fluent.conf: |
    &lt;source&gt;
      @type tail
      @id input_tail
      path /var/log/containers/*.log
      pos_file /var/log/fluentd-containers.log.pos
      tag kubernetes.*
      read_from_head true
      &lt;parse&gt;
        @type json
        time_format %Y-%m-%dT%H:%M:%S.%NZ
      &lt;/parse&gt;
    &lt;/source&gt;

    &lt;filter kubernetes.**&gt;
      @type kubernetes_metadata
      @id filter_kube_metadata
      kubernetes_url "#{ENV['FLUENT_FILTER_KUBERNETES_URL'] || 'https://' + ENV.fetch('KUBERNETES_SERVICE_HOST') + ':' + ENV.fetch('KUBERNETES_SERVICE_PORT') + '/api'}"
      verify_ssl "#{ENV['KUBERNETES_VERIFY_SSL'] || true}"
      ca_file "#{ENV['KUBERNETES_CA_FILE']}"
      skip_labels "#{ENV['FLUENT_FILTER_KUBERNETES_METADATA_SKIP_LABELS'] || 'false'}"
      skip_container_metadata "#{ENV['FLUENT_FILTER_KUBERNETES_METADATA_SKIP_CONTAINER_METADATA'] || 'false'}"
      skip_master_url "#{ENV['FLUENT_FILTER_KUBERNETES_METADATA_SKIP_MASTER_URL'] || 'false'}"
    &lt;/filter&gt;

    &lt;filter kubernetes.**&gt;
      @type modify
      &lt;replace&gt;
        key cluster_name
        expression production
      &lt;/replace&gt;
      &lt;replace&gt;
        key environment
        expression prod
      &lt;/replace&gt;
    &lt;/filter&gt;

    &lt;match **&gt;
      @type elasticsearch
      @id output_elasticsearch
      @log_level info
      include_tag_key true
      host "#{ENV['FLUENT_ELASTICSEARCH_HOST'] || 'elasticsearch.logging.svc.cluster.local'}"
      port "#{ENV['FLUENT_ELASTICSEARCH_PORT'] || 9200}"
      username "#{ENV['FLUENT_ELASTICSEARCH_USER']}"
      password "#{ENV['FLUENT_ELASTICSEARCH_PASSWORD']}"
      logstash_format true
      logstash_prefix kubernetes-${HOSTNAME}
      &lt;buffer tag,time&gt;
        @type file
        path /var/log/fluentd-buffers/kubernetes.system.buffer
        flush_mode interval
        retry_type exponential_backoff
        flush_interval 5s
        retry_forever
        retry_max_interval 30
        chunk_limit_size "#{ENV['FLUENT_ELASTICSEARCH_BUFFER_CHUNK_LIMIT_SIZE'] || '2M'}"
        queue_limit_length "#{ENV['FLUENT_ELASTICSEARCH_BUFFER_QUEUE_LIMIT_LENGTH'] || '8'}"
        overflow_action block
      &lt;/buffer&gt;
    &lt;/match&gt;

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: fluentd
  namespace: logging
spec:
  replicas: 3
  serviceName: fluentd
  selector:
    matchLabels:
      app: fluentd
  template:
    metadata:
      labels:
        app: fluentd
    spec:
      serviceAccountName: fluentd
      securityContext:
        fsGroup: 0

      containers:
      - name: fluentd
        image: fluent/fluentd-kubernetes-daemonset:v1-debian-elasticsearch

        env:
        - name: FLUENT_ELASTICSEARCH_HOST
          value: "elasticsearch.logging.svc.cluster.local"
        - name: FLUENT_ELASTICSEARCH_PORT
          value: "9200"
        - name: FLUENT_ELASTICSEARCH_USER
          value: "elastic"
        - name: FLUENT_ELASTICSEARCH_PASSWORD
          valueFrom:
            secretKeyRef:
              name: elasticsearch-credentials
              key: password
        - name: FLUENT_ELASTICSEARCH_LOGSTASH_PREFIX
          value: "kubernetes"

        resources:
          limits:
            memory: 512Mi
            cpu: 500m
          requests:
            memory: 256Mi
            cpu: 200m

        volumeMounts:
        - name: varlog
          mountPath: /var/log
          readOnly: true
        - name: varlibdockercontainers
          mountPath: /var/lib/docker/containers
          readOnly: true
        - name: config
          mountPath: /fluentd/etc/fluent.conf
          subPath: fluent.conf
        - name: buffer
          mountPath: /var/log/fluentd-buffers

      volumes:
      - name: varlog
        hostPath:
          path: /var/log
      - name: varlibdockercontainers
        hostPath:
          path: /var/lib/docker/containers
      - name: config
        configMap:
          name: fluentd-config

  volumeClaimTemplates:
  - metadata:
      name: buffer
    spec:
      accessModes: [ "ReadWriteOnce" ]
      storageClassName: standard
      resources:
        requests:
          storage: 10Gi</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_búsqueda_y_análisis_de_logs">Búsqueda y análisis de logs</h4>
<div class="paragraph">
<p><strong>Via Kibana UI</strong></p>
</div>
<div class="listingblock">
<div class="title">Explorar logs en Kibana:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Acceder a Kibana: https://kibana.example.com

2. Crear Index Pattern:
   - Settings → Index Patterns
   - Create Index Pattern
   - Pattern: kubernetes-*
   - Time field: @timestamp
   - Create

3. Discover:
   - Ver logs en tiempo real
   - Filtrar por:
     * Pod name
     * Namespace
     * Container
     * Log level
     * Message content

4. Búsquedas avanzadas:
   - Kibana Query Language (KQL)
   - Ejemplo: kubernetes.pod_name:"nginx-*" AND log:"error"

5. Crear visualizaciones:
   - Visualize
   - Seleccionar índice
   - Crear gráficos, tablas, mapas

6. Dashboards:
   - Combinar múltiples visualizaciones
   - Filtros globales
   - Actualización en tiempo real</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Kibana Query Language (KQL) - Ejemplos</strong></p>
</div>
<div class="listingblock">
<div class="title">Consultas útiles:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text"># Logs de error de un namespace específico
kubernetes.namespace_name:"production" AND log:"ERROR"

# Logs de un pod específico en últimos 15 minutos
kubernetes.pod_name:"my-app-123abc" AND @timestamp &gt; now-15m

# Latencia alta en requests HTTP
http.response_time &gt; 1000 AND http.status &gt;= 500

# Errores en base de datos
log:"connection refused" OR log:"database error"

# Logs de múltiples aplicaciones
app:"frontend" OR app:"backend" OR app:"api"

# Logs sin errores en últimos 5 minutos
NOT log:"ERROR" AND NOT log:"WARN" AND @timestamp &gt; now-5m

# Pods reiniciados
restart_count &gt; 0

# Todos los logs de production
kubernetes.namespace_name:"production"

# Búsqueda por contenedor
kubernetes.container_name:"nginx"

# Logs con metadata específica
kubernetes.labels.environment:"staging"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Análisis con agregaciones</strong></p>
</div>
<div class="listingblock">
<div class="title">Crear agregaciones en Kibana:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Visualize → Create new visualization
2. Select index pattern: kubernetes-*
3. Aggregation options:

   Metrics:
   - Average response_time
   - Max memory_usage
   - Count of errors

   Bucket aggregations:
   - Terms (Top 10 namespaces by request count)
   - Date histogram (errors over time)
   - Nested aggregations (errors per pod per namespace)

4. Visualización automática
5. Guardar visualización</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Alertas en Kibana/Elasticsearch</strong></p>
</div>
<div class="listingblock">
<div class="title">Crear alertas:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Stack Rules - Alert cuando muchos errores
apiVersion: v1
kind: ConfigMap
metadata:
  name: kibana-alerts
  namespace: logging
data:
  high-error-rate.json: |
    {
      "name": "High Error Rate Alert",
      "ruleTypeId": "logs.alert_conditions",
      "schedule": {
        "interval": "5m"
      },
      "params": {
        "criteria": [
          {
            "comparator": "&gt;",
            "fieldName": "error_count",
            "value": 100
          }
        ],
        "timeSize": 5,
        "timeUnit": "m"
      },
      "actions": [
        {
          "actionTypeId": ".slack",
          "params": {
            "message": "Alert: High error rate detected"
          }
        }
      ]
    }

---
# Vía Elasticsearch Watcher
apiVersion: v1
kind: ConfigMap
metadata:
  name: elasticsearch-watcher
  namespace: logging
data:
  high-error-alert.json: |
    {
      "trigger": {
        "schedule": {
          "interval": "5m"
        }
      },
      "input": {
        "search": {
          "request": {
            "index": ["kubernetes-*"],
            "body": {
              "query": {
                "bool": {
                  "must": [
                    { "match": { "log": "ERROR" } },
                    { "range": { "@timestamp": { "gte": "now-5m" } } }
                  ]
                }
              },
              "aggs": {
                "error_count": { "value_count": { "field": "_id" } }
              }
            }
          }
        }
      },
      "condition": {
        "compare": {
          "ctx.payload.aggregations.error_count.value": { "gt": 100 }
        }
      },
      "actions": {
        "send_email": {
          "email": {
            "to": "ops-team@example.com",
            "subject": "Alert: High Error Rate",
            "body": "Error count: {{ctx.payload.aggregations.error_count.value}}"
          }
        }
      }
    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_políticas_de_retención">Políticas de retención</h4>
<div class="paragraph">
<p><strong>Índices de Elasticsearch - Cycle y retention</strong></p>
</div>
<div class="paragraph">
<p>Por defecto, Fluent Bit/Fluentd crean índices diarios: <code>kubernetes-2024.10.31</code></p>
</div>
<div class="listingblock">
<div class="title">YAML Index Lifecycle Management (ILM):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Política ILM para rotación de índices
apiVersion: v1
kind: ConfigMap
metadata:
  name: elasticsearch-ilm-policy
  namespace: logging
data:
  kubernetes-policy.json: |
    {
      "policy": "kubernetes-logs-policy",
      "phases": {
        "hot": {
          "min_age": "0d",
          "actions": {
            "rollover": {
              "max_primary_shard_size": "50GB",
              "max_age": "1d"
            },
            "set_priority": {
              "priority": 100
            }
          }
        },
        "warm": {
          "min_age": "7d",
          "actions": {
            "set_priority": {
              "priority": 50
            },
            "forcemerge": {
              "max_num_segments": 1
            }
          }
        },
        "cold": {
          "min_age": "30d",
          "actions": {
            "set_priority": {
              "priority": 0
            },
            "searchable_snapshot": {
              "snapshot_repository": "backup"
            }
          }
        },
        "delete": {
          "min_age": "90d",
          "actions": {
            "delete": {}
          }
        }
      }
    }

---
# Index Template para aplicar ILM automáticamente
apiVersion: v1
kind: ConfigMap
metadata:
  name: elasticsearch-index-template
  namespace: logging
data:
  kubernetes-template.json: |
    {
      "index_patterns": ["kubernetes-*"],
      "template": {
        "settings": {
          "number_of_shards": 1,
          "number_of_replicas": 1,
          "index.lifecycle.name": "kubernetes-logs-policy",
          "index.lifecycle.rollover_alias": "kubernetes-logs"
        },
        "mappings": {
          "properties": {
            "@timestamp": { "type": "date" },
            "log": { "type": "text" },
            "kubernetes": {
              "properties": {
                "pod_name": { "type": "keyword" },
                "namespace_name": { "type": "keyword" },
                "container_name": { "type": "keyword" },
                "node_name": { "type": "keyword" }
              }
            }
          }
        }
      }
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Políticas de retención según compliance</strong></p>
</div>
<div class="listingblock">
<div class="title">Retención por tipo de log:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Logs de aplicación:
- Retención: 30 días
- ILM: Hot (7d) → Warm (23d) → Delete (30d)
- Compresión: Sí (después de 7d)

Logs de auditoría (Kubernetes):
- Retención: 1 año (compliance)
- ILM: Hot (30d) → Warm (335d) → Delete (365d)
- Snapshot: Diarios a S3

Logs de seguridad (RBAC, network):
- Retención: 90 días (regulatory)
- ILM: Hot (14d) → Warm (76d) → Delete (90d)
- Alertas: Críticas (24h retention)

Logs de sistema:
- Retención: 14 días
- ILM: Hot (7d) → Delete (14d)
- Sampling: Después de 3d</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Automatizar purga de índices</strong></p>
</div>
<div class="listingblock">
<div class="title">CronJob para eliminar índices antiguos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: batch/v1
kind: CronJob
metadata:
  name: elasticsearch-cleanup
  namespace: logging
spec:
  # Ejecutar cada día a las 3 AM
  schedule: "0 3 * * *"
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: elasticsearch-cleanup
          containers:
          - name: cleanup
            image: curlimages/curl:7.85.0
            command:
            - /bin/sh
            - -c
            - |
              # Eliminar índices más antiguos de 90 días
              curl -X DELETE "elasticsearch.logging.svc.cluster.local:9200/kubernetes-$(date -d '90 days ago' +%Y.%m.%d)" \
                -u elastic:${ELASTICSEARCH_PASSWORD}

              # Ejecutar ILM manualmente
              curl -X POST "elasticsearch.logging.svc.cluster.local:9200/_ilm/move" \
                -H "Content-Type: application/json" \
                -u elastic:${ELASTICSEARCH_PASSWORD} \
                -d '{"sequence": 0, "phase": "delete"}'

            env:
            - name: ELASTICSEARCH_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: elasticsearch-credentials
                  key: password

          restartPolicy: OnFailure

---
# ServiceAccount y Role para cleanup
apiVersion: v1
kind: ServiceAccount
metadata:
  name: elasticsearch-cleanup
  namespace: logging

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: elasticsearch-cleanup
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get"]</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Monitoreo de almacenamiento</strong></p>
</div>
<div class="listingblock">
<div class="title">Verificar uso de disco en Elasticsearch:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Get cluster health
curl -X GET "elasticsearch.example.com:9200/_cluster/health" \
  -u elastic:password | jq '.'

# Get disk usage
curl -X GET "elasticsearch.example.com:9200/_cat/indices?v" \
  -u elastic:password | head -20

# Get node disk usage
curl -X GET "elasticsearch.example.com:9200/_cat/nodes?v&amp;h=node,disk.total,disk.used,disk.avail,disk.percent" \
  -u elastic:password

# Expand disk threshold alert
# Alert si algún nodo usa &gt; 85% del disco
curl -X PUT "elasticsearch.example.com:9200/_cluster/settings" \
  -u elastic:password \
  -H "Content-Type: application/json" \
  -d '{
    "transient": {
      "cluster.info.update.interval": "1m"
    }
  }'</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Best practices para logging</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Estructura de logs:
   - JSON siempre (más fácil de parsear)
   - Timestamps ISO 8601
   - Log levels: DEBUG, INFO, WARN, ERROR, FATAL
   - Context: pod, namespace, node, environment

2. Retención:
   - Compliance first (GDPR, HIPAA, SOC2)
   - Tier por importancia
   - Sampling para reducir volumen
   - Archive a S3/GCS después de N días

3. Performance:
   - Índices diarios (rollover automático)
   - Sharding apropiado (1-3 réplicas)
   - Disk I/O monitoring
   - Query optimization

4. Seguridad:
   - RBAC para acceso a índices
   - Encriptación en tránsito (TLS)
   - Enmascaramiento de datos sensibles
   - Audit trail de acceso

5. Costo:
   - Sampling de logs verbose
   - Compresión después de N días
   - Tiering a S3 (cheaper)
   - Eliminar logs no necesarios</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_6_3_troubleshooting">6.3 Troubleshooting</h3>
<div class="paragraph">
<p>Troubleshooting en Rancher y Kubernetes requiere una metodología sistemática para diagnosticar y resolver problemas rápidamente.</p>
</div>
<div class="sect3">
<h4 id="_diagnóstico_de_problemas_comunes">Diagnóstico de problemas comunes</h4>
<div class="paragraph">
<p><strong>Problemas con Pods</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 55. Tabla de estados de pods y causas:</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 33.3335%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Estado</th>
<th class="tableblock halign-left valign-top">Causa</th>
<th class="tableblock halign-left valign-top">Síntomas</th>
<th class="tableblock halign-left valign-top">Solución</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pending</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Recursos insuficientes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pod no se asigna a nodo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ver eventos, escalar nodes, ajustar requests</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ImagePullBackOff</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Imagen no disponible</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No puede descargar imagen</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Verificar nombre imagen, registry, secrets</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CrashLoopBackOff</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aplicación falla al iniciar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pods mueren y reinician</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ver logs, verificar probes, revisión de código</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NotReady</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Readiness probe falha</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pod no recibe tráfico</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ver logs de readiness, ajustar endpoint</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Terminating</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No termina gracefully</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tarda &gt;30s en terminar</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aumentar terminationGracePeriodSeconds</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Diagnosticar pod crashloopping</strong></p>
</div>
<div class="listingblock">
<div class="title">Pasos para resolver:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># 1. Ver estado del pod
kubectl describe pod myapp-xyz -n production

# Buscar:
# - Events: qué pasó recientemente
# - State: Current, Last State
# - Restart Count

# 2. Ver logs del contenedor
kubectl logs myapp-xyz -n production

# Si crashed, ver logs anteriores:
kubectl logs myapp-xyz -n production --previous

# Ver últimas N líneas
kubectl logs myapp-xyz -n production --tail=100

# Seguir logs en tiempo real
kubectl logs -f myapp-xyz -n production

# 3. Ejecutar comando en pod (si está running)
kubectl exec -it myapp-xyz -n production -- /bin/sh

# Dentro del pod:
ps aux          # Ver procesos
env             # Ver variables de entorno
cat /var/log/*  # Ver logs del sistema

# 4. Verificar readiness probe endpoint
kubectl exec myapp-xyz -n production -- curl http://localhost:8080/ready

# 5. Aumentar log level y reintentar
kubectl set env deployment/myapp LOG_LEVEL=debug -n production
kubectl rollout restart deployment/myapp -n production

# 6. Si todo falla, debuggear con alpine
kubectl debug pod/myapp-xyz -n production -it --image=alpine</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Problemas con Deployments</strong></p>
</div>
<div class="listingblock">
<div class="title">Diagnosticar rollout stuck:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver status del rollout
kubectl rollout status deployment/myapp -n production

# Ver historial de rollouts
kubectl rollout history deployment/myapp -n production

# Ver detalles de una revisión específica
kubectl rollout history deployment/myapp --revision=2 -n production

# Paused rollout?
kubectl get deployment myapp -n production -o yaml | grep -i paused

# Si está pausado, reanudar:
kubectl rollout resume deployment/myapp -n production

# Ver réplicas deseadas vs actuales
kubectl get deployment myapp -n production -o wide

# Buscar eventos de error
kubectl get events -n production --field-selector involvedObject.name=myapp --sort-by='.lastTimestamp'

# Debuggear replicaset
kubectl describe replicaset -l app=myapp -n production</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Problemas de networking</strong></p>
</div>
<div class="listingblock">
<div class="title">Diagnosticar conectividad entre pods:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># 1. ¿Pueden comunicarse dos pods?
# Pod A -&gt; Pod B:
kubectl exec -it &lt;pod-a&gt; -n ns-a -- \
  nc -zv &lt;pod-b-ip&gt; 8080

# O con curl:
kubectl exec -it &lt;pod-a&gt; -n ns-a -- \
  curl -v http://&lt;pod-b-ip&gt;:8080

# 2. Verificar Service discovery
kubectl exec -it &lt;pod-a&gt; -n ns-a -- \
  nslookup myservice.default.svc.cluster.local

# 3. Verificar iptables en nodo
kubectl debug node/&lt;node-name&gt; -it --image=ubuntu

# En la imagen ubuntu:
chroot /host
iptables -t nat -L -n | grep myservice
iptables -t filter -L -n

# 4. Verificar NetworkPolicy
kubectl get networkpolicy -A
kubectl describe networkpolicy &lt;name&gt; -n &lt;ns&gt;

# Testear NetworkPolicy:
kubectl exec -it &lt;pod&gt; -- curl http://other-service:8080

# 5. Ver endpoint del Service
kubectl get endpoints myservice -n default

# 6. Verificar CNI (calico, cilium)
kubectl get pods -n kube-system | grep -E 'calico|cilium|flannel'

# Ver logs de CNI
kubectl logs -n kube-system -l k8s-app=calico-node --tail=50</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Problemas de Storage</strong></p>
</div>
<div class="listingblock">
<div class="title">Diagnosticar PVC no bound:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># 1. Ver estado de PVC
kubectl describe pvc mydata -n production

# Buscar:
# - Phase: Bound | Pending | Lost
# - Events: por qué no está bound

# 2. Verificar que StorageClass existe
kubectl get storageclass

# 3. Verificar provisioner
kubectl get storageclass fast-ssd -o yaml

# 4. Ver PVs disponibles
kubectl get pv

# 5. Ver provisioner logs
kubectl logs -n default &lt;provisioner-pod&gt; --tail=100

# 6. Comprobar permisos RBAC
kubectl auth can-i create pvc --as=system:serviceaccount:production:default

# 7. Si es EBS/cloud storage, verificar:
# - Créditos de cloud
# - Región/zona correcta
# - Quotas no excedidas

# 8. Crear PVC manualmente para test:
kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test-pvc
  namespace: default
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: fast-ssd
  resources:
    requests:
      storage: 1Gi
EOF</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_herramientas_de_debugging">Herramientas de debugging</h4>
<div class="paragraph">
<p><strong>kubectl debug - Debuggear pods y nodos</strong></p>
</div>
<div class="listingblock">
<div class="title">Debuggear pod:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Crear pod de debug con imagen interactiva
kubectl debug pod/myapp -it --image=nicolaka/netshoot

# Dentro del pod debug:
# - curl, wget, telnet: networking
# - tcpdump, netstat, ss: network stats
# - strace, ltrace: system call tracing
# - ps, top: process monitoring
# - dig, nslookup: DNS resolution

# Verificar DNS:
dig myservice.default.svc.cluster.local

# Network connectivity test:
curl -v http://myservice:8080/health

# Check iptables:
iptables -L -n -t nat</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Debuggear nodo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Crear pod privilegiado en nodo
kubectl debug node/my-node -it --image=ubuntu

# Dentro de la imagen:
chroot /host

# Ver recursos del nodo
free -h              # Memoria
df -h                # Disco
top                  # Procesos
systemctl status kubelet
journalctl -u kubelet -n 100

# Ver networking del nodo
ip link show
ip addr show
ss -tlnp

# Ver cgroups (container limits)
ls /sys/fs/cgroup
cat /sys/fs/cgroup/memory/docker/*/memory.limit_in_bytes</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>k9s - Dashboard interactivo</strong></p>
</div>
<div class="paragraph">
<p>k9s es un terminal UI para Kubernetes que facilita la exploración.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Instalar k9s
brew install k9s  # macOS
wget https://github.com/derailed/k9s/releases/download/v0.28.4/k9s_Linux_amd64.tar.gz  # Linux
tar xf k9s_Linux_amd64.tar.gz

# Ejecutar
k9s

# Comandos en k9s:
:pods              # Ver pods
:nodes             # Ver nodos
:svc               # Ver servicios
:pvc               # Ver persistent volumes
:events            # Ver eventos

# Navegar:
- Arrow keys: navegar
- Enter: describe
- d: delete
- l: logs
- s: shell (exec)
- Port forward: :portforward

# Ejemplos:
1. Ir a :pods
2. Seleccionar pod
3. Press 'l' para ver logs
4. Press 's' para abrir shell
5. Press 'e' para editar</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Lens - IDE for Kubernetes</strong></p>
</div>
<div class="paragraph">
<p>Lens es un GUI potente para administrar clusters.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Descargar desde https://k8slens.dev
2. Conectar cluster:
   - Añadir cluster
   - Seleccionar kubeconfig
   - Conectar

3. Features:
   - Visual pod browser
   - Real-time metrics
   - Pod logs
   - Shell access
   - Resource editor
   - Network visualization
   - Helm integration

4. Pro features:
   - Multi-cluster
   - Cluster backup
   - Terminal access
   - Observability</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Prometheus + Grafana para debugging</strong></p>
</div>
<div class="listingblock">
<div class="title">Queries para debuggear:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text"># Pod que consume más CPU
topk(5, sum(rate(container_cpu_usage_seconds_total[5m])) by (pod_name))

# Pod que consume más memoria
topk(5, sum(container_memory_usage_bytes) by (pod_name))

# Pods con más restarts
topk(5, kube_pod_container_status_restarts_total)

# Pods pending
sum by (pod) (kube_pod_status_phase{phase="Pending"})

# Error rate por servicio
sum(rate(myapp_errors_total[5m])) by (service)

# Latencia p95 por endpoint
histogram_quantile(0.95, rate(myapp_request_duration_seconds_bucket[5m]))

# Network I/O por pod
sum(rate(container_network_receive_bytes_total[5m])) by (pod_name)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_análisis_de_rendimiento">Análisis de rendimiento</h4>
<div class="paragraph">
<p><strong>Identificar cuello de botella</strong></p>
</div>
<div class="listingblock">
<div class="title">Checklist de performance:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. CPU:
   - Top 5 pods por CPU
   - CPU throttling en containers
   - CPU requests vs usage

2. Memoria:
   - Pods con OOM kills
   - Memory pressure en nodos
   - Memory leaks (crecimiento)

3. Disco:
   - PVC usage &gt; 80%
   - Inode usage &gt; 90%
   - I/O latency

4. Red:
   - High packet loss
   - Network saturation
   - DNS latency &gt; 100ms

5. Aplicación:
   - Request latency (p95, p99)
   - Error rate
   - Garbage collection pauses
   - Database query time</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Profiling de aplicación</strong></p>
</div>
<div class="listingblock">
<div class="title">Python CPU profiling:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">import cProfile
import pstats
from io import StringIO

def slow_function():
    total = 0
    for i in range(1000000):
        total += i
    return total

# Profiling
pr = cProfile.Profile()
pr.enable()

slow_function()

pr.disable()
s = StringIO()
ps = pstats.Stats(pr, stream=s).sort_stats('cumulative')
ps.print_stats()
print(s.getvalue())

# Output mostrará:
# - ncalls: número de llamadas
# - tottime: tiempo total en función
# - cumtime: tiempo acumulado
# - callers: quién llamó</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Node.js CPU profiling:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">const v8Profiler = require('v8-profiler-next');

// Iniciar profiling
v8Profiler.startProfiling('profile', true);

// Tu código
setInterval(() =&gt; {
  // workload
}, 100);

// Después de tiempo
setTimeout(() =&gt; {
  const profile = v8Profiler.stopProfiling('profile');

  profile.export((err, result) =&gt; {
    require('fs').writeFileSync('profile.cpuprofile', result);
    profile.delete();
  });
}, 60000);

// Abrir profile.cpuprofile en Chrome DevTools</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Memory leak detection</strong></p>
</div>
<div class="listingblock">
<div class="title">Python memory leak:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Usar memory_profiler
pip install memory-profiler

# Anotar función
@profile
def my_function():
    x = [1] * (10 ** 6)
    y = [2] * (10 ** 6)
    return x + y

# Ejecutar con profiling
python -m memory_profiler script.py

# Output:
# Line #      Hits         Time  Per Hit   % Time  Line Contents
# 1           1       7391.0   7391.0     14.3  x = [1] * (10 ** 6)
# 2           1      14233.0  14233.0     27.6  y = [2] * (10 ** 6)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Docker container memory:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Monitorear memory en tiempo real
docker stats mycontainer

# Ver memory limit
docker inspect mycontainer | grep -i memory

# Ver memory usage por proceso dentro del container
docker exec mycontainer ps aux --sort -rss

# Si hay memory leak:
# 1. Limitaciones de heap (si es Java)
# 2. Connection pooling (database connections)
# 3. Cache no limpiad
# 4. Event listeners no removidos</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Load testing</strong></p>
</div>
<div class="listingblock">
<div class="title">Apache Bench:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Test simple
ab -n 1000 -c 10 http://myapp.example.com/

# Con custom headers
ab -n 1000 -c 50 -H "Authorization: Bearer token" http://myapp.example.com/api

# Output:
# - Requests per second
# - Time per request
# - Transfer rate
# - Percentiles de latencia</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">wrk (HTTP benchmarking):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Instalar
brew install wrk  # macOS
apt-get install build-essential &amp;&amp; git clone https://github.com/wg/wrk.git

# Test simple
wrk -t4 -c100 -d30s http://myapp.example.com/

# Con script Lua personalizado
cat &gt; script.lua &lt;&lt;EOF
request = function()
  return wrk.format(nil, "/api/users?id=" .. math.random(1, 100))
end
EOF

wrk -t4 -c100 -d30s -s script.lua http://myapp.example.com/

# Output:
# - Running 30s test
# - 4 threads
# - 100 connections
# - Latency distribution</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_estrategias_de_resolución_de_incidentes">Estrategias de resolución de incidentes</h4>
<div class="paragraph">
<p><strong>Runbook - Guía de resolución</strong></p>
</div>
<div class="listingblock">
<div class="title">Estructura de runbook:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text"># Incident: PersistentVolume Full

## Symptoms
- Application writes failing
- PVC usage &gt; 95%
- Disk full alerts firing

## Root Cause Possibilities
1. Application bug (unbounded logging)
2. Data not being cleaned up
3. PVC too small
4. Storage provisioning failed

## Diagnosis
1. Check PVC usage:
   kubectl get pvc
   kubectl describe pvc mydata

2. See what's using space:
   kubectl exec &lt;pod&gt; -- du -sh /*

3. Check logs:
   kubectl logs &lt;pod&gt; --all-containers

4. Check events:
   kubectl get events -n namespace --sort-by=.metadata.creationTimestamp

## Resolution

### Option A: Increase PVC size
- Edit PVC spec.resources.requests.storage
- Verify allowVolumeExpansion: true
- Monitor expansion progress

### Option B: Clean up data
- Identify old logs/files to delete
- Export/backup if needed
- Delete old data
- Monitor disk usage

### Option C: Enable autoscaling
- Set up script to monitor disk
- Trigger cleanup when &gt; 80%
- Or use managed cleanup policies

## Verification
- Check PVC usage dropped
- Verify application working
- Confirm alerts resolved

## Post-mortem
- Why wasn't this caught earlier?
- Need better monitoring?
- Need larger PVC?
- Need auto-cleanup?</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>War room process</strong></p>
</div>
<div class="listingblock">
<div class="title">Durante un incident:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. INITIAL RESPONSE (primeros 5 min)
   - Page on-call engineer
   - Create war room channel (#incidents)
   - Gather incident details
   - Timeline: When did it start?
   - Impact: What's affected?
   - Severity: P1 (critical) | P2 (major) | P3 (minor)

2. INVESTIGATION (siguiente 15 min)
   - Incident commander:
     * Leads investigation
     * Coordinates communication
     * Makes decisions

   - Technical leads:
     * Investigate specific areas
     * Update commander regularly
     * Try fixes under guidance

3. MITIGATION (15-60 min)
   - Options:
     a) Quick fix (rollback, restart)
     b) Workaround (scale down, traffic shift)
     c) Degraded service (partial functionality)
     d) Investigation (deeper, more time)

   - Execute fix:
     * Clear communication
     * Only one person makes changes
     * Monitor impact

4. RECOVERY (post-fix)
   - Verify impact resolved
   - Monitor for side effects
   - Check metrics normalizing

5. COMMUNICATION
   - Status page updates every 10 min
   - Slack updates hourly
   - Post-incident summary

6. POST-MORTEM (24-48 horas después)
   - What happened?
   - What was the root cause?
   - How do we prevent it?
   - Action items with owners
   - Timeline (when each happened)
   - Lessons learned</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Status page updates</strong></p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de update:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">INCIDENT: API service degradation
SEVERITY: P1 - Critical

2025-10-31 15:00 UTC
INVESTIGATING
- Users experiencing 500 errors on API
- Approximately 40% of traffic affected
- Investigation ongoing

2025-10-31 15:15 UTC
IDENTIFIED
- Root cause: Database connection pool exhausted
- Queries backing up in queue
- Connections not being released

2025-10-31 15:25 UTC
MITIGATING
- Restarting affected pods to clear connections
- Increasing connection pool size
- Reducing query timeout

2025-10-31 15:40 UTC
MONITORING
- 95% of traffic recovered
- Continuing to monitor
- Will send update in 30 min

2025-10-31 16:00 UTC
RESOLVED
- All traffic normalized
- Monitoring for recurrence
- Post-mortem scheduled for 2025-11-01 14:00 UTC</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Escalation policy</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Level 1: Initial on-call
- 30 min to engage L2
- 60 min to declare P1 if unresolved

Level 2: Senior engineer
- 30 min to engage L3
- 60 min to declare major issue

Level 3: Staff/Architecture
- Final escalation
- Customer communication
- Major decisions

Criteria for escalation:
- P1: Revenue impact, security, widespread
- P2: Significant impact to subsystem
- P3: Minor issues, workarounds available

Response times (SLA):
- P1: 15 min acknowledge, 30 min mitigation
- P2: 1 hour acknowledge, 4 hours resolution
- P3: 8 hours acknowledge, best effort</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Post-incident review template</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">Incident Report
===============

Date: 2025-10-31
Duration: 45 minutes (15:00 - 15:45 UTC)
Severity: P1 - Critical
Impact: 40% of API traffic, 5000+ affected users
Revenue Impact: ~$50K in lost transactions

Timeline
========
15:00 - Alerts start firing (500 errors)
15:05 - On-call notified
15:10 - War room opened
15:15 - Root cause identified (db connections)
15:25 - Mitigation started (pod restart)
15:40 - Service partially recovered
15:45 - Full recovery achieved

Root Cause
==========
Database connection pool exhausted due to:
- Query backlog during peak traffic
- Connections not being released due to timeout bug
- Bug introduced in deploy 3 hours earlier

Contributing Factors
====================
1. Insufficient monitoring on connection pool
2. Load test didn't simulate peak traffic
3. Rollback procedure not followed

Immediate Actions
=================
1. Revert problematic deploy (DONE)
2. Deploy connection pool fix (DONE)
3. Increase alerts on connection pool (IN PROGRESS)

Preventive Actions
===================
1. Add connection pool monitoring to dashboard
2. Improve load testing to simulate peak
3. Implement canary deployment process
4. Add pre-deployment checklist

Owners &amp; Due Dates
==================
- Monitoring: John Smith, 2025-11-07
- Load testing: Jane Doe, 2025-11-14
- Canary deployment: Bob Johnson, 2025-11-21</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Best practices para troubleshooting</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">1. Metodología:
   - Gather facts (no asumir)
   - Ask questions (why 5 times)
   - Test assumptions
   - Document process
   - Share learnings

2. Tooling:
   - Mantener herramientas actualizadas
   - Automatizar troubleshooting común
   - Integrar herramientas (Prometheus, etc.)
   - Dashboards por use-case

3. Comunicación:
   - Update frecuentes
   - Clear language (sin jargon)
   - Status page para users
   - Post-mortem abierto

4. Prevention:
   - Learn from incidents
   - Implement preventive measures
   - Test disaster scenarios
   - Regular game days</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Learn from incidents</p>
</li>
<li>
<p>Implement preventive measures</p>
</li>
<li>
<p>Test disaster scenarios</p>
</li>
<li>
<p>Regular game days</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre>== Módulo 7: Operaciones y Mantenimiento

=== 7.1 Backup y recuperación

Un plan de backup y recuperación robusto es fundamental para garantizar la continuidad del negocio y la protección de datos en Rancher y Kubernetes.

==== Estrategias de backup

**RTO y RPO - Objetivos de backup**

Dos conceptos críticos para definir la estrategia:

[cols="1,1,2", options="header"]
|===
|Métrica |Significado |Ejemplo

|RTO
|Recovery Time Objective
|¿Cuánto tiempo es aceptable de downtime?

|RPO
|Recovery Point Objective
|¿Cuántos datos podemos perder (max)?

|RTR
|Recovery Test Result
|¿Qué tan rápido se restaura en realidad?
|===

.Ejemplo de RTO/RPO:
[source,text]</pre>
</div>
</div>
<div class="paragraph">
<p>Aplicación crítica (ecommerce):
- RTO: 1 hora máximo
- RPO: 15 minutos (perder máx 15 min de datos)
- Requiere: Backups cada 15 min + replicación</p>
</div>
<div class="paragraph">
<p>Aplicación no crítica (analytics):
- RTO: 24 horas
- RPO: 1 día
- Requiere: Backup diario</p>
</div>
<div class="paragraph">
<p>Staging/Testing:
- RTO: N/A
- RPO: N/A
- Requiere: Backup semanal</p>
</div>
<div class="listingblock">
<div class="content">
<pre>**Niveles de backup**

[cols="1,2,2,1", options="header"]
|===
|Nivel |Qué se respalda |Caso de uso |Frecuencia

|etcd
|Estado del cluster
|Recoverable
|Cada 1 hora

|Aplicaciones
|Deployments, configs, datos
|Critical
|Cada 15 min

|Persistencia
|PVs, databases, files
|Critical
|Cada 1 hora

|Infraestructura
|IaC, Terraform, Helm
|Best practice
|Con cambios
|===

**Estrategias de ubicación de backup**

.3-2-1 rule (best practice):
[source,text]</pre>
</div>
</div>
<div class="paragraph">
<p>3 copias de datos:
- 1 original en cluster
- 2 copias de backup</p>
</div>
<div class="paragraph">
<p>2 formatos de almacenamiento:
- 1 local/rápido (para restauración rápida)
- 1 diferente (protección contra corrupción)</p>
</div>
<div class="paragraph">
<p>1 copia fuera de sitio:
- Almacenar en cloud/site diferente
- Protección contra desastres geográficos</p>
</div>
<div class="paragraph">
<p>Ejemplo implementación:
- Original: etcd en cluster Rancher
- Backup local: Longhorn snapshots (1 hora)
- Backup remoto: S3 (diario), cifrado
- Geo-replica: S3 replica en otra región</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Herramientas de backup

**Rancher Backup - Backup nativo**

Rancher Backup es la herramienta recomendada para backups del cluster.

.Instalar Rancher Backup:
[source,bash]</pre>
</div>
</div>
<div class="paragraph">
<p>helm repo add rancher-latest <a href="https://releases.rancher.com/server-charts/latest" class="bare">https://releases.rancher.com/server-charts/latest</a>
helm install rancher-backup rancher-latest/rancher-backup \
  --namespace cattle-system \
  --create-namespace \
  --set persistence.enabled=true \
  --set persistence.size=100Gi</p>
</div>
<div class="listingblock">
<div class="content">
<pre>.YAML BackupStorageLocation (S3):
[source,yaml]</pre>
</div>
</div>
<div class="paragraph">
<p>apiVersion: resources.cattle.io/v1
kind: BackupStorageLocation
metadata:
  name: s3-backup
  namespace: cattle-system
spec:
  s3:
    credentialSecret:
      name: aws-s3-credentials
      namespace: cattle-system
    bucket: rancher-backups
    region: us-west-2
    endpointURL: <a href="https://s3.amazonaws.com" class="bare">https://s3.amazonaws.com</a>
    insecureTLS: false
  provider: s3</p>
</div>
<hr>
<div class="paragraph">
<p>apiVersion: v1
kind: Secret
metadata:
  name: aws-s3-credentials
  namespace: cattle-system
type: Opaque
stringData:
  accessKey: AKIAIOSFODNN7EXAMPLE
  secretKey: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY</p>
</div>
<div class="listingblock">
<div class="content">
<pre>.YAML Backup Schedule (automático):
[source,yaml]</pre>
</div>
</div>
<div class="paragraph">
<p>apiVersion: resources.cattle.io/v1
kind: Backup
metadata:
  name: rancher-backup-daily
  namespace: cattle-system
spec:
  backupStorageLocation:
    name: s3-backup</p>
</div>
<div class="literalblock">
<div class="content">
<pre># Schedule en cron
schedule: "0 2 * * *"  # Cada día a las 2 AM</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># Retención
retention:
  days: 30        # Borrar backups &gt; 30 días
  maxBackups: 100  # Máximo 100 backups</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># Componentes a respaldar
resourceSet:
  desiredState: "all"</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># Encriptación
encryption:
  enabled: true
  secrets: true</pre>
</div>
</div>
<hr>
<div class="literalblock">
<div class="content">
<pre>  # Restore desde backup
apiVersion: resources.cattle.io/v1
kind: Restore
metadata:
  name: rancher-restore-from-backup
  namespace: cattle-system
spec:
  backupStorageLocation:
    name: s3-backup</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>backupName: rancher-backup-daily-20251031</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Restore selectivos
resourceSet:
  desiredState: "all"</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Wait for completion
prune: false</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>.Gestionar backups via CLI:
[source,bash]</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Ver backups disponibles
kubectl get backups -n cattle-system</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Ver detalles de backup
kubectl describe backup rancher-backup-daily-20251031 -n cattle-system</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Crear backup manual
kubectl apply -f - &lt;&lt;EOF
apiVersion: resources.cattle.io/v1
kind: Backup
metadata:
  name: manual-backup-now
  namespace: cattle-system
spec:
  backupStorageLocation:
    name: s3-backup
  resourceSet:
    desiredState: "all"
EOF</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Esperar a que se complete
kubectl wait --for=condition=Complete backup/manual-backup-now -n cattle-system --timeout=600s</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Ver backups en S3
aws s3 ls s3://rancher-backups/</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Descargar backup localmente
aws s3 cp s3://rancher-backups/rancher-backup-daily-20251031.tar.gz ./</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Ver contenido del backup
tar tzf rancher-backup-daily-20251031.tar.gz | head -50</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>**Velero - Backup para datos persistentes**

Velero es ideal para respaldar volúmenes persistentes y datos de aplicaciones.

.Instalar Velero:
[source,bash]</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Descargar Velero
wget https://github.com/vmware-tanzu/velero/releases/download/v1.13.0/velero-v1.13.0-linux-amd64.tar.gz
tar xzf velero-v1.13.0-linux-amd64.tar.gz
mv velero-v1.13.0-linux-amd64/velero /usr/local/bin/</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Crear credenciales AWS
cat &gt; credentials-velero &lt;&lt;EOF</pre>
</div>
</div>
<div class="paragraph">
<p>aws_access_key_id = AKIAIOSFODNN7EXAMPLE
aws_secret_access_key = wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
EOF</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Instalar Velero en cluster
velero install \
  --provider aws \
  --bucket velero-backups \
  --region us-west-2 \
  --secret-file ./credentials-velero \
  --use-volume-snapshots=true \
  --snapshot-location-provider aws \
  --volume-snapshot-location aws</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Verificar instalación
velero version
kubectl get pods -n velero</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>.YAML Schedule de Velero:
[source,yaml]</pre>
</div>
</div>
<div class="paragraph">
<p>apiVersion: velero.io/v1
kind: Schedule
metadata:
  name: daily-full-backup
  namespace: velero
spec:
  # Cronograma
  schedule: "0 2 * * *"  # Cada día a las 2 AM</p>
</div>
<div class="literalblock">
<div class="content">
<pre># Template para backups
template:
  includedNamespaces:
  - '*'  # Todos los namespaces</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>includedClusterResources:
- '*'  # Todos los recursos del cluster</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>storageLocation: aws-s3</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>volumeSnapshotLocation: aws-snapshots</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># Hooks (pre-backup cleanup, post-restore validation)
hooks:
  resources:
  - name: pre-backup-hook
    includedNamespaces:
    - production
    execOnPod:
      container: postgres
      command:
      - /bin/bash
      - -c
      - pg_dump mydb &gt; /tmp/backup.sql</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># TTL para expiración automática
ttl: 720h  # 30 días</pre>
</div>
</div>
<hr>
<div class="literalblock">
<div class="content">
<pre>  # Backup on-demand
apiVersion: velero.io/v1
kind: Backup
metadata:
  name: manual-backup-now
  namespace: velero
spec:
  includedNamespaces:
  - production</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>includedResources:
- deployments
- statefulsets
- persistentvolumeclaims</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>storageLocation: aws-s3
volumeSnapshotLocation: aws-snapshots</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># Exclude specific resources
excludedNamespaces:
- kube-system
- velero</pre>
</div>
</div>
<hr>
<div class="literalblock">
<div class="content">
<pre>  # Restore desde backup
apiVersion: velero.io/v1
kind: Restore
metadata:
  name: restore-from-backup
  namespace: velero
spec:
  backupName: daily-full-backup-20251031</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># Restore selectivo
includedNamespaces:
- production</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># Wait for completion
restorePVs: true
restoreStatus:
  includedResources:
  - pods</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># Restaurar a namespace diferente
namespaceMapping:
  production: production-restored</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>.Gestionar Velero via CLI:
[source,bash]</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Ver backups disponibles
velero backup get</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Crear backup manual
velero backup create manual-backup-now \
  --include-namespaces production</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Ver detalles de backup
velero backup describe manual-backup-now
velero backup logs manual-backup-now</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Listar snapshots
velero snapshot-location get</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Restaurar desde backup
velero restore create --from-backup daily-full-backup-20251031</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Ver restores
velero restore get</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Ver logs de restore
velero restore logs restore-daily-full-backup-20251031</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Eliminar backup antiguo
velero backup delete daily-full-backup-20250101</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Schedule diario
velero schedule create daily-backup \
  --schedule="0 2 * * *" \
  --include-namespaces='*' \
  --default-volumes-to-restic</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>**Longhorn - Snapshots y Backups distribuidos**

Si usa Longhorn StorageClass, puede aprovechar snapshots nativos.

.YAML Snapshot de Longhorn:
[source,yaml]</pre>
</div>
</div>
<div class="paragraph">
<p>apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: postgres-snapshot-001
  namespace: databases
spec:
  volumeSnapshotClassName: longhorn
  source:
    persistentVolumeClaimName: postgres-data</p>
</div>
<hr>
<div class="literalblock">
<div class="content">
<pre># Ver snapshots
# kubectl get volumesnapshot -n databases</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Restaurar desde snapshot
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-data-restored
  namespace: databases
spec:
  dataSource:
    name: postgres-snapshot-001
    kind: VolumeSnapshot
    apiGroup: snapshot.storage.k8s.io
  accessModes:
    - ReadWriteOnce
  storageClassName: longhorn
  resources:
    requests:
      storage: 100Gi</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Planes de recuperación de desastres

**Disaster Recovery Plan (DRP)**

.Componentes del DRP:
[source,text]</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ASSESSMENT</p>
<div class="ulist">
<ul>
<li>
<p>Identificar sistemas críticos</p>
</li>
<li>
<p>Definir RTO/RPO para cada sistema</p>
</li>
<li>
<p>Evaluación de riesgos</p>
</li>
</ul>
</div>
</li>
<li>
<p>MITIGATION</p>
<div class="ulist">
<ul>
<li>
<p>Geografía redundante</p>
</li>
<li>
<p>Multi-region deployment</p>
</li>
<li>
<p>Data replication</p>
</li>
<li>
<p>Network redundancy</p>
</li>
</ul>
</div>
</li>
<li>
<p>PREPARATION</p>
<div class="ulist">
<ul>
<li>
<p>Backups regulares</p>
</li>
<li>
<p>Procedimientos documentados</p>
</li>
<li>
<p>Team training</p>
</li>
<li>
<p>Runbooks preparados</p>
</li>
</ul>
</div>
</li>
<li>
<p>DETECTION</p>
<div class="ulist">
<ul>
<li>
<p>Alertas de anomalías</p>
</li>
<li>
<p>Monitoreo continuo</p>
</li>
<li>
<p>Pruebas periódicas</p>
</li>
</ul>
</div>
</li>
<li>
<p>RESPONSE</p>
<div class="ulist">
<ul>
<li>
<p>Escalation procedures</p>
</li>
<li>
<p>Communication plan</p>
</li>
<li>
<p>Recovery procedures</p>
</li>
<li>
<p>Status updates</p>
</li>
</ul>
</div>
</li>
<li>
<p>RECOVERY</p>
<div class="ulist">
<ul>
<li>
<p>Restore data</p>
</li>
<li>
<p>Validate integrity</p>
</li>
<li>
<p>Restore connectivity</p>
</li>
<li>
<p>Verify functionality</p>
</li>
</ul>
</div>
</li>
<li>
<p>LEARNING</p>
<div class="ulist">
<ul>
<li>
<p>Post-disaster review</p>
</li>
<li>
<p>Document lessons learned</p>
</li>
<li>
<p>Update procedures</p>
</li>
<li>
<p>Improve controls</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>**Multi-region backup strategy**

.Arquitectura recomendada:
[source,yaml]</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Región Primary (us-west-2)
apiVersion: resources.cattle.io/v1
kind: BackupStorageLocation
metadata:
  name: primary-s3
  namespace: cattle-system
spec:
  s3:
    bucket: rancher-backups-primary
    region: us-west-2
  provider: s3</pre>
</div>
</div>
<hr>
<div class="literalblock">
<div class="content">
<pre>  # Región Secondary (us-east-1) - Geo-replica
apiVersion: resources.cattle.io/v1
kind: BackupStorageLocation
metadata:
  name: dr-s3
  namespace: cattle-system
spec:
  s3:
    bucket: rancher-backups-dr
    region: us-east-1
  provider: s3</pre>
</div>
</div>
<hr>
<div class="literalblock">
<div class="content">
<pre>  # Backup job que replica a ambas regiones
apiVersion: batch/v1
kind: CronJob
metadata:
  name: backup-to-both-regions
  namespace: cattle-system
spec:
  schedule: "0 * * * *"  # Cada hora
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: backup-replicator
          containers:
          - name: backup-sync
            image: amazon/aws-cli:latest
            command:
            - /bin/sh
            - -c
            - |
              # Sync from primary to secondary
              aws s3 sync s3://rancher-backups-primary/ \
                s3://rancher-backups-dr/ \
                --region us-west-2 \
                --copy-props metadata \
                --storage-class STANDARD_IA
          restartPolicy: OnFailure</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>**Runbook: Disaster Recovery**

.Procedimiento de recuperación de desastres:
[source,text]</pre>
</div>
</div>
<div class="paragraph">
<p>SEVERITY: P1 - Critical System Down</p>
</div>
<div class="paragraph">
<p>&gt;&gt; DETECTION PHASE
1. Multiple alerts firing (multiple systems down)
2. Primary region unavailable
3. RTO timer starts</p>
</div>
<div class="paragraph">
<p>&gt;&gt; 0-5 MIN: INITIAL ASSESSMENT
- Confirm disaster scope
- Verify primary region is down
- Declare disaster
- Page all staff
- Open war room</p>
</div>
<div class="paragraph">
<p>&gt;&gt; 5-15 MIN: DECLARE FAILOVER
- Announce: "Switching to DR site"
- Notify management
- Notify customers (status page)
- Start disaster recovery runbook</p>
</div>
<div class="paragraph">
<p>&gt;&gt; 15-30 MIN: PROVISION DR ENVIRONMENT
- Provision new cluster in DR region
  * kubectl create cluster
  * Or use pre-provisioned standby</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Deploy networking</p>
<div class="ulist">
<ul>
<li>
<p>Load balancer in DR region</p>
</li>
<li>
<p>DNS failover (Route 53)</p>
</li>
<li>
<p>VPN/connectivity</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>&gt;&gt; 30-60 MIN: RESTORE FROM BACKUP
- Restore Rancher backup (from S3):
  velero restore create --from-backup latest</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Restore application data:</p>
</li>
<li>
<p>Velero restores PVs automatically</p>
</li>
<li>
<p>Or restore from DB replicas</p>
</li>
<li>
<p>Verify integrity:
kubectl get deployments -A
kubectl get statefulsets -A
kubectl get pvc -A</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>&gt;&gt; 60-90 MIN: VERIFY FUNCTIONALITY
- Health checks on all services
- Run smoke tests
- Check data consistency
- Verify connectivity</p>
</div>
<div class="paragraph">
<p>&gt;&gt; 90+ MIN: COMMUNICATE RECOVERY
- Update status page: "Services recovering"
- Update stakeholders
- Continue monitoring</p>
</div>
<div class="paragraph">
<p>&gt;&gt; POST-RECOVERY: ROOT CAUSE ANALYSIS
- What caused the disaster?
- How do we prevent it?
- Update DRP based on lessons learned</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Testing de restauración

**Disaster Recovery Drill (DRD)**

Los drills regulares garantizan que el plan funciona.

.Tabla de frecuencia de testing:
[cols="1,1,2,2", options="header"]
|===
|Tipo |Frecuencia |Scope |Duración

|Backup verification
|Semanal
|Verify backup integrity
|15 min

|Restore test
|Mensual
|Restore to staging
|1-2 horas

|Full DR drill
|Trimestral
|Full failover simulation
|4-8 horas

|Live DR drill
|Anual
|Actual failover (planeado)
|Varios días
|===

.Script de testing automático:
[source,bash]</pre>
</div>
</div>
<div class="paragraph">
<p>#!/bin/bash
# backup-verification.sh</p>
</div>
<div class="paragraph">
<p>set -e</p>
</div>
<div class="paragraph">
<p>BACKUP_STORAGE="s3://rancher-backups"
STAGING_CLUSTER="staging"</p>
</div>
<div class="paragraph">
<p>echo "=== Backup Verification ==="
echo "[$(date)] Starting backup verification"</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  # 1. Verificar que existen backups recientes
echo "[$(date)] Checking for recent backups..."
LATEST_BACKUP=$(aws s3 ls $BACKUP_STORAGE/ | tail -1 | awk '{print $4}')
BACKUP_AGE=$(($(date +%s) - $(date -d "$(aws s3 ls $BACKUP_STORAGE/$LATEST_BACKUP | head -1 | awk '{print $1, $2}')" +%s)))</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  if [ $BACKUP_AGE -gt 86400 ]; then  # 24 horas
  echo "[ERROR] Latest backup is older than 24 hours"
  exit 1
fi</pre>
</div>
</div>
<div class="paragraph">
<p>echo "[OK] Latest backup: $LATEST_BACKUP (age: ${BACKUP_AGE}s)"</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  # 2. Restaurar a cluster de staging
echo "[$(date)] Restoring to staging cluster..."
velero restore create test-restore-$(date +%s) \
  --from-backup $(basename $LATEST_BACKUP .tar.gz) \
  --wait</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # 3. Verificar restore completado
echo "[$(date)] Waiting for restore to complete..."
RESTORE_STATUS=$(velero restore get | grep test-restore | awk '{print $4}')</pre>
</div>
</div>
<div class="paragraph">
<p>if [ "$RESTORE_STATUS" != "Completed" ]; then
  echo "[ERROR] Restore failed with status: $RESTORE_STATUS"
  exit 1
fi</p>
</div>
<div class="paragraph">
<p>echo "[OK] Restore completed successfully"</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  # 4. Run smoke tests en staging
echo "[$(date)] Running smoke tests..."
kubectl exec -n production-staging deployment/app -- curl http://localhost:8080/health</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # 5. Verificar datos
echo "[$(date)] Verifying data..."
RECORD_COUNT=$(kubectl exec -n production-staging pod/postgres-0 -- \
  psql -U postgres -d myapp -c "SELECT COUNT(*) FROM users;" | tail -2 | head -1)</pre>
</div>
</div>
<div class="paragraph">
<p>echo "[OK] Data verification: $RECORD_COUNT records"</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  # 6. Cleanup
echo "[$(date)] Cleaning up staging..."
velero restore delete test-restore-*</pre>
</div>
</div>
<div class="paragraph">
<p>echo "[$(date)] Backup verification completed successfully"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>.Ejecutar testing automatizado:
[source,bash]</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Via cron (semanal)
cat &gt;&gt; /etc/cron.d/backup-verification &lt;&lt;EOF
0 3 * * 0 /usr/local/bin/backup-verification.sh &gt;&gt; /var/log/backup-verification.log 2&gt;&amp;1
EOF</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Monitorear resultados
tail -f /var/log/backup-verification.log</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  # Ver histórico de backups
ls -lah /backup-verification-*.log</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>**Restore test procedure**

.Procedimiento paso a paso:
[source,text]</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>PREPARATION (30 min antes)</p>
<div class="ulist">
<ul>
<li>
<p>Notify team</p>
</li>
<li>
<p>Create staging cluster (if needed)</p>
</li>
<li>
<p>Backup current state</p>
</li>
<li>
<p>Review runbook</p>
</li>
</ul>
</div>
</li>
<li>
<p>SETUP (0-15 min)</p>
<div class="ulist">
<ul>
<li>
<p>Start timer</p>
</li>
<li>
<p>Open war room</p>
</li>
<li>
<p>Record process</p>
</li>
<li>
<p>Baseline metrics</p>
</li>
</ul>
</div>
</li>
<li>
<p>RESTORE (15-45 min)</p>
<div class="ulist">
<ul>
<li>
<p>Download backup</p>
</li>
<li>
<p>Verify integrity (checksums)</p>
</li>
<li>
<p>Restore to staging</p>
</li>
<li>
<p>Monitor restore progress</p>
</li>
<li>
<p>Document issues</p>
</li>
</ul>
</div>
</li>
<li>
<p>VALIDATION (45-90 min)</p>
<div class="ulist">
<ul>
<li>
<p>Verify all pods running</p>
</li>
<li>
<p>Check data integrity</p>
</li>
<li>
<p>Run smoke tests</p>
</li>
<li>
<p>Performance testing</p>
</li>
<li>
<p>Document any gaps</p>
</li>
</ul>
</div>
</li>
<li>
<p>CLEANUP (90-120 min)</p>
<div class="ulist">
<ul>
<li>
<p>Delete test data</p>
</li>
<li>
<p>Document results</p>
</li>
<li>
<p>Create tickets for improvements</p>
</li>
</ul>
</div>
</li>
<li>
<p>REVIEW (post-test)</p>
<div class="ulist">
<ul>
<li>
<p>Team retrospective</p>
</li>
<li>
<p>What went well?</p>
</li>
<li>
<p>What failed?</p>
</li>
<li>
<p>Action items</p>
</li>
<li>
<p>Update procedures</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre>.Testing checklist:
[source,text]</pre>
</div>
</div>
<div class="paragraph">
<p>Pre-Test Checks:
[ ] Backup exists and is &lt; 24h old
[ ] Staging cluster has resources
[ ] Team members available
[ ] Network connectivity verified
[ ] Runbook reviewed</p>
</div>
<div class="paragraph">
<p>During Test:
[ ] Backup downloaded successfully
[ ] Restore started without errors
[ ] All resources recreated
[ ] Pods reached Running state
[ ] Services have endpoints
[ ] Data integrity verified
[ ] Application health checks pass
[ ] Network connectivity works
[ ] Performance acceptable</p>
</div>
<div class="paragraph">
<p>Post-Test:
[ ] All resources cleaned up
[ ] No failed pods remaining
[ ] Test logged and documented
[ ] Issues created for gaps
[ ] Team debriefing completed
[ ] Lessons learned documented</p>
</div>
<div class="listingblock">
<div class="content">
<pre>**Best practices para backup y DR**

[source,text]</pre>
</div>
</div>
<div class="paragraph">
<p>Operacional:
1. RTO/RPO definidos y comunicados
2. Backups validados regularmente (no falsos positivos)
3. Testing mensual de restauración
4. DR drill anual con failover real
5. Documentación actualizada</p>
</div>
<div class="paragraph">
<p>Technical:
1. Cifrado en tránsito y en reposo
2. Verificación de integridad (checksums)
3. Retención basada en regulaciones
4. Geo-distributed storage
5. Automated failover capabilities</p>
</div>
<div class="paragraph">
<p>Governance:
1. Change log de backups
2. Auditoría de acceso
3. Segregación de acceso (least privilege)
4. Políticas de retención documentadas
5. Regular compliance reviews</p>
</div>
<div class="paragraph">
<p>Comunicación:
1. RTO/RPO comunicado a stakeholders
2. Status page durante incidentes
3. Post-mortem after DR events
4. Training material actualizado
5. Runbooks accessible off-site</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== 7.2 Actualizaciones y upgrades

Las actualizaciones en Rancher deben planificarse cuidadosamente para minimizar disrupciones. Esta sección cubre estrategias de actualización, garantías de cero downtime, procedimientos de rollback y gestión de versiones.

==== Estrategias de actualización

Las estrategias de actualización definen cómo y cuándo se actualiza Rancher manteniendo la disponibilidad.

**Tipos de estrategias:**

.Comparación de estrategias de actualización:
[cols="1,2,2,2"]
|===
|Estrategia |Ventajas |Desventajas |Caso de uso

|Rolling Update
|Sin downtime, capacidad gradual
|Versiones múltiples en transición, complejidad
|Producción con alta disponibilidad

|Blue-Green
|Rollback instantáneo, fácil validación
|Requiere el doble de recursos
|Actualizaciones críticas

|Canary
|Riesgo mínimo, validación gradual
|Complejidad operacional, monitoreo intenso
|Cambios mayores, nuevas versiones

|Maintenance Window
|Simple, recursos mínimos
|Downtime planificado, afecta usuarios
|Desarrollo, entornos no-producción
|===

**Rolling Update (Recomendado):**

Actualiza nodos secuencialmente, manteniendo servicio disponible.

[source,yaml]</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rke2_cluster_con_rolling_update">RKE2 Cluster con Rolling Update</h2>
<div class="sectionbody">
<div class="paragraph">
<p>apiVersion: rke.rancher.io/v1
kind: RKE2Config
metadata:
  name: prod-cluster-rolling-update
spec:
  kubernetesVersion: v1.29.0</p>
</div>
<div class="literalblock">
<div class="content">
<pre>## Actualización Rolling
nodeDrainOptions:
  enabled: true
  timeout: 360s
  graceperiod: 30s
  skipWaitForDeleteTimeoutSeconds: 0
  deleteEmptyDirData: true
  ignoreDaemonsets: true
  ignoreErrors: false
  force: false</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>## Max nodes no disponibles
maxUnavailable: 1</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>## Máximo de nodos actualizándose
maxSurge: 0</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>## Worker node update strategy
workerNodeUpdateStrategy:
  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 1
    maxUnavailablePercentage: null
    maxSurgePercentage: null</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>## Control plane update strategy
controlPlaneNodeUpdateStrategy:
  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 0</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>## Drain policy
drainBeforeDelete: true
skipWaitForDeleteTimeoutSeconds: 0</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>**Blue-Green Deployment:**

Mantiene dos ambientes paralelos: uno activo (blue) y otro en standby (green).

[source,yaml]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_estrategia_blue_green_con_rancher">Estrategia Blue-Green con Rancher</h2>
<div class="sectionbody">
<div class="paragraph">
<p>apiVersion: v1
kind: Namespace
metadata:
  name: rancher-blue-green</p>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_blue_environment_actual">Blue Environment (actual)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>apiVersion: apps/v1
kind: Deployment
metadata:
  name: rancher-blue
  namespace: rancher-blue-green
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rancher
      environment: blue
  template:
    metadata:
      labels:
        app: rancher
        environment: blue
    spec:
      containers:
      - name: rancher
        image: rancher/rancher:v2.8.0
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 443
        livenessProbe:
          httpGet:
            path: /health
            port: 443
            scheme: HTTPS
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 443
            scheme: HTTPS
          initialDelaySeconds: 30
          periodSeconds: 5</p>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_green_environment_new_version_standby">Green Environment (new version - standby)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>apiVersion: apps/v1
kind: Deployment
metadata:
  name: rancher-green
  namespace: rancher-blue-green
spec:
  replicas: 0  <mark> Inicialmente escalado a 0
  selector:
    matchLabels:
      app: rancher
      environment: green
  template:
    metadata:
      labels:
        app: rancher
        environment: green
    spec:
      containers:
      - name: rancher
        image: rancher/rancher:v2.9.0  </mark> Nueva versión
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 443
        livenessProbe:
          httpGet:
            path: /health
            port: 443
            scheme: HTTPS
          initialDelaySeconds: 60
          periodSeconds: 10</p>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_service_que_apunta_a_blue_inicialmente">Service que apunta a Blue inicialmente</h2>
<div class="sectionbody">
<div class="paragraph">
<p>apiVersion: v1
kind: Service
metadata:
  name: rancher-traffic
  namespace: rancher-blue-green
spec:
  type: LoadBalancer
  selector:
    app: rancher
    environment: blue  ## Cambiar a 'green' durante cutover
  ports:
  - name: https
    port: 443
    targetPort: 443
    protocol: TCP</p>
</div>
<div class="listingblock">
<div class="content">
<pre>**Canary Deployment:**

Deploya la nueva versión a un pequeño porcentaje de usuarios primero.

[source,yaml]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_canary_deployment_con_istio_recomendado">Canary Deployment con Istio (recomendado)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: rancher-canary
spec:
  hosts:
  - rancher.example.com
  http:
  - match:
    - uri:
        prefix: "/canary"
    route:
    - destination:
        host: rancher
        subset: v2-canary
      weight: 100
  - route:
    - destination:
        host: rancher
        subset: v1-stable
      weight: 95
    - destination:
        host: rancher
        subset: v2-canary
      weight: 5</p>
</div>
<hr>
<div class="paragraph">
<p>apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: rancher-canary
spec:
  host: rancher
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http1MaxPendingRequests: 100
  subsets:
  - name: v1-stable
    labels:
      version: v2.8.0
  - name: v2-canary
    labels:
      version: v2.9.0</p>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Zero-Downtime Upgrades

Garantizar disponibilidad continua durante actualizaciones.

**Prerequisitos:**

* Múltiples réplicas de Rancher (mínimo 3)
* Almacenamiento persistente sincronizado
* Health checks configurados
* Monitores y alertas activos
* Plan de rollback documentado

**Procedimiento de Zero-Downtime:**

[source,bash]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_pre_upgrade_validation">Pre-upgrade validation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Pre-Upgrade Validation ==="
kubectl get nodes -o wide
kubectl get pods -n cattle-system -o wide
helm list -n cattle-system</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_snapshot_actual_para_rollback">Snapshot actual para rollback</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Creating pre-upgrade snapshot ==="
kubectl create namespace rancher-backup
kubectl apply -f - &lt;&lt;EOF
apiVersion: resources.cattle.io/v1
kind: Backup
metadata:
  name: pre-upgrade-backup-$(date +%Y%m%d-%H%M%S)
  namespace: rancher-backup
spec:
  backupStorageLocation:
    name: s3-backup
  resourceSet:
    desiredState: "all"
  encryption:
    enabled: true
EOF</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_esperar_a_que_se_complete_el_backup">Esperar a que se complete el backup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>kubectl wait --for=condition=Complete backup -n rancher-backup --timeout=600s</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_drain_nodos_worker_no_control_plane">Drain nodos worker (NO control plane)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Draining worker nodes ==="
for node in $(kubectl get nodes -l node-role.kubernetes.io/worker -o jsonpath='{.items[*].metadata.name}'); do
  echo "Draining $node&#8230;&#8203;"
  kubectl drain $node --ignore-daemonsets --delete-emptydir-data --pod-selector='app!=rancher' --timeout=600s
done</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_actualizar_rancher_via_helm">Actualizar Rancher via Helm</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Updating Rancher ==="
CURRENT_VERSION=$(helm list -n cattle-system -o json | jq -r '.[0].app_version')
NEW_VERSION="v2.9.0"</p>
</div>
<div class="paragraph">
<p>echo "Current version: $CURRENT_VERSION"
echo "New version: $NEW_VERSION"</p>
</div>
<div class="paragraph">
<p>helm repo update rancher-latest
helm upgrade rancher rancher-latest/rancher \
  --namespace cattle-system \
  --version ${NEW_VERSION} \
  --set hostname=rancher.example.com \
  --set replicas=3 \
  --set bootstrap.password=admin \
  --wait \
  --timeout=600s</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_verificar_rollout">Verificar rollout</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Monitoring rollout ==="
kubectl rollout status deployment/rancher -n cattle-system --timeout=600s
kubectl get pods -n cattle-system -o wide</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_verificar_health_de_rancher">Verificar health de Rancher</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Health check ==="
RANCHER_IP=$(kubectl get service -n cattle-system rancher -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
for i in {1..30}; do
  HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -k <a href="https://${RANCHER_IP}/health" class="bare">https://${RANCHER_IP}/health</a>)
  if [ "$HTTP_CODE" = "200" ]; then
    echo "✓ Rancher health check passed"
    break
  fi
  echo "Attempt $i/30: HTTP $HTTP_CODE"
  sleep 10
done</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_uncordon_worker_nodes">Uncordon worker nodes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Uncordoning worker nodes ==="
for node in $(kubectl get nodes -l node-role.kubernetes.io/worker -o jsonpath='{.items[*].metadata.name}'); do
  echo "Uncordoning $node&#8230;&#8203;"
  kubectl uncordon $node
done</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_validación_post_upgrade">Validación post-upgrade</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Post-upgrade validation ==="
kubectl get nodes -o wide
kubectl get pods -n cattle-system -o wide
kubectl top nodes
kubectl top pods -n cattle-system</p>
</div>
<div class="paragraph">
<p>echo "=== Upgrade completed successfully ==="</p>
</div>
<div class="listingblock">
<div class="content">
<pre>**Monitoreo durante actualización:**

[source,bash]</pre>
</div>
</div>
<div class="paragraph">
<p>#!/bin/bash
# Monitor zero-downtime upgrade progress</p>
</div>
<div class="paragraph">
<p>NAMESPACE="cattle-system"
DEPLOYMENT="rancher"</p>
</div>
<div class="paragraph">
<p>echo "Monitoring upgrade progress&#8230;&#8203;"
while true; do
  READY=$(kubectl get deployment $DEPLOYMENT -n $NAMESPACE -o jsonpath='{.status.readyReplicas}')
  DESIRED=$(kubectl get deployment $DEPLOYMENT -n $NAMESPACE -o jsonpath='{.spec.replicas}')
  UPDATED=$(kubectl get deployment $DEPLOYMENT -n $NAMESPACE -o jsonpath='{.status.updatedReplicas}')</p>
</div>
<div class="literalblock">
<div class="content">
<pre>TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
echo "[$TIMESTAMP] Ready: $READY/$DESIRED | Updated: $UPDATED | Status: $(kubectl get deployment $DEPLOYMENT -n $NAMESPACE -o jsonpath='{.status.conditions[?(@.type=="Progressing")].message}')"</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>if [ "$READY" = "$DESIRED" ] &amp;&amp; [ "$UPDATED" = "$DESIRED" ]; then
  echo "✓ Upgrade complete!"
  break
fi</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  sleep 5
done</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>==== Rollback Procedures

Procedimiento rápido para revertir a versión anterior si hay problemas.

**Niveles de rollback:**

1. **Inmediato (&lt; 1 minuto)**: Blue-Green deployment
2. **Rápido (&lt; 5 minutos)**: Helm rollback
3. **Completo (&lt; 30 minutos)**: Restore from backup

**Rollback via Helm:**

[source,bash]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ver_histórico_de_releases">Ver histórico de releases</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Helm release history ==="
helm history rancher -n cattle-system</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rollback_a_la_release_anterior">Rollback a la release anterior</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Rolling back to previous version ==="
PREVIOUS_RELEASE=$(helm history rancher -n cattle-system -o json | \
  jq -r 'sort_by(.revision) | .[-2].revision')</p>
</div>
<div class="paragraph">
<p>helm rollback rancher $PREVIOUS_RELEASE -n cattle-system --wait --timeout=600s</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_verificar_rollback">Verificar rollback</h2>
<div class="sectionbody">
<div class="paragraph">
<p>kubectl rollout status deployment/rancher -n cattle-system --timeout=600s</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_validación_post_rollback">Validación post-rollback</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Post-rollback validation ==="
kubectl get pods -n cattle-system
kubectl get deployment rancher -n cattle-system -o jsonpath='{.spec.template.spec.containers[0].image}'</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_test_connectivity">Test connectivity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RANCHER_IP=$(kubectl get service -n cattle-system rancher -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
curl -k -s <a href="https://${RANCHER_IP}/health" class="bare">https://${RANCHER_IP}/health</a> | jq .</p>
</div>
<div class="listingblock">
<div class="content">
<pre>**Rollback desde backup:**

[source,bash]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_listar_backups_disponibles">Listar backups disponibles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Available backups ==="
kubectl get backups -n rancher-backup -o wide</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_seleccionar_backup_pre_upgrade">Seleccionar backup pre-upgrade</h2>
<div class="sectionbody">
<div class="paragraph">
<p>BACKUP_NAME="pre-upgrade-backup-20251031-143022"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_crear_restore_job">Crear restore job</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Creating restore ==="
kubectl apply -f - &lt;&lt;EOF
apiVersion: resources.cattle.io/v1
kind: Restore
metadata:
  name: restore-from-${BACKUP_NAME}
  namespace: rancher-backup
spec:
  backupStorageLocation:
    name: s3-backup
  backupName: ${BACKUP_NAME}
  resourceSet:
    desiredState: "all"
EOF</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_monitorear_restore">Monitorear restore</h2>
<div class="sectionbody">
<div class="paragraph">
<p>echo "=== Monitoring restore ==="
kubectl wait --for=condition=Complete restore/restore-from-${BACKUP_NAME} \
  -n rancher-backup --timeout=1200s</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_verificar_estado">Verificar estado</h2>
<div class="sectionbody">
<div class="paragraph">
<p>kubectl get restore -n rancher-backup -o wide
kubectl describe restore restore-from-${BACKUP_NAME} -n rancher-backup</p>
</div>
<div class="listingblock">
<div class="content">
<pre>**Checklist de rollback:**

[cols="1,3,1"]
|===
|Item |Descripción |Estado

|Backup Pre-Upgrade
|Backup completado antes de actualización
|☐

|Helm History
|Verificar releases anteriores disponibles
|☐

|Test Rollback
|Ejecutar rollback en ambiente test
|☐

|Communication
|Notificar a stakeholders
|☐

|Ejecutar Rollback
|Rollback Helm o Restore
|☐

|Validación
|Verificar health y funcionalidad
|☐

|Post-Mortem
|Documentar causa y lecciones
|☐
|===

==== Gestión de versiones

Estrategia integral de versionado para Rancher, Kubernetes y componentes.

**Matriz de compatibilidad:**

[cols="1,2,2,2"]
|===
|Rancher Version |Min K8s |Max K8s |RKE2 Version

|v2.8.x
|v1.27
|v1.28
|v1.28.x

|v2.9.0
|v1.28
|v1.29
|v1.29.x

|v3.0.0 (beta)
|v1.29
|v1.31
|v1.31.x
|===

**Planificación de versiones:**

[source,yaml]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_version_management_planning_document">Version management planning document</h2>
<div class="sectionbody">
<div class="paragraph">
<p>apiVersion: v1
kind: ConfigMap
metadata:
  name: rancher-version-plan
  namespace: cattle-system
data:
  current-version: "v2.8.5"
  target-version: "v2.9.0"</p>
</div>
<div class="literalblock">
<div class="content">
<pre>kubernetes-upgrade-plan: |
  Phase 1: K8s v1.28.0 -&gt; v1.28.3 (patch)
  Phase 2: K8s v1.28.3 -&gt; v1.29.0 (minor)
  Phase 3: Rancher v2.8.5 -&gt; v2.9.0 (minor)
  Phase 4: Component updates</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>support-timeline: |
  v2.8.x: Maintenance until 2026-01-01
  v2.9.x: Active support until 2027-01-01
  v3.0.x: Early adopter until GA</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>testing-checklist: |
  - Unit tests
  - Integration tests
  - End-to-end tests
  - Performance tests
  - Security scanning
  - Backup/restore validation
  - Upgrade/downgrade validation</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>**Política de versiones recomendada:**

* **Major Version (X.0.0)**: Ruptura de compatibilidad, planificación detallada requerida
* **Minor Version (X.Y.0)**: Nuevas características, compatibilidad mantenida, ≥3 meses entre versiones
* **Patch Version (X.Y.Z)**: Bugfixes y security patches, aplicar dentro de 2 semanas

**Ciclo de vida de versiones:**

.Version Lifecycle:
[cols="1,2,3"]
|===
|Fase |Duración |Acción

|Early Access
|2-4 semanas
|Testing beta, feedback recolectado

|General Availability (GA)
|12 meses
|Soporte full, updates regulares

|Maintenance
|6 meses
|Solo security patches

|End of Life (EOL)
|Post-EOL
|Sin soporte
|===

**Herramientas de versionado:**

[source,bash]</pre>
</div>
</div>
<div class="paragraph">
<p><mark>!/bin/bash
#</mark> Version management utility</p>
</div>
<div class="paragraph">
<p>show_versions() {
  echo "=== Current Versions ==="
  echo "Rancher: $(helm list -n cattle-system -o json | jq -r '.[0].app_version')"
  echo "Kubernetes: $(kubectl version --short | grep Server | awk '{print $3}')"
  echo "RKE2: $(cat /etc/rancher/rke2/version.txt 2&gt;/dev/null || echo 'N/A')"
  echo "Docker: $(docker version --format '{{.Server.Version}}' 2&gt;/dev/null || echo 'N/A')"
  echo "Helm: $(helm version --short)"
}</p>
</div>
<div class="paragraph">
<p>check_compatibility() {
  RANCHER_VERSION=$1
  K8S_VERSION=$2</p>
</div>
<div class="literalblock">
<div class="content">
<pre>## Verificar matriz de compatibilidad
case "$RANCHER_VERSION" in
  v2.8.*)
    if [[ "$K8S_VERSION" =~ ^v1\.(27|28) ]]; then
      echo "✓ Compatible"
      return 0
    fi
    ;;
  v2.9.*)
    if [[ "$K8S_VERSION" =~ ^v1\.(28|29) ]]; then
      echo "✓ Compatible"
      return 0
    fi
    ;;
esac</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>  echo "✗ Incompatible"
  return 1
}</pre>
</div>
</div>
<div class="paragraph">
<p>get_upgrade_path() {
  CURRENT=$1
  TARGET=$2</p>
</div>
<div class="literalblock">
<div class="content">
<pre>  echo "Upgrade path from $CURRENT to $TARGET:"
  echo "1. Test in staging environment"
  echo "2. Create pre-upgrade backup"
  echo "3. Plan maintenance window"
  echo "4. Execute upgrade with monitoring"
  echo "5. Validate all components"
  echo "6. Monitor for 24 hours"
}</pre>
</div>
</div>
<div class="paragraph">
<p>show_versions
check_compatibility v2.9.0 v1.29.0
get_upgrade_path v2.8.5 v2.9.0</p>
</div>
<div class="listingblock">
<div class="content">
<pre>=== 7.3 Performance y optimización

Optimizar el rendimiento de Rancher y sus cargas de trabajo requiere monitoreo continuo, rightsizing de recursos y análisis de capacidad. Esta sección cubre optimización de recursos, troubleshooting de performance, capacity planning y cost monitoring.

==== Optimización de recursos

Garantizar que Rancher y las aplicaciones reciban suficientes recursos sin exceso de provisión.

**Configuración de requests y limits:**

[source,yaml]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rancher_deployment_con_resource_requestslimits_optimizados">Rancher Deployment con resource requests/limits optimizados</h2>
<div class="sectionbody">
<div class="paragraph">
<p>apiVersion: apps/v1
kind: Deployment
metadata:
  name: rancher
  namespace: cattle-system
spec:
  replicas: 3
  selector:
    matchLabels:
      app: rancher
  template:
    metadata:
      labels:
        app: rancher
    spec:
      containers:
      - name: rancher
        image: rancher/rancher:v2.8.5
        imagePullPolicy: IfNotPresent</p>
</div>
<div class="literalblock">
<div class="content">
<pre>## Requests: mínimo garantizado
resources:
  requests:
    memory: "2Gi"
    cpu: "1000m"
  ## Limits: máximo permitido
  limits:
    memory: "4Gi"
    cpu: "2000m"</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>## Probes para evitar restart innecesarios
livenessProbe:
  httpGet:
    path: /health
    port: 443
    scheme: HTTPS
  initialDelaySeconds: 60
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>readinessProbe:
  httpGet:
    path: /health
    port: 443
    scheme: HTTPS
  initialDelaySeconds: 30
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>## Affinity rules para distribuir pods
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app
            operator: In
            values:
            - rancher
        topologyKey: kubernetes.io/hostname</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>**Resource Quotas por Namespace:**

[source,yaml]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_resourcequota_para_limitar_uso_en_namespaces">ResourceQuota para limitar uso en namespaces</h2>
<div class="sectionbody">
<div class="paragraph">
<p>apiVersion: v1
kind: ResourceQuota
metadata:
  name: rancher-quotas
  namespace: cattle-system
spec:
  hard:
    requests.memory: "16Gi"
    requests.cpu: "8"
    limits.memory: "32Gi"
    limits.cpu: "16"
    pods: "50"
    services: "10"
    persistentvolumeclaims: "5"</p>
</div>
<hr>
</div>
</div>
<div class="sect1">
<h2 id="_limitrange_para_defaults_en_pods">LimitRange para defaults en pods</h2>
<div class="sectionbody">
<div class="paragraph">
<p>apiVersion: v1
kind: LimitRange
metadata:
  name: rancher-limits
  namespace: cattle-system
spec:
  limits:
  - type: Pod
    max:
      memory: "8Gi"
      cpu: "4"
    min:
      memory: "256Mi"
      cpu: "100m"
    default:
      memory: "1Gi"
      cpu: "500m"
    defaultRequest:
      memory: "512Mi"
      cpu: "250m"
  - type: Container
    max:
      memory: "4Gi"
      cpu: "2"
    min:
      memory: "128Mi"
      cpu: "50m"
    default:
      memory: "512Mi"
      cpu: "250m"
    defaultRequest:
      memory: "256Mi"
      cpu: "100m"</p>
</div>
<div class="listingblock">
<div class="content">
<pre>**Horizontal Pod Autoscaling (HPA):**

[source,yaml]</pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hpa_basado_en_cpu_y_memoria">HPA basado en CPU y memoria</h2>
<div class="sectionbody">
<div class="paragraph">
<p>apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: rancher-hpa
  namespace: cattle-system
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: rancher</p>
</div>
<div class="literalblock">
<div class="content">
<pre>minReplicas: 3
maxReplicas: 10</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>metrics:
- type: Resource
  resource:
    name: cpu
    target:
      type: Utilization
      averageUtilization: 70</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>type: Resource
resource:
  name: memory
  target:
    type: Utilization
    averageUtilization: 80</p>
<div class="literalblock">
<div class="content">
<pre>behavior:
  scaleDown:
    stabilizationWindowSeconds: 300
    policies:
    - type: Percent
      value: 50
      periodSeconds: 60
  scaleUp:
    stabilizationWindowSeconds: 0
    policies:
    - type: Percent
      value: 100
      periodSeconds: 30
    - type: Pods
      value: 2
      periodSeconds: 60
    selectPolicy: Max</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_7_3_1_troubleshooting_de_performance">7.3.1 Troubleshooting de performance</h3>
<div class="paragraph">
<p>Identificar y resolver cuellos de botella de rendimiento.</p>
</div>
<div class="paragraph">
<p><strong>Herramientas de profiling:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
## Performance troubleshooting utilities

check_resources() {
  echo "=== Rancher Pod Resources ==="
  kubectl get pods -n cattle-system rancher-* \
    -o custom-columns=NAME:.metadata.name,\
CPU_REQ:.spec.containers[0].resources.requests.cpu,\
CPU_LIM:.spec.containers[0].resources.limits.cpu,\
MEM_REQ:.spec.containers[0].resources.requests.memory,\
MEM_LIM:.spec.containers[0].resources.limits.memory

  echo ""
  echo "=== Current Usage ==="
  kubectl top pods -n cattle-system --containers=true
}

check_latency() {
  echo "=== API Server Latency ==="
  kubectl get --raw /metrics | grep apiserver_request_duration_seconds | head -10
}

check_memory() {
  echo "=== Node Memory Status ==="
  kubectl describe nodes | grep -A 5 "Allocated resources"
}

check_disk() {
  echo "=== Node Disk Pressure ==="
  kubectl describe nodes | grep -A 3 "DiskPressure\|InodesFree\|PIDPressure"
}

check_etcd() {
  echo "=== Etcd Commit Duration ==="
  kubectl get --raw /metrics | grep etcd_disk_backend_commit_duration
}

check_resources
check_latency
check_memory
check_disk
check_etcd</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Análisis de bottlenecks:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
## Bottleneck detection script

analyze_rancher_performance() {
  local NAMESPACE="cattle-system"

  echo "=== Rancher Performance Analysis ==="

  ## CPU throttling
  echo ""
  echo "CPU Throttling:"
  kubectl get --raw /metrics | grep container_cpu_cfs_throttled_seconds | \
    grep cattle-system | head -5

  ## Memory OOM
  echo ""
  echo "Memory OOM Events:"
  kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp' | grep OOMKilled

  ## Pod evictions
  echo ""
  echo "Pod Evictions:"
  kubectl get events -n $NAMESPACE --sort-by='.lastTimestamp' | grep Evicted

  ## Network latency
  echo ""
  echo "Network Performance:"
  for pod in $(kubectl get pods -n $NAMESPACE -l app=rancher -o jsonpath='{.items[0].metadata.name}'); do
    kubectl exec -it $pod -n $NAMESPACE -- ping -c 3 localhost
  done

  ## Disk I/O
  echo ""
  echo "Disk I/O Performance:"
  kubectl exec -it $(kubectl get pods -n $NAMESPACE -l app=rancher -o jsonpath='{.items[0].metadata.name}') \
    -n $NAMESPACE -- df -h
}

analyze_rancher_performance</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Profiling de aplicaciones:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">## ServiceMonitor para capturar métricas de Rancher
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: rancher-metrics
  namespace: cattle-system
spec:
  selector:
    matchLabels:
      app: rancher
  endpoints:
  - port: metrics
    interval: 30s
    scrapeTimeout: 10s
    path: /metrics
    scheme: https
    tlsConfig:
      insecureSkipVerify: true

---
## PrometheusRule para alertas de performance
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: rancher-performance-alerts
  namespace: cattle-system
spec:
  groups:
  - name: rancher.performance
    interval: 30s
    rules:
    - alert: RancherHighCPUUsage
      expr: 'rate(container_cpu_usage_seconds_total{pod=~"rancher-.*",namespace="cattle-system"}[5m]) &gt; 1.5'
      for: 5m
      annotations:
        summary: "Rancher high CPU usage"
        description: "Pod {{ $labels.pod }} is consuming {{ $value }} CPUs"

    - alert: RancherHighMemoryUsage
      expr: 'container_memory_working_set_bytes{pod=~"rancher-.*",namespace="cattle-system"} / container_spec_memory_limit_bytes &gt; 0.8'
      for: 5m
      annotations:
        summary: "Rancher high memory usage"
        description: "Pod {{ $labels.pod }} is at {{ $value }}% memory"

    - alert: RancherAPILatency
      expr: 'histogram_quantile(0.95, apiserver_request_duration_seconds_bucket) &gt; 1'
      for: 5m
      annotations:
        summary: "High API latency"
        description: "95th percentile latency is {{ $value }}s"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_7_3_2_capacity_planning">7.3.2 Capacity planning</h3>
<div class="paragraph">
<p>Planificar el crecimiento futuro y escalabilidad.</p>
</div>
<div class="paragraph">
<p><strong>Forecasting de recursos:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
## Capacity planning analysis

forecast_resources() {
  echo "=== Resource Capacity Planning ==="

  ## Recopilar datos históricos (últimos 30 días)
  THIRTY_DAYS_AGO=$(date -d "30 days ago" +%s)

  ## Promedio de uso CPU
  echo ""
  echo "&gt;&gt; CPU Average Usage (30 days):"
  kubectl get --raw "/api/v1/query?query=avg(rate(container_cpu_usage_seconds_total{namespace=\"cattle-system\",pod=~\"rancher-.*\"}[5m])) by (pod)" | jq .

  ## Promedio de uso memoria
  echo ""
  echo "&gt;&gt; Memory Average Usage (30 days):"
  kubectl get --raw "/api/v1/query?query=avg(container_memory_working_set_bytes{namespace=\"cattle-system\",pod=~\"rancher-.*\"}) by (pod)" | jq .

  ## Proyección a 90 días
  echo ""
  echo "&gt;&gt; Projected Usage at 90 days:"
  echo "Assuming 10% monthly growth:"
  echo "- CPU: 10% increase per month"
  echo "- Memory: 10% increase per month"
  echo "- Storage: 15% increase per month"
}

forecast_resources</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Matriz de capacidad:</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 22.2222%;">
<col style="width: 22.2222%;">
<col style="width: 22.2222%;">
<col style="width: 22.2223%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Escala</th>
<th class="tableblock halign-left valign-top">Min Nodes</th>
<th class="tableblock halign-left valign-top">Min CPU</th>
<th class="tableblock halign-left valign-top">Min Memory</th>
<th class="tableblock halign-left valign-top">Min Storage</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Desarrollo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1-3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4 cores</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">50 GB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Producción Pequeña</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3-5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16 cores</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">200 GB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Producción Media</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5-10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">32 cores</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64 GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">500 GB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Producción Grande</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">64+ cores</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128+ GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1+ TB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Producción Enterprise</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128+ cores</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">256+ GB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5+ TB</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p><strong>Planificación de escalado:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">## ClusterAutoscaler para scaling automático de nodos
apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-autoscaler-config
  namespace: kube-system
data:
  nodes.max: "100"
  nodes.min: "3"
  scale-down-enabled: "true"
  scale-down-delay-after-add: "10m"
  scale-down-unneeded-time: "10m"
  scale-down-unready-time: "20m"
  max-node-provision-time: "15m"
  max-total-unready-percentage: "45"
  ok-total-unready-count: "3"
  max-graceful-termination-sec: "600"

---
## Vertical Pod Autoscaler para optimizar requests/limits
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: rancher-vpa
  namespace: cattle-system
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind: Deployment
    name: rancher
  updatePolicy:
    updateMode: "Auto"  ## auto, recreate, off
  resourcePolicy:
    containerPolicies:
    - containerName: "*"
      minAllowed:
        cpu: 500m
        memory: "512Mi"
      maxAllowed:
        cpu: "4"
        memory: "4Gi"
      controlledResources: ["cpu", "memory"]
      controlledValues: RequestsAndLimits</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_7_3_3_cost_monitoring">7.3.3 Cost monitoring</h3>
<div class="paragraph">
<p>Monitorear y optimizar costos de infraestructura.</p>
</div>
<div class="paragraph">
<p><strong>Herramientas de cost analysis:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">#!/bin/bash
## Cost monitoring and analysis

## 1. Calcular costo por recurso
calculate_resource_cost() {
  echo "=== Resource Cost Calculation ==="

  ## Precios de ejemplo (AWS)
  CPU_COST_PER_HOUR=0.05  ## $0.05 per CPU per hour
  MEMORY_COST_PER_GB=0.01  ## $0.01 per GB per hour

  ## Obtener recursos actuales
  TOTAL_CPU=$(kubectl get nodes -o jsonpath='{.items[*].status.allocatable.cpu}' | \
    sed 's/m//g' | awk '{s+=$1} END {print s/1000}')
  TOTAL_MEMORY=$(kubectl get nodes -o jsonpath='{.items[*].status.allocatable.memory}' | \
    sed 's/Ki//g' | awk '{s+=$1} END {print s/1024/1024}')

  echo "Total CPU: $TOTAL_CPU cores"
  echo "Total Memory: $TOTAL_MEMORY GB"

  ## Calcular costos
  CPU_COST=$(echo "$TOTAL_CPU * $CPU_COST_PER_HOUR" | bc)
  MEMORY_COST=$(echo "$TOTAL_MEMORY * $MEMORY_COST_PER_GB" | bc)
  HOURLY_COST=$(echo "$CPU_COST + $MEMORY_COST" | bc)
  MONTHLY_COST=$(echo "$HOURLY_COST * 730" | bc)
  YEARLY_COST=$(echo "$MONTHLY_COST * 12" | bc)

  echo ""
  echo "Hourly cost: \$$HOURLY_COST"
  echo "Monthly cost: \$$MONTHLY_COST"
  echo "Yearly cost: \$$YEARLY_COST"
}

## 2. Identificar recursos desperdiciados
find_wasted_resources() {
  echo ""
  echo "=== Unused Resources Detection ==="

  ## Pods con muy bajo uso
  echo "&gt;&gt; Pods using &lt; 10% of requested resources:"
  kubectl get pods --all-namespaces -o json | jq -r '.items[] |
    select(.spec.containers[].resources.requests.cpu != null) |
    "\(.metadata.namespace)/\(.metadata.name)"'

  ## PVCs no usados
  echo ""
  echo "&gt;&gt; Unused PersistentVolumeClaims:"
  kubectl get pvc --all-namespaces -o json | jq -r '.items[] |
    select(.metadata.annotations."pv-used-by" == null) |
    "\(.metadata.namespace)/\(.metadata.name) - \(.spec.resources.requests.storage)"'
}

## 3. RI/Savings Plans análisis
show_commitment_savings() {
  echo ""
  echo "=== Reserved Instance Savings Analysis ==="
  echo "On-Demand vs RI (1-year): 30-40% savings"
  echo "On-Demand vs RI (3-year): 50-70% savings"
  echo ""
  echo "Recomendación: Usar RIs para cargas estables (control plane, base nodes)"
  echo "Usar On-Demand o Spot para cargas variables"
}

calculate_resource_cost
find_wasted_resources
show_commitment_savings</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cost allocation tags:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">## ResourceQuota with cost labels
apiVersion: v1
kind: Namespace
metadata:
  name: production
  labels:
    cost-center: "engineering"
    environment: "production"
    team: "platform"
    project: "rancher"

---
## Pod con cost tracking labels
apiVersion: v1
kind: Pod
metadata:
  name: rancher-app
  namespace: production
  labels:
    app: rancher
    cost-center: "engineering"
    environment: "production"
    team: "platform"
    version: "v2.8.5"
  annotations:
    cost.allocation/team: "platform"
    cost.allocation/project: "rancher"
    cost.allocation/environment: "production"
spec:
  containers:
  - name: rancher
    image: rancher/rancher:v2.8.5
    resources:
      requests:
        memory: "2Gi"
        cpu: "1000m"
      limits:
        memory: "4Gi"
        cpu: "2000m"</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Dashboard de costos:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">## Prometheus query para costos
apiVersion: v1
kind: ConfigMap
metadata:
  name: cost-metrics-queries
  namespace: monitoring
data:
  hourly-cost: |
    sum(
      sum(rate(container_cpu_usage_seconds_total[5m])) * 0.05 +
      sum(container_memory_working_set_bytes / 1024 / 1024 / 1024) * 0.01
    )

  namespace-cost: |
    sum by (namespace) (
      sum(rate(container_cpu_usage_seconds_total{pod!=""}[5m])) by (pod, namespace) * 0.05 +
      sum(container_memory_working_set_bytes{pod!=""} / 1024 / 1024 / 1024) by (pod, namespace) * 0.01
    )

  pod-cost: |
    sum by (pod, namespace) (
      sum(rate(container_cpu_usage_seconds_total[5m])) * 0.05 +
      sum(container_memory_working_set_bytes / 1024 / 1024 / 1024) * 0.01
    )</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Recomendaciones de optimización de costos:</strong></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 28.5714%;">
<col style="width: 42.8571%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Estrategia</th>
<th class="tableblock halign-left valign-top">Descripción</th>
<th class="tableblock halign-left valign-top">Impacto</th>
<th class="tableblock halign-left valign-top">Esfuerzo</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rightsizing</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ajustar requests/limits a uso real</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15-25% reducción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bajo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reserved Instances</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Comprar RIs para cargas estables</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">30-50% reducción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Medio</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spot Instances</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Usar Spot para cargas no-críticas</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">60-90% reducción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Medio</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Auto-scaling</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Escalar down recursos no-utilizados</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20-30% reducción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Medio</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cost Allocation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Rastrear y optimizar por equipo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10-20% reducción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bajo</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scheduler Optimization</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mejorar bin packing de pods</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15-30% reducción</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Alto</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_recursos_adicionales">Recursos Adicionales</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentación_oficial">Documentación oficial</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://ranchermanager.docs.rancher.com/">Documentación de Rancher Manager</a></p>
</li>
<li>
<p><a href="https://rancherfederal.docs.rancher.com/">Rancher Government Documentation</a></p>
</li>
<li>
<p><a href="https://github.com/rancherfederal/rancher">Rancher Federal GitHub</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_comunidades_y_soporte">Comunidades y soporte</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://forums.rancher.com/">Foros de Rancher</a></p>
</li>
<li>
<p><a href="https://slack.rancher.io/">Slack Community</a></p>
</li>
<li>
<p><a href="https://www.suse.com/support/">Soporte SUSE</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_certificaciones">Certificaciones</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.suse.com/training/certification/">Certificaciones SUSE</a></p>
</li>
<li>
<p><a href="https://www.rancher.com/training/">Rancher Training</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_herramientas_recomendadas">Herramientas recomendadas</h3>
<div class="ulist">
<ul>
<li>
<p>kubectl, helm, k9s</p>
</li>
<li>
<p>Docker Desktop, Lens</p>
</li>
<li>
<p>Prometheus, Grafana</p>
</li>
<li>
<p>Velero, Longhorn</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-10-31 08:16:40 +0100
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>