<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.26">
<title>Curso de Kubernetes</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child{border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock pre>code{display:block}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active,#footnotes .footnote a:first-of-type:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Curso de Kubernetes</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_módulo_1_introducción_a_kubernetes">Módulo 1: Introducción a Kubernetes</a>
<ul class="sectlevel2">
<li><a href="#_fundamentos_de_orquestación_de_contenedores">Fundamentos de orquestación de contenedores</a></li>
<li><a href="#_historia_y_evolución_de_kubernetes">Historia y evolución de Kubernetes</a></li>
<li><a href="#_arquitectura_y_componentes_principales">Arquitectura y componentes principales</a></li>
<li><a href="#_ventajas_y_casos_de_uso">Ventajas y casos de uso</a></li>
<li><a href="#_diferencias_con_docker_swarm_y_otras_plataformas">Diferencias con Docker Swarm y otras plataformas</a></li>
</ul>
</li>
<li><a href="#_módulo_2_configuración_del_entorno">Módulo 2: Configuración del Entorno</a>
<ul class="sectlevel2">
<li><a href="#_instalación_de_kubernetes_local_y_cloud">Instalación de Kubernetes (local y cloud)</a></li>
<li><a href="#_minikube_kind_y_k3s_para_desarrollo">Minikube, Kind y K3s para desarrollo</a></li>
<li><a href="#_configuración_de_kubectl">Configuración de kubectl</a></li>
<li><a href="#_primeros_comandos_básicos">Primeros comandos básicos</a></li>
<li><a href="#_explorando_el_dashboard_de_kubernetes">Explorando el dashboard de Kubernetes</a></li>
</ul>
</li>
<li><a href="#_módulo_3_objetos_básicos_de_kubernetes">Módulo 3: Objetos Básicos de Kubernetes</a>
<ul class="sectlevel2">
<li><a href="#_pods_unidad_básica_de_despliegue">Pods: unidad básica de despliegue</a>
<ul class="sectlevel3">
<li><a href="#_ciclo_de_vida_de_un_pod">Ciclo de vida de un pod</a></li>
<li><a href="#_estados_de_un_pod">Estados de un pod</a></li>
<li><a href="#_gestión_de_pods">Gestión de pods</a></li>
<li><a href="#_labels_y_annotations">Labels y Annotations</a></li>
</ul>
</li>
<li><a href="#_replicasets_y_controladores_de_replicación">ReplicaSets y controladores de replicación</a>
<ul class="sectlevel3">
<li><a href="#_ciclo_de_vida_de_un_replicaset">Ciclo de vida de un ReplicaSet</a></li>
<li><a href="#_estados_de_un_replicaset">Estados de un ReplicaSet</a></li>
<li><a href="#_gestión_de_replicasets">Gestión de ReplicaSets</a></li>
</ul>
</li>
<li><a href="#_deployments_gestión_de_actualizaciones">Deployments: gestión de actualizaciones</a>
<ul class="sectlevel3">
<li><a href="#_ciclo_de_vida_de_un_deployment">Ciclo de vida de un Deployment</a></li>
<li><a href="#_estados_de_un_deployment">Estados de un Deployment</a></li>
<li><a href="#_gestión_de_deployments">Gestión de Deployments</a></li>
</ul>
</li>
<li><a href="#_statefulsets_gestión_de_aplicaciones_con_estado">StatefulSets: gestión de aplicaciones con estado</a>
<ul class="sectlevel3">
<li><a href="#_características_principales_de_los_statefulsets">Características principales de los StatefulSets</a></li>
<li><a href="#_casos_de_uso_típicos">Casos de uso típicos</a></li>
<li><a href="#_ejemplo_de_manifiesto_yaml_para_statefulset">Ejemplo de manifiesto YAML para StatefulSet</a></li>
<li><a href="#_comandos_útiles_para_gestionar_statefulsets">Comandos útiles para gestionar StatefulSets</a></li>
<li><a href="#_buenas_prácticas_con_statefulsets">Buenas prácticas con StatefulSets</a></li>
<li><a href="#_resumen_gráfico">Resumen gráfico</a></li>
</ul>
</li>
<li><a href="#_daemonsets_ejecución_de_pods_en_todos_los_nodos">DaemonSets: ejecución de pods en todos los nodos</a>
<ul class="sectlevel3">
<li><a href="#_características_principales_de_los_daemonsets">Características principales de los DaemonSets</a></li>
<li><a href="#_casos_de_uso_típicos_2">Casos de uso típicos</a></li>
<li><a href="#_ejemplo_de_manifiesto_yaml_para_daemonset">Ejemplo de manifiesto YAML para DaemonSet</a></li>
<li><a href="#_comandos_útiles_para_gestionar_daemonsets">Comandos útiles para gestionar DaemonSets</a></li>
<li><a href="#_buenas_prácticas_con_daemonsets">Buenas prácticas con DaemonSets</a></li>
</ul>
</li>
<li><a href="#_jobs_y_cronjobs_ejecución_de_tareas_puntuales_y_programadas">Jobs y CronJobs: ejecución de tareas puntuales y programadas</a>
<ul class="sectlevel3">
<li><a href="#_características_principales_de_los_jobs">Características principales de los Jobs</a></li>
<li><a href="#_ejemplo_básico_de_job">Ejemplo básico de Job</a></li>
<li><a href="#_ejemplo_de_job_con_múltiples_ejecuciones_y_concurrencia">Ejemplo de Job con múltiples ejecuciones y concurrencia</a></li>
<li><a href="#_indexed_jobs">Indexed Jobs</a></li>
<li><a href="#_características_principales_de_los_cronjobs">Características principales de los CronJobs</a></li>
<li><a href="#_ejemplo_básico_de_cronjob">Ejemplo básico de CronJob</a></li>
<li><a href="#_ejemplo_de_cronjob_con_backup_de_base_de_datos">Ejemplo de CronJob con backup de base de datos</a></li>
<li><a href="#_buenas_prácticas_con_jobs_y_cronjobs">Buenas prácticas con Jobs y CronJobs</a></li>
<li><a href="#_resumen_gráfico_2">Resumen gráfico</a></li>
</ul>
</li>
<li><a href="#_services_comunicación_entre_componentes">Services: comunicación entre componentes</a>
<ul class="sectlevel3">
<li><a href="#_tipos_de_servicios">Tipos de servicios</a></li>
<li><a href="#_ciclo_de_vida_de_un_service">Ciclo de vida de un Service</a></li>
<li><a href="#_características_principales_de_los_services">Características principales de los Services</a></li>
<li><a href="#_gestión_de_services">Gestión de Services</a></li>
<li><a href="#_endpoints_y_descubrimiento_de_servicios">Endpoints y descubrimiento de servicios</a></li>
<li><a href="#_proxies_y_balanceo_de_carga">Proxies y balanceo de carga</a></li>
<li><a href="#_dns_interno_de_kubernetes">DNS interno de Kubernetes</a></li>
<li><a href="#_exposición_de_servicios_al_exterior">Exposición de servicios al exterior</a></li>
<li><a href="#_ingress_gestión_de_tráfico_http">Ingress: gestión de tráfico HTTP</a></li>
<li><a href="#_ingress_controllers">Ingress Controllers</a></li>
<li><a href="#_configuración_de_ingress">Configuración de Ingress</a></li>
<li><a href="#_buenas_prácticas_para_servicios">Buenas prácticas para servicios</a></li>
</ul>
</li>
<li><a href="#_namespaces_organización_lógica">Namespaces: organización lógica</a></li>
</ul>
</li>
<li><a href="#_módulo_4_conceptos_avanzados_de_pods_y_recursos">Módulo 4: Conceptos Avanzados de Pods y Recursos</a>
<ul class="sectlevel2">
<li><a href="#_init_containers">Init Containers</a>
<ul class="sectlevel3">
<li><a href="#_características_de_los_init_containers">Características de los Init Containers</a></li>
<li><a href="#_casos_de_uso_comunes">Casos de uso comunes</a></li>
<li><a href="#_ejemplo_de_init_container">Ejemplo de Init Container</a></li>
<li><a href="#_verificación_del_estado_de_init_containers">Verificación del estado de Init Containers</a></li>
<li><a href="#_buenas_prácticas">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_health_checks_probes_en_kubernetes">Health Checks: Probes en Kubernetes</a>
<ul class="sectlevel3">
<li><a href="#_tipos_de_probes">Tipos de Probes</a></li>
<li><a href="#_métodos_de_verificación">Métodos de verificación</a></li>
<li><a href="#_liveness_probe">Liveness Probe</a></li>
<li><a href="#_readiness_probe">Readiness Probe</a></li>
<li><a href="#_startup_probe">Startup Probe</a></li>
<li><a href="#_parámetros_de_configuración">Parámetros de configuración</a></li>
<li><a href="#_buenas_prácticas_2">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_gestión_de_recursos_requests_y_limits">Gestión de Recursos: Requests y Limits</a>
<ul class="sectlevel3">
<li><a href="#_requests_vs_limits">Requests vs Limits</a></li>
<li><a href="#_ejemplo_de_requests_y_limits">Ejemplo de requests y limits</a></li>
<li><a href="#_unidades_de_medida">Unidades de medida</a></li>
<li><a href="#_qos_classes_quality_of_service">QoS Classes (Quality of Service)</a></li>
<li><a href="#_limitrange">LimitRange</a></li>
<li><a href="#_resourcequota">ResourceQuota</a></li>
<li><a href="#_buenas_prácticas_3">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_pod_scheduling_avanzado">Pod Scheduling Avanzado</a>
<ul class="sectlevel3">
<li><a href="#_nodeselector">NodeSelector</a></li>
<li><a href="#_node_affinity">Node Affinity</a></li>
<li><a href="#_pod_affinity_y_anti_affinity">Pod Affinity y Anti-Affinity</a></li>
<li><a href="#_taints_y_tolerations">Taints y Tolerations</a></li>
<li><a href="#_casos_de_uso_comunes_2">Casos de uso comunes</a></li>
<li><a href="#_buenas_prácticas_4">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_pod_disruption_budgets_pdb">Pod Disruption Budgets (PDB)</a>
<ul class="sectlevel3">
<li><a href="#_qué_son_las_disrupciones_voluntarias">¿Qué son las disrupciones voluntarias?</a></li>
<li><a href="#_ejemplo_de_pdb">Ejemplo de PDB</a></li>
<li><a href="#_verificar_estado_de_pdb">Verificar estado de PDB</a></li>
<li><a href="#_buenas_prácticas_5">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_priorityclass">PriorityClass</a>
<ul class="sectlevel3">
<li><a href="#_creación_de_priorityclass">Creación de PriorityClass</a></li>
<li><a href="#_uso_de_priorityclass_en_pods">Uso de PriorityClass en Pods</a></li>
<li><a href="#_priorityclasses_del_sistema">PriorityClasses del sistema</a></li>
<li><a href="#_preemption">Preemption</a></li>
<li><a href="#_buenas_prácticas_6">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_security_context">Security Context</a>
<ul class="sectlevel3">
<li><a href="#_security_context_a_nivel_de_pod">Security Context a nivel de Pod</a></li>
<li><a href="#_security_context_a_nivel_de_container">Security Context a nivel de Container</a></li>
<li><a href="#_opciones_principales">Opciones principales</a></li>
<li><a href="#_ejemplo_de_pod_seguro">Ejemplo de pod seguro</a></li>
<li><a href="#_buenas_prácticas_7">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_tipos_de_volúmenes">Tipos de Volúmenes</a>
<ul class="sectlevel3">
<li><a href="#_emptydir">emptyDir</a></li>
<li><a href="#_hostpath">hostPath</a></li>
<li><a href="#_configmap_y_secret_como_volúmenes">configMap y secret como volúmenes</a></li>
<li><a href="#_downwardapi">downwardAPI</a></li>
<li><a href="#_projected">projected</a></li>
<li><a href="#_buenas_prácticas_para_volúmenes">Buenas prácticas para volúmenes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_5_configuración_de_aplicaciones">Módulo 5: Configuración de Aplicaciones</a>
<ul class="sectlevel2">
<li><a href="#_configmaps_y_secrets">ConfigMaps y Secrets</a>
<ul class="sectlevel3">
<li><a href="#_configmaps">ConfigMaps</a></li>
<li><a href="#_secrets">Secrets</a></li>
</ul>
</li>
<li><a href="#_variables_de_entorno">Variables de entorno</a></li>
<li><a href="#_gestión_de_configuraciones">Gestión de configuraciones</a></li>
<li><a href="#_montaje_de_volúmenes_de_configuración">Montaje de volúmenes de configuración</a></li>
<li><a href="#_buenas_prácticas_para_configuraciones">Buenas prácticas para configuraciones</a></li>
</ul>
</li>
<li><a href="#_módulo_6_almacenamiento_en_kubernetes">Módulo 6: Almacenamiento en Kubernetes</a>
<ul class="sectlevel2">
<li><a href="#_conceptos_de_almacenamiento_persistente">Conceptos de almacenamiento persistente</a></li>
<li><a href="#_persistentvolumes_y_persistentvolumeclaims">PersistentVolumes y PersistentVolumeClaims</a></li>
<li><a href="#_storageclasses">StorageClasses</a></li>
<li><a href="#_administración_de_volúmenes">Administración de volúmenes</a></li>
<li><a href="#_soluciones_de_almacenamiento_para_kubernetes">Soluciones de almacenamiento para Kubernetes</a></li>
</ul>
</li>
<li><a href="#_módulo_7_redes_en_kubernetes">Módulo 7: Redes en Kubernetes</a>
<ul class="sectlevel2">
<li><a href="#_modelo_de_red_de_kubernetes">Modelo de red de Kubernetes</a>
<ul class="sectlevel3">
<li><a href="#_principios_básicos">Principios básicos</a></li>
<li><a href="#_componentes_principales">Componentes principales</a></li>
<li><a href="#_plugins_de_red_cni">Plugins de red (CNI)</a></li>
<li><a href="#_ejemplo_de_comunicación">Ejemplo de comunicación</a></li>
<li><a href="#_resumen_gráfico_3">Resumen gráfico</a></li>
</ul>
</li>
<li><a href="#_proxies_y_balanceadores_de_carga">Proxies y balanceadores de carga</a>
<ul class="sectlevel3">
<li><a href="#_qué_es_un_proxy">¿Qué es un proxy?</a></li>
<li><a href="#_qué_es_un_balanceador_de_carga">¿Qué es un balanceador de carga?</a></li>
<li><a href="#_tipos_de_proxies_y_balanceadores_en_kubernetes">Tipos de proxies y balanceadores en Kubernetes</a></li>
<li><a href="#_ejemplo_de_flujo_de_tráfico">Ejemplo de flujo de tráfico</a></li>
<li><a href="#_ventajas_de_usar_proxies_y_balanceadores">Ventajas de usar proxies y balanceadores</a></li>
<li><a href="#_resumen_gráfico_4">Resumen gráfico</a></li>
</ul>
</li>
<li><a href="#_políticas_de_red_en_kubernetes">Políticas de red en Kubernetes</a>
<ul class="sectlevel3">
<li><a href="#_qué_es_una_networkpolicy">¿Qué es una NetworkPolicy?</a></li>
<li><a href="#_cómo_funcionan_las_networkpolicies">¿Cómo funcionan las NetworkPolicies?</a></li>
<li><a href="#_ejemplo_didáctico_permitir_solo_tráfico_de_frontend_a_backend">Ejemplo didáctico: Permitir solo tráfico de frontend a backend</a></li>
<li><a href="#_ejemplo_avanzado_permitir_tráfico_de_salida_solo_a_internet">Ejemplo avanzado: Permitir tráfico de salida solo a Internet</a></li>
<li><a href="#_buenas_prácticas_8">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_ingress_controllers_2">Ingress Controllers</a>
<ul class="sectlevel3">
<li><a href="#_qué_es_un_ingress_controller">¿Qué es un Ingress Controller?</a></li>
<li><a href="#_tipos_de_ingress_controllers">Tipos de Ingress Controllers</a></li>
<li><a href="#_ejemplo_despliegue_de_nginx_ingress_controller">Ejemplo: Despliegue de NGINX Ingress Controller</a></li>
<li><a href="#_ejemplo_de_recurso_ingress">Ejemplo de recurso Ingress</a></li>
<li><a href="#_funcionamiento_general">Funcionamiento general</a></li>
<li><a href="#_buenas_prácticas_9">Buenas prácticas</a></li>
<li><a href="#_resumen_gráfico_5">Resumen gráfico</a></li>
</ul>
</li>
<li><a href="#_service_mesh">Service Mesh</a>
<ul class="sectlevel3">
<li><a href="#_por_qué_usar_un_service_mesh">¿Por qué usar un Service Mesh?</a></li>
<li><a href="#_arquitectura_de_un_service_mesh">Arquitectura de un Service Mesh</a></li>
<li><a href="#_ejemplo_despliegue_básico_de_istio">Ejemplo: Despliegue básico de Istio</a></li>
<li><a href="#_funcionalidades_clave_de_un_service_mesh">Funcionalidades clave de un Service Mesh</a></li>
<li><a href="#_ejemplo_de_observabilidad_con_istio">Ejemplo de observabilidad con Istio</a></li>
<li><a href="#_otros_service_mesh_populares">Otros Service Mesh populares</a></li>
<li><a href="#_buenas_prácticas_10">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_exposición_de_servicios_al_exterior_2">Exposición de servicios al exterior</a>
<ul class="sectlevel3">
<li><a href="#_opciones_principales_para_exponer_servicios">Opciones principales para exponer servicios</a></li>
<li><a href="#_ejemplo_de_service_tipo_nodeport">Ejemplo de Service tipo NodePort</a></li>
<li><a href="#_ejemplo_de_service_tipo_loadbalancer">Ejemplo de Service tipo LoadBalancer</a></li>
<li><a href="#_ejemplo_de_exposición_usando_ingress">Ejemplo de exposición usando Ingress</a></li>
<li><a href="#_ejemplo_de_service_tipo_externalname">Ejemplo de Service tipo ExternalName</a></li>
<li><a href="#_buenas_prácticas_11">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_8_escalabilidad_y_alta_disponibilidad">Módulo 8: Escalabilidad y Alta Disponibilidad</a>
<ul class="sectlevel2">
<li><a href="#_escalado_horizontal_de_pods_hpa">Escalado horizontal de pods (HPA)</a>
<ul class="sectlevel3">
<li><a href="#_cómo_funciona_el_hpa">¿Cómo funciona el HPA?</a></li>
<li><a href="#_ejemplo_paso_a_paso">Ejemplo paso a paso</a></li>
<li><a href="#_buenas_prácticas_12">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_escalado_vertical">Escalado vertical</a>
<ul class="sectlevel3">
<li><a href="#_cómo_funciona_el_vpa">¿Cómo funciona el VPA?</a></li>
<li><a href="#_ejemplo_de_despliegue_de_vpa">Ejemplo de despliegue de VPA</a></li>
<li><a href="#_comandos_útiles">Comandos útiles</a></li>
<li><a href="#_buenas_prácticas_13">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_actualizaciones_sin_tiempo_de_inactividad">Actualizaciones sin tiempo de inactividad</a>
<ul class="sectlevel3">
<li><a href="#_cómo_funcionan_las_actualizaciones_sin_downtime">¿Cómo funcionan las actualizaciones sin downtime?</a></li>
<li><a href="#_ejemplo_de_deployment_con_estrategia_de_rolling_update">Ejemplo de Deployment con estrategia de rolling update</a></li>
<li><a href="#_proceso_de_actualización_paso_a_paso">Proceso de actualización paso a paso</a></li>
<li><a href="#_buenas_prácticas_14">Buenas prácticas</a></li>
<li><a href="#_ejemplo_de_probes_en_el_deployment">Ejemplo de probes en el Deployment</a></li>
</ul>
</li>
<li><a href="#_estrategias_de_despliegue_avanzadas">Estrategias de despliegue avanzadas</a>
<ul class="sectlevel3">
<li><a href="#_bluegreen_deployment">Blue/Green Deployment</a></li>
<li><a href="#_canary_deployment">Canary Deployment</a></li>
<li><a href="#_ab_testing">A/B Testing</a></li>
<li><a href="#_buenas_prácticas_15">Buenas prácticas</a></li>
<li><a href="#_resumen_gráfico_6">Resumen gráfico</a></li>
</ul>
</li>
<li><a href="#_autoscaling_basado_en_métricas">Autoscaling basado en métricas</a>
<ul class="sectlevel3">
<li><a href="#_tipos_de_autoscaling_en_kubernetes">Tipos de autoscaling en Kubernetes</a></li>
<li><a href="#_ejemplo_de_hpa_basado_en_cpu_y_memoria">Ejemplo de HPA basado en CPU y memoria</a></li>
<li><a href="#_autoscaling_con_métricas_personalizadas">Autoscaling con métricas personalizadas</a></li>
<li><a href="#_cluster_autoscaler">Cluster Autoscaler</a></li>
<li><a href="#_buenas_prácticas_16">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_9_seguridad_en_kubernetes">Módulo 9: Seguridad en Kubernetes</a>
<ul class="sectlevel2">
<li><a href="#_rbac_control_de_acceso_basado_en_roles">RBAC (Control de Acceso Basado en Roles)</a>
<ul class="sectlevel3">
<li><a href="#_conceptos_clave">Conceptos clave</a></li>
<li><a href="#_ejemplo_básico_de_role_y_rolebinding">Ejemplo básico de Role y RoleBinding</a></li>
<li><a href="#_ejemplo_de_clusterrole_y_clusterrolebinding">Ejemplo de ClusterRole y ClusterRoleBinding</a></li>
<li><a href="#_buenas_prácticas_17">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_service_accounts">Service Accounts</a>
<ul class="sectlevel3">
<li><a href="#_para_qué_se_usan_las_service_accounts">¿Para qué se usan las Service Accounts?</a></li>
<li><a href="#_ejemplo_de_creación_y_uso_de_una_service_account">Ejemplo de creación y uso de una Service Account</a></li>
<li><a href="#_buenas_prácticas_18">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_network_policies">Network Policies</a>
<ul class="sectlevel3">
<li><a href="#_qué_es_una_networkpolicy_2">¿Qué es una NetworkPolicy?</a></li>
<li><a href="#_cómo_funcionan_las_networkpolicies_2">¿Cómo funcionan las NetworkPolicies?</a></li>
<li><a href="#_ejemplo_básico_permitir_solo_tráfico_de_frontend_a_backend">Ejemplo básico: Permitir solo tráfico de frontend a backend</a></li>
<li><a href="#_ejemplo_avanzado_permitir_tráfico_de_salida_solo_a_internet_2">Ejemplo avanzado: Permitir tráfico de salida solo a Internet</a></li>
<li><a href="#_tipos_de_reglas">Tipos de reglas</a></li>
<li><a href="#_buenas_prácticas_19">Buenas prácticas</a></li>
<li><a href="#_diagrama_explicativo">Diagrama explicativo</a></li>
</ul>
</li>
<li><a href="#_pod_security_policies">Pod Security Policies</a>
<ul class="sectlevel3">
<li><a href="#_qué_es_una_pod_security_policy">¿Qué es una Pod Security Policy?</a></li>
<li><a href="#_ejemplo_de_pod_security_policy">Ejemplo de Pod Security Policy</a></li>
<li><a href="#_limitaciones_y_estado_actual">Limitaciones y estado actual</a></li>
<li><a href="#_alternativas_modernas_pod_security_admission_psa">Alternativas modernas: Pod Security Admission (PSA)</a></li>
<li><a href="#_buenas_prácticas_20">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_escaneo_de_vulnerabilidades_en_contenedores">Escaneo de vulnerabilidades en contenedores</a>
<ul class="sectlevel3">
<li><a href="#_por_qué_es_importante_el_escaneo_de_vulnerabilidades">¿Por qué es importante el escaneo de vulnerabilidades?</a></li>
<li><a href="#_herramientas_populares_de_escaneo">Herramientas populares de escaneo</a></li>
<li><a href="#_ejemplo_de_escaneo_con_trivy">Ejemplo de escaneo con Trivy</a></li>
<li><a href="#_integración_en_pipelines_cicd">Integración en pipelines CI/CD</a></li>
<li><a href="#_escaneo_continuo_en_kubernetes">Escaneo continuo en Kubernetes</a></li>
<li><a href="#_buenas_prácticas_21">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_10_monitorización_y_observabilidad">Módulo 10: Monitorización y Observabilidad</a>
<ul class="sectlevel2">
<li><a href="#_stack_de_monitorización_prometheus">Stack de monitorización (Prometheus)</a>
<ul class="sectlevel3">
<li><a href="#_cómo_funciona_prometheus_en_kubernetes">¿Cómo funciona Prometheus en Kubernetes?</a></li>
<li><a href="#_despliegue_de_prometheus_con_helm">Despliegue de Prometheus con Helm</a></li>
<li><a href="#_exponer_la_interfaz_web_de_prometheus">Exponer la interfaz web de Prometheus</a></li>
<li><a href="#_monitorización_de_aplicaciones_personalizadas">Monitorización de aplicaciones personalizadas</a></li>
<li><a href="#_alertas_con_alertmanager">Alertas con Alertmanager</a></li>
<li><a href="#_buenas_prácticas_22">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_visualización_con_grafana">Visualización con Grafana</a>
<ul class="sectlevel3">
<li><a href="#_cómo_funciona_grafana_en_kubernetes">¿Cómo funciona Grafana en Kubernetes?</a></li>
<li><a href="#_despliegue_de_grafana_con_helm">Despliegue de Grafana con Helm</a></li>
<li><a href="#_acceso_a_la_interfaz_de_grafana">Acceso a la interfaz de Grafana</a></li>
<li><a href="#_dashboards_recomendados">Dashboards recomendados</a></li>
<li><a href="#_ejemplo_de_configuración_de_datasource_en_grafana">Ejemplo de configuración de datasource en Grafana</a></li>
<li><a href="#_buenas_prácticas_23">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_trazabilidad_con_jaegerzipkin">Trazabilidad con Jaeger/Zipkin</a>
<ul class="sectlevel3">
<li><a href="#_por_qué_es_importante_la_trazabilidad">¿Por qué es importante la trazabilidad?</a></li>
<li><a href="#_jaeger_y_zipkin_características_principales">Jaeger y Zipkin: características principales</a></li>
<li><a href="#_despliegue_de_jaeger_en_kubernetes">Despliegue de Jaeger en Kubernetes</a></li>
<li><a href="#_despliegue_de_zipkin_en_kubernetes">Despliegue de Zipkin en Kubernetes</a></li>
<li><a href="#_instrumentación_de_aplicaciones">Instrumentación de aplicaciones</a></li>
<li><a href="#_integración_con_service_mesh_istio">Integración con Service Mesh (Istio)</a></li>
<li><a href="#_buenas_prácticas_24">Buenas prácticas</a></li>
<li><a href="#_resumen">Resumen</a></li>
</ul>
</li>
<li><a href="#_alertas_y_notificaciones">Alertas y notificaciones</a>
<ul class="sectlevel3">
<li><a href="#_cómo_funcionan_las_alertas_en_kubernetes">¿Cómo funcionan las alertas en Kubernetes?</a></li>
<li><a href="#_ejemplo_de_regla_de_alerta_en_prometheus">Ejemplo de regla de alerta en Prometheus</a></li>
<li><a href="#_configuración_básica_de_alertmanager">Configuración básica de Alertmanager</a></li>
<li><a href="#_acceso_y_pruebas_de_alertmanager">Acceso y pruebas de Alertmanager</a></li>
<li><a href="#_buenas_prácticas_25">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_11_helm_gestor_de_paquetes">Módulo 11: Helm: Gestor de Paquetes</a>
<ul class="sectlevel2">
<li><a href="#_introducción_a_helm">Introducción a Helm</a>
<ul class="sectlevel3">
<li><a href="#_qué_es_un_chart_de_helm">¿Qué es un chart de Helm?</a></li>
<li><a href="#_ventajas_de_usar_helm">Ventajas de usar Helm</a></li>
<li><a href="#_instalación_de_helm">Instalación de Helm</a></li>
<li><a href="#_primeros_pasos_con_helm">Primeros pasos con Helm</a></li>
<li><a href="#_estructura_básica_de_un_chart">Estructura básica de un chart</a></li>
<li><a href="#_buenas_prácticas_26">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_charts_y_repositorios">Charts y repositorios</a>
<ul class="sectlevel3">
<li><a href="#_estructura_de_un_chart">Estructura de un chart</a></li>
<li><a href="#_repositorios_de_charts">Repositorios de charts</a></li>
<li><a href="#_instalación_de_aplicaciones_desde_un_repositorio">Instalación de aplicaciones desde un repositorio</a></li>
<li><a href="#_versionado_y_actualización_de_charts">Versionado y actualización de charts</a></li>
<li><a href="#_creación_de_repositorios_privados">Creación de repositorios privados</a></li>
<li><a href="#_buenas_prácticas_27">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_creación_de_charts_personalizados">Creación de charts personalizados</a>
<ul class="sectlevel3">
<li><a href="#_estructura_básica_de_un_chart_2">Estructura básica de un chart</a></li>
<li><a href="#_creación_de_un_chart_desde_cero">Creación de un chart desde cero</a></li>
<li><a href="#_personalización_de_plantillas">Personalización de plantillas</a></li>
<li><a href="#_instalación_y_prueba_del_chart_personalizado">Instalación y prueba del chart personalizado</a></li>
<li><a href="#_uso_de_helpers_y_funciones">Uso de helpers y funciones</a></li>
<li><a href="#_buenas_prácticas_28">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_gestión_del_ciclo_de_vida_de_aplicaciones">Gestión del ciclo de vida de aplicaciones</a>
<ul class="sectlevel3">
<li><a href="#_fases_del_ciclo_de_vida_de_una_aplicación_en_kubernetes">Fases del ciclo de vida de una aplicación en Kubernetes</a></li>
<li><a href="#_ejemplo_de_ciclo_de_vida_con_helm">Ejemplo de ciclo de vida con Helm</a></li>
<li><a href="#_integración_con_cicd">Integración con CI/CD</a></li>
<li><a href="#_buenas_prácticas_29">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_integraciones_con_cicd">Integraciones con CI/CD</a>
<ul class="sectlevel3">
<li><a href="#_beneficios_de_la_integración_cicd_con_kubernetes">Beneficios de la integración CI/CD con Kubernetes</a></li>
<li><a href="#_herramientas_populares_de_cicd_para_kubernetes">Herramientas populares de CI/CD para Kubernetes</a></li>
<li><a href="#_ejemplo_de_pipeline_de_cicd_con_gitlab_ci">Ejemplo de pipeline de CI/CD con GitLab CI</a></li>
<li><a href="#_ejemplo_de_pipeline_con_github_actions">Ejemplo de pipeline con GitHub Actions</a></li>
<li><a href="#_gitops_despliegue_continuo_basado_en_git">GitOps: despliegue continuo basado en Git</a></li>
<li><a href="#_buenas_prácticas_30">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_12_operadores_de_kubernetes">Módulo 12: Operadores de Kubernetes</a>
<ul class="sectlevel2">
<li><a href="#_concepto_de_operadores">Concepto de operadores</a>
<ul class="sectlevel3">
<li><a href="#_cómo_funcionan_los_operadores">¿Cómo funcionan los operadores?</a></li>
<li><a href="#_ventajas_de_usar_operadores">Ventajas de usar operadores</a></li>
<li><a href="#_ejemplo_de_uso_de_un_operador">Ejemplo de uso de un operador</a></li>
<li><a href="#_buenas_prácticas_31">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_operator_framework">Operator Framework</a>
<ul class="sectlevel3">
<li><a href="#_componentes_principales_del_operator_framework">Componentes principales del Operator Framework</a></li>
<li><a href="#_por_qué_usar_operator_framework">¿Por qué usar Operator Framework?</a></li>
<li><a href="#_ejemplo_de_creación_de_un_operador_con_operator_sdk">Ejemplo de creación de un operador con Operator SDK</a></li>
<li><a href="#_operator_lifecycle_manager_olm">Operator Lifecycle Manager (OLM)</a></li>
<li><a href="#_buenas_prácticas_32">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_casos_de_uso_y_ejemplos_comunes">Casos de uso y ejemplos comunes</a>
<ul class="sectlevel3">
<li><a href="#_1_gestión_automatizada_de_bases_de_datos">1. Gestión automatizada de bases de datos</a></li>
<li><a href="#_2_automatización_de_sistemas_de_mensajería_y_colas">2. Automatización de sistemas de mensajería y colas</a></li>
<li><a href="#_3_aplicaciones_stateful_y_almacenamiento">3. Aplicaciones stateful y almacenamiento</a></li>
<li><a href="#_4_automatización_de_certificados_y_seguridad">4. Automatización de certificados y seguridad</a></li>
<li><a href="#_5_integración_con_servicios_cloud_y_saas">5. Integración con servicios cloud y SaaS</a></li>
<li><a href="#_6_ejemplo_básico_operador_personalizado_para_reinicio_de_pods">6. Ejemplo básico: operador personalizado para reinicio de pods</a></li>
<li><a href="#_buenas_prácticas_33">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_creación_de_operadores_básicos">Creación de operadores básicos</a>
<ul class="sectlevel3">
<li><a href="#_pasos_para_crear_un_operador_básico_con_operator_sdk">Pasos para crear un operador básico con Operator SDK</a></li>
<li><a href="#_ejemplo_mínimo_de_crd_y_lógica_de_reconciliación">Ejemplo mínimo de CRD y lógica de reconciliación</a></li>
<li><a href="#_buenas_prácticas_34">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_automatización_de_tareas_complejas">Automatización de tareas complejas</a>
<ul class="sectlevel3">
<li><a href="#_ejemplos_de_automatización_con_operadores">Ejemplos de automatización con operadores</a></li>
<li><a href="#_ejemplo_backup_automático_con_un_operador_de_base_de_datos">Ejemplo: backup automático con un operador de base de datos</a></li>
<li><a href="#_ejemplo_rotación_automática_de_certificados_con_cert_manager">Ejemplo: rotación automática de certificados con cert-manager</a></li>
<li><a href="#_buenas_prácticas_35">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_13_cicd_con_kubernetes">Módulo 13: CI/CD con Kubernetes</a>
<ul class="sectlevel2">
<li><a href="#_pipelines_de_cicd_para_kubernetes">Pipelines de CI/CD para Kubernetes</a>
<ul class="sectlevel3">
<li><a href="#_cómo_funciona_un_pipeline_de_cicd_para_kubernetes">¿Cómo funciona un pipeline de CI/CD para Kubernetes?</a></li>
<li><a href="#_herramientas_populares_para_pipelines_de_cicd_en_kubernetes">Herramientas populares para pipelines de CI/CD en Kubernetes</a></li>
<li><a href="#_ejemplo_básico_de_pipeline_con_gitlab_ci">Ejemplo básico de pipeline con GitLab CI</a></li>
<li><a href="#_ejemplo_básico_de_pipeline_con_github_actions">Ejemplo básico de pipeline con GitHub Actions</a></li>
<li><a href="#_buenas_prácticas_36">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_gitops_con_argocdflux">GitOps con ArgoCD/Flux</a>
<ul class="sectlevel3">
<li><a href="#_cómo_funciona_gitops">¿Cómo funciona GitOps?</a></li>
<li><a href="#_ventajas_de_gitops">Ventajas de GitOps</a></li>
<li><a href="#_ejemplo_de_flujo_gitops_con_argocd">Ejemplo de flujo GitOps con ArgoCD</a></li>
<li><a href="#_ejemplo_de_flujo_gitops_con_flux">Ejemplo de flujo GitOps con Flux</a></li>
<li><a href="#_buenas_prácticas_37">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_estrategias_de_despliegue_bluegreen_canary">Estrategias de despliegue (blue/green, canary)</a>
<ul class="sectlevel3">
<li><a href="#_bluegreen_deployment_2">Blue/Green Deployment</a></li>
<li><a href="#_canary_deployment_2">Canary Deployment</a></li>
<li><a href="#_ab_testing_2">A/B Testing</a></li>
<li><a href="#_buenas_prácticas_38">Buenas prácticas</a></li>
<li><a href="#_resumen_gráfico_7">Resumen gráfico</a></li>
</ul>
</li>
<li><a href="#_integración_con_herramientas_populares">Integración con herramientas populares</a>
<ul class="sectlevel3">
<li><a href="#_herramientas_de_integración_más_utilizadas">Herramientas de integración más utilizadas</a></li>
<li><a href="#_ejemplo_de_integración_en_un_pipeline_de_cicd">Ejemplo de integración en un pipeline de CI/CD</a></li>
<li><a href="#_buenas_prácticas_39">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_automatización_de_pruebas_y_despliegues">Automatización de pruebas y despliegues</a>
<ul class="sectlevel3">
<li><a href="#_fases_típicas_de_automatización">Fases típicas de automatización</a></li>
<li><a href="#_ejemplo_de_pipeline_automatizado_gitlab_ci">Ejemplo de pipeline automatizado (GitLab CI)</a></li>
<li><a href="#_herramientas_recomendadas">Herramientas recomendadas</a></li>
<li><a href="#_buenas_prácticas_40">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_14_kubernetes_en_producción">Módulo 14: Kubernetes en Producción</a>
<ul class="sectlevel2">
<li><a href="#_arquitecturas_multi_cluster">Arquitecturas multi-cluster</a>
<ul class="sectlevel3">
<li><a href="#_qué_es_un_clúster">¿Qué es un clúster?</a></li>
<li><a href="#_por_qué_usar_una_arquitectura_multi_cluster">¿Por qué usar una arquitectura multi-cluster?</a></li>
<li><a href="#_ejemplo_de_escenarios_multi_cluster">Ejemplo de escenarios multi-cluster</a></li>
<li><a href="#_herramientas_para_gestionar_arquitecturas_multi_cluster">Herramientas para gestionar arquitecturas multi-cluster</a></li>
<li><a href="#_ejemplo_de_configuración_multi_cluster_con_kubeconfig">Ejemplo de configuración multi-cluster con kubeconfig</a></li>
<li><a href="#_ejemplo_de_despliegue_federado_con_kubefed">Ejemplo de despliegue federado con KubeFed</a></li>
<li><a href="#_ventajas_y_retos_de_las_arquitecturas_multi_cluster">Ventajas y retos de las arquitecturas multi-cluster</a></li>
</ul>
</li>
<li><a href="#_gestión_de_certificados_y_tls">Gestión de certificados y TLS</a>
<ul class="sectlevel3">
<li><a href="#_conceptos_básicos_de_tls_y_certificados">Conceptos básicos de TLS y certificados</a></li>
<li><a href="#_generación_de_certificados_autofirmados">Generación de certificados autofirmados</a></li>
<li><a href="#_uso_de_certificados_en_docker">Uso de certificados en Docker</a></li>
<li><a href="#_gestión_de_certificados_en_kubernetes_con_cert_manager">Gestión de certificados en Kubernetes con cert-manager</a></li>
<li><a href="#_renovación_y_revocación_de_certificados">Renovación y revocación de certificados</a></li>
<li><a href="#_buenas_prácticas_en_la_gestión_de_certificados">Buenas prácticas en la gestión de certificados</a></li>
</ul>
</li>
<li><a href="#_estrategias_de_backups_y_recuperación">Estrategias de backups y recuperación</a>
<ul class="sectlevel3">
<li><a href="#_principios_básicos_de_backup_y_recuperación">Principios básicos de backup y recuperación</a></li>
<li><a href="#_estrategias_de_backup_en_docker">Estrategias de backup en Docker</a></li>
<li><a href="#_estrategias_de_backup_en_kubernetes">Estrategias de backup en Kubernetes</a></li>
<li><a href="#_backup_de_bases_de_datos_en_contenedores">Backup de bases de datos en contenedores</a></li>
<li><a href="#_automatización_y_almacenamiento_seguro">Automatización y almacenamiento seguro</a></li>
<li><a href="#_pruebas_de_recuperación">Pruebas de recuperación</a></li>
<li><a href="#_buenas_prácticas_41">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_optimización_de_recursos_y_costes">Optimización de recursos y costes</a>
<ul class="sectlevel3">
<li><a href="#_principios_de_optimización">Principios de optimización</a></li>
<li><a href="#_optimización_en_docker">Optimización en Docker</a></li>
<li><a href="#_optimización_en_kubernetes">Optimización en Kubernetes</a></li>
<li><a href="#_optimización_de_almacenamiento">Optimización de almacenamiento</a></li>
<li><a href="#_optimización_de_red">Optimización de red</a></li>
<li><a href="#_optimización_de_costes_en_la_nube">Optimización de costes en la nube</a></li>
<li><a href="#_buenas_prácticas_42">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_troubleshooting_y_resolución_de_problemas">Troubleshooting y resolución de problemas</a>
<ul class="sectlevel3">
<li><a href="#_principios_del_troubleshooting">Principios del troubleshooting</a></li>
<li><a href="#_troubleshooting_en_docker">Troubleshooting en Docker</a></li>
<li><a href="#_troubleshooting_en_kubernetes">Troubleshooting en Kubernetes</a></li>
<li><a href="#_troubleshooting_de_red">Troubleshooting de red</a></li>
<li><a href="#_troubleshooting_de_almacenamiento">Troubleshooting de almacenamiento</a></li>
<li><a href="#_herramientas_útiles">Herramientas útiles</a></li>
<li><a href="#_buenas_prácticas_43">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_módulo_15_extensiones_y_ecosistema">Módulo 15: Extensiones y Ecosistema</a>
<ul class="sectlevel2">
<li><a href="#_custom_resource_definitions_crds">Custom Resource Definitions (CRDs)</a>
<ul class="sectlevel3">
<li><a href="#_qué_es_una_crd">¿Qué es una CRD?</a></li>
<li><a href="#_ejemplo_básico_de_crd">Ejemplo básico de CRD</a></li>
<li><a href="#_ventajas_de_usar_crds">Ventajas de usar CRDs</a></li>
<li><a href="#_operadores_y_crds">Operadores y CRDs</a></li>
<li><a href="#_gestión_y_actualización_de_crds">Gestión y actualización de CRDs</a></li>
<li><a href="#_buenas_prácticas_44">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_api_aggregation">API Aggregation</a>
<ul class="sectlevel3">
<li><a href="#_qué_es_api_aggregation">¿Qué es API Aggregation?</a></li>
<li><a href="#_diferencias_entre_crds_y_api_aggregation">Diferencias entre CRDs y API Aggregation</a></li>
<li><a href="#_arquitectura_de_api_aggregation">Arquitectura de API Aggregation</a></li>
<li><a href="#_ejemplo_de_uso_metrics_server">Ejemplo de uso: Metrics Server</a></li>
<li><a href="#_ejemplo_de_manifiesto_de_apiservice">Ejemplo de manifiesto de APIService</a></li>
<li><a href="#_ventajas_y_casos_de_uso_2">Ventajas y casos de uso</a></li>
<li><a href="#_consideraciones_de_seguridad">Consideraciones de seguridad</a></li>
<li><a href="#_buenas_prácticas_45">Buenas prácticas</a></li>
</ul>
</li>
<li><a href="#_servicios_en_la_nube_basados_en_kubernetes">Servicios en la nube basados en Kubernetes</a>
<ul class="sectlevel3">
<li><a href="#_qué_es_un_servicio_gestionado_de_kubernetes">¿Qué es un servicio gestionado de Kubernetes?</a></li>
<li><a href="#_principales_servicios_en_la_nube">Principales servicios en la nube</a></li>
<li><a href="#_ventajas_de_los_servicios_gestionados">Ventajas de los servicios gestionados</a></li>
<li><a href="#_consideraciones_y_buenas_prácticas">Consideraciones y buenas prácticas</a></li>
<li><a href="#_ejemplo_de_archivo_de_configuración_kubeconfig">Ejemplo de archivo de configuración kubeconfig</a></li>
<li><a href="#_otros_servicios_y_ecosistema">Otros servicios y ecosistema</a></li>
</ul>
</li>
<li><a href="#_integraciones_con_proveedores_cloud_aws_gcp_azure">Integraciones con proveedores cloud (AWS, GCP, Azure)</a>
<ul class="sectlevel3">
<li><a href="#_integración_con_aws">Integración con AWS</a></li>
<li><a href="#_integración_con_gcp">Integración con GCP</a></li>
<li><a href="#_integración_con_azure">Integración con Azure</a></li>
<li><a href="#_buenas_prácticas_de_integración">Buenas prácticas de integración</a></li>
</ul>
</li>
<li><a href="#_herramientas_complementarias">Herramientas complementarias</a>
<ul class="sectlevel3">
<li><a href="#_monitorización_y_observabilidad">Monitorización y observabilidad</a></li>
<li><a href="#_seguridad_y_cumplimiento">Seguridad y cumplimiento</a></li>
<li><a href="#_gestión_y_automatización">Gestión y automatización</a></li>
<li><a href="#_service_mesh_y_networking">Service Mesh y networking</a></li>
<li><a href="#_desarrollo_y_productividad">Desarrollo y productividad</a></li>
<li><a href="#_ejemplo_de_integración_helm">Ejemplo de integración: Helm</a></li>
<li><a href="#_buenas_prácticas_46">Buenas prácticas</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_recursos_adicionales">Recursos Adicionales</a>
<ul class="sectlevel2">
<li><a href="#_documentación_oficial_y_cncf">Documentación oficial y CNCF</a></li>
<li><a href="#_certificaciones_disponibles_cka_ckad_cks">Certificaciones disponibles (CKA, CKAD, CKS)</a></li>
<li><a href="#_comunidad_y_eventos">Comunidad y eventos</a></li>
<li><a href="#_recursos_de_aprendizaje_continuo">Recursos de aprendizaje continuo</a></li>
<li><a href="#_tendencias_futuras_en_el_ecosistema_de_kubernetes">Tendencias futuras en el ecosistema de Kubernetes</a></li>
</ul>
</li>
<li><a href="#_módulo_16_terraform">Módulo 16: Terraform</a>
<ul class="sectlevel2">
<li><a href="#_introducción_a_infrastructure_as_code_iac">Introducción a Infrastructure as Code (IaC)</a>
<ul class="sectlevel3">
<li><a href="#_beneficios_de_iac">Beneficios de IaC</a></li>
<li><a href="#_enfoques_de_iac">Enfoques de IaC</a></li>
</ul>
</li>
<li><a href="#_qué_es_terraform">¿Qué es Terraform?</a>
<ul class="sectlevel3">
<li><a href="#_características_principales">Características principales</a></li>
<li><a href="#_casos_de_uso">Casos de uso</a></li>
</ul>
</li>
<li><a href="#_instalación_de_terraform">Instalación de Terraform</a>
<ul class="sectlevel3">
<li><a href="#_linux_ubuntudebian">Linux (Ubuntu/Debian)</a></li>
<li><a href="#_instalación_con_gestor_de_paquetes">Instalación con gestor de paquetes</a></li>
<li><a href="#_instalación_manual">Instalación manual</a></li>
</ul>
</li>
<li><a href="#_conceptos_fundamentales_de_terraform">Conceptos fundamentales de Terraform</a>
<ul class="sectlevel3">
<li><a href="#_providers">Providers</a></li>
<li><a href="#_resources">Resources</a></li>
<li><a href="#_data_sources">Data Sources</a></li>
<li><a href="#_variables">Variables</a></li>
<li><a href="#_outputs">Outputs</a></li>
<li><a href="#_state_estado">State (Estado)</a></li>
</ul>
</li>
<li><a href="#_comandos_básicos_de_terraform">Comandos básicos de Terraform</a>
<ul class="sectlevel3">
<li><a href="#_terraform_init">terraform init</a></li>
<li><a href="#_terraform_plan">terraform plan</a></li>
<li><a href="#_terraform_apply">terraform apply</a></li>
<li><a href="#_terraform_destroy">terraform destroy</a></li>
<li><a href="#_otros_comandos_útiles">Otros comandos útiles</a></li>
</ul>
</li>
<li><a href="#_módulos_de_terraform">Módulos de Terraform</a>
<ul class="sectlevel3">
<li><a href="#_estructura_de_un_módulo">Estructura de un módulo</a></li>
<li><a href="#_ejemplo_de_módulo_webserver">Ejemplo de módulo (webserver)</a></li>
<li><a href="#_uso_del_módulo">Uso del módulo</a></li>
<li><a href="#_módulos_públicos_del_registry">Módulos públicos del Registry</a></li>
</ul>
</li>
<li><a href="#_terraform_con_kubernetes">Terraform con Kubernetes</a>
<ul class="sectlevel3">
<li><a href="#_configuración_del_provider_kubernetes">Configuración del provider Kubernetes</a></li>
<li><a href="#_ejemplo_desplegar_aplicación_completa_en_kubernetes">Ejemplo: Desplegar aplicación completa en Kubernetes</a></li>
</ul>
</li>
<li><a href="#_buenas_prácticas_con_terraform">Buenas prácticas con Terraform</a>
<ul class="sectlevel3">
<li><a href="#_organización_del_código">Organización del código</a></li>
<li><a href="#_gestión_del_state">Gestión del state</a></li>
<li><a href="#_seguridad">Seguridad</a></li>
<li><a href="#_desarrollo_y_testing">Desarrollo y testing</a></li>
<li><a href="#_cicd">CI/CD</a></li>
<li><a href="#_comandos_de_ejemplo_en_cicd">Comandos de ejemplo en CI/CD</a></li>
</ul>
</li>
<li><a href="#_herramientas_complementarias_2">Herramientas complementarias</a></li>
<li><a href="#_recursos_adicionales_2">Recursos adicionales</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_módulo_1_introducción_a_kubernetes">Módulo 1: Introducción a Kubernetes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_fundamentos_de_orquestación_de_contenedores">Fundamentos de orquestación de contenedores</h3>
<div class="paragraph">
<p>La orquestación de contenedores es el proceso de automatizar la implementación, gestión, escalado y networking de contenedores. Permite administrar múltiples contenedores distribuidos en diferentes hosts, facilitando la alta disponibilidad, el balanceo de carga y la recuperación ante fallos.</p>
</div>
</div>
<div class="sect2">
<h3 id="_historia_y_evolución_de_kubernetes">Historia y evolución de Kubernetes</h3>
<div class="paragraph">
<p>Kubernetes fue desarrollado originalmente por Google, basado en su experiencia con Borg y Omega, y donado a la Cloud Native Computing Foundation (CNCF) en 2015. Desde entonces, se ha convertido en el estándar de facto para la orquestación de contenedores, evolucionando rápidamente gracias a una comunidad activa y un ecosistema robusto.</p>
</div>
</div>
<div class="sect2">
<h3 id="_arquitectura_y_componentes_principales">Arquitectura y componentes principales</h3>
<div class="paragraph">
<p>Kubernetes se compone de un plano de control (control plane) y nodos de trabajo (worker nodes).
.Los componentes principales incluyen:
- <strong>API Server</strong>: punto de entrada para todas las operaciones.
- <strong>etcd</strong>: almacén de datos clave-valor distribuido.
- <strong>Controller Manager</strong>: gestiona los controladores que regulan el estado del clúster.
- <strong>Scheduler</strong>: asigna pods a los nodos disponibles.
- <strong>Kubelet</strong>: agente que corre en cada nodo y gestiona los pods.
- <strong>Kube Proxy</strong>: gestiona la red y el acceso a los servicios.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="kubernetes_cluster.png" alt="kubernetes cluster" width="1207" height="525">
</div>
<div class="title">Figure 1. Diagrama de arquitectura de Kubernetes con todas sus entidades</div>
</div>
</div>
<div class="sect2">
<h3 id="_ventajas_y_casos_de_uso">Ventajas y casos de uso</h3>
<div class="ulist">
<div class="title">Kubernetes ofrece múltiples ventajas:</div>
<ul>
<li>
<p>Escalabilidad automática de aplicaciones.</p>
</li>
<li>
<p>Alta disponibilidad y tolerancia a fallos.</p>
</li>
<li>
<p>Despliegues y actualizaciones sin tiempo de inactividad.</p>
</li>
<li>
<p>Gestión eficiente de recursos.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Los casos de uso más comunes son:</div>
<ul>
<li>
<p>Despliegue y gestión de microservicios.</p>
</li>
<li>
<p>Aplicaciones cloud-native.</p>
</li>
<li>
<p>Entornos de desarrollo, pruebas y producción.</p>
</li>
<li>
<p>Procesamiento de datos y análisis distribuido.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_diferencias_con_docker_swarm_y_otras_plataformas">Diferencias con Docker Swarm y otras plataformas</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Kubernetes</strong> es más complejo pero ofrece mayor flexibilidad, escalabilidad y un ecosistema más amplio.</p>
</li>
<li>
<p><strong>Docker Swarm</strong> es más sencillo de configurar, pero menos potente y con menor adopción en producción.</p>
</li>
<li>
<p>Otras plataformas como <strong>Mesos</strong> o <strong>Nomad</strong> tienen enfoques distintos, pero Kubernetes se ha consolidado como el estándar por su comunidad, soporte y características avanzadas.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_2_configuración_del_entorno">Módulo 2: Configuración del Entorno</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_instalación_de_kubernetes_local_y_cloud">Instalación de Kubernetes (local y cloud)</h3>
<div class="paragraph">
<p>Para entornos locales, puedes instalar Kubernetes usando herramientas como Minikube, Kind o K3s. En la nube, los principales proveedores ofrecen servicios gestionados como Google Kubernetes Engine (GKE), Amazon EKS y Azure AKS. La instalación local es ideal para pruebas y desarrollo, mientras que la instalación en la nube es recomendada para producción.</p>
</div>
</div>
<div class="sect2">
<h3 id="_minikube_kind_y_k3s_para_desarrollo">Minikube, Kind y K3s para desarrollo</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Minikube</strong>: Permite crear un clúster de Kubernetes en una máquina local usando una máquina virtual o contenedor.</p>
</li>
<li>
<p><strong>Kind (Kubernetes IN Docker)</strong>: Ejecuta clústeres de Kubernetes usando contenedores Docker, ideal para pruebas rápidas y CI.</p>
</li>
<li>
<p><strong>K3s</strong>: Una distribución ligera de Kubernetes, fácil de instalar y optimizada para IoT y edge computing.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_configuración_de_kubectl">Configuración de kubectl</h3>
<div class="paragraph">
<p><code>kubectl</code> es la herramienta de línea de comandos para interactuar con Kubernetes. Para configurarla:</p>
</div>
<div class="listingblock">
<div class="title">Instala <code>kubectl</code> en tu máquina local:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Instala kubectl
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
# Verifica la instalación
kubectl version --client
# Configura el acceso al clúster
kubectl config set-cluster &lt;nombre-del-cluster&gt; --server=&lt;url-del-api-server&gt;
kubectl config set-credentials &lt;nombre-del-usuario&gt; --token
kubectl config set-context &lt;nombre-del-contexto&gt; --cluster=&lt;nombre-del-cluster&gt; --user=&lt;nombre-del-usuario&gt;
kubectl config use-context &lt;nombre-del-contexto&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Verifica la conexión ejecutando:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl cluster-info</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_primeros_comandos_básicos">Primeros comandos básicos</h3>
<div class="paragraph">
<p>Algunos comandos esenciales para comenzar:
.Ver nodos del clúster:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get nodes</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ver pods en todos los namespaces:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get pods --all-namespaces</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Crear un pod de ejemplo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl run nginx --image=nginx</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Eliminar un pod:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl delete pod nginx</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_explorando_el_dashboard_de_kubernetes">Explorando el dashboard de Kubernetes</h3>
<div class="paragraph">
<p>El Dashboard es una interfaz web para gestionar y visualizar recursos del clúster.
.Instala el dashboard:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Accede al dashboard ejecutando:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl proxy</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_3_objetos_básicos_de_kubernetes">Módulo 3: Objetos Básicos de Kubernetes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_pods_unidad_básica_de_despliegue">Pods: unidad básica de despliegue</h3>
<div class="paragraph">
<div class="title">Autentícate usando un token de acceso generado para tu usuario o cuenta de servicio.</div>
<p>Un <strong>Pod</strong> es la unidad más pequeña de despliegue en Kubernetes. Un pod puede contener uno o varios contenedores que comparten red, almacenamiento y especificaciones de configuración. Los pods se utilizan para ejecutar aplicaciones o servicios y son efímeros: si fallan, Kubernetes puede recrearlos automáticamente.</p>
</div>
<div class="sect3">
<h4 id="_ciclo_de_vida_de_un_pod">Ciclo de vida de un pod</h4>
<div class="paragraph">
<p>Un pod puede ser creado, programado en un nodo, ejecutado y finalmente terminado o eliminado. Kubernetes gestiona automáticamente la recreación de pods en caso de fallos, según las políticas definidas en los controladores como Deployments o ReplicaSets.</p>
</div>
</div>
<div class="sect3">
<h4 id="_estados_de_un_pod">Estados de un pod</h4>
<div class="ulist">
<div class="title">Los principales estados de un pod son:</div>
<ul>
<li>
<p><strong>Pending</strong>: El pod ha sido aceptado por el clúster, pero uno o más de sus contenedores aún no han sido creados.</p>
</li>
<li>
<p><strong>Running</strong>: Todos los contenedores del pod han sido creados y al menos uno está en ejecución.</p>
</li>
<li>
<p><strong>Succeeded</strong>: Todos los contenedores han terminado correctamente y no serán reiniciados.</p>
</li>
<li>
<p><strong>Failed</strong>: Todos los contenedores han terminado, pero al menos uno falló.</p>
</li>
<li>
<p><strong>Unknown</strong>: El estado del pod no pudo ser determinado, generalmente por problemas de comunicación con el nodo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_pods">Gestión de pods</h4>
<div class="paragraph">
<p>La gestión de pods se realiza principalmente mediante controladores como Deployments, ReplicaSets o Jobs, que permiten definir el estado deseado y delegar en Kubernetes la creación, actualización y eliminación de pods.</p>
</div>
<div class="listingblock">
<div class="title">Comandos básicos de kubectl para pods:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Crear y gestionar pods
kubectl run nginx --image=nginx
kubectl get pods
kubectl delete pod &lt;nombre-del-pod&gt;
kubectl describe pod &lt;nombre-del-pod&gt;

# Ver logs y ejecutar comandos
kubectl logs &lt;nombre-del-pod&gt;
kubectl exec -it &lt;nombre-del-pod&gt; -- /bin/bash

# Ver configuración y eventos
kubectl get pod &lt;nombre-del-pod&gt; -o yaml
kubectl get events --field-selector involvedObject.name=&lt;nombre-del-pod&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gestión de Deployments (recomendado para producción):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Escalar réplicas
kubectl scale --replicas=3 deployment/&lt;nombre-del-deployment&gt;

# Actualizar imagen
kubectl set image deployment/&lt;nombre-del-deployment&gt; &lt;contenedor&gt;=&lt;nueva-imagen&gt;

# Reiniciar deployment
kubectl rollout restart deployment/&lt;nombre-del-deployment&gt;

# Ver historial y hacer rollback
kubectl rollout history deployment/&lt;nombre-del-deployment&gt;
kubectl rollout undo deployment/&lt;nombre-del-deployment&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_labels_y_annotations">Labels y Annotations</h4>
<div class="paragraph">
<p><strong>Labels</strong> son pares clave-valor que se asignan a los objetos de Kubernetes para identificarlos, agruparlos y seleccionarlos lógicamente. Se utilizan para operaciones como filtrado, organización, despliegue selectivo y políticas de red. Ejemplo de uso de labels en un manifiesto:</p>
</div>
<div class="listingblock">
<div class="title">Un ejemplo de label en un pod:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: ejemplo-pod
  labels:
    app: web
    entorno: produccion</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Annotations</strong> permiten adjuntar metadatos adicionales a los objetos, como información de despliegue, enlaces, descripciones o configuraciones externas. A diferencia de los labels, no se usan para selección o agrupación, sino para almacenar datos auxiliares. Ejemplo de uso de annotations:</p>
</div>
<div class="listingblock">
<div class="title">Un ejemplo de annotation en un pod:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: ejemplo-pod
  annotations:
    descripcion: "Pod de ejemplo para mostrar annotations"
    contacto: "devops@empresa.com"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Las labels y annotations son fundamentales para la gestión avanzada de recursos, automatización y observabilidad en Kubernetes.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_replicasets_y_controladores_de_replicación">ReplicaSets y controladores de replicación</h3>
<div class="paragraph">
<p>Un <strong>ReplicaSet</strong> es un objeto de Kubernetes que asegura que un número específico de réplicas de un pod estén corriendo en todo momento. Si un pod falla o es eliminado, el ReplicaSet crea uno nuevo para mantener el estado deseado. Los ReplicaSets reemplazaron a los controladores de replicación tradicionales, ofreciendo mayor flexibilidad y soporte para selectores avanzados.</p>
</div>
<div class="paragraph">
<p>Los controladores de replicación fueron el primer mecanismo para garantizar la disponibilidad de pods, pero han sido reemplazados por ReplicaSets debido a sus limitaciones en la selección de pods. Actualmente, los ReplicaSets suelen ser gestionados indirectamente a través de Deployments.</p>
</div>
<div class="olist arabic">
<div class="title">Un ReplicaSet consta de estos apartados:</div>
<ol class="arabic">
<li>
<p><code>apiVersion</code>: Versión de la API de Kubernetes utilizada.</p>
</li>
<li>
<p><code>kind</code>: Tipo de recurso, en este caso <code>ReplicaSet</code>.</p>
</li>
<li>
<p><code>metadata</code>: Información descriptiva del objeto (nombre, etiquetas, anotaciones).</p>
</li>
<li>
<p><code>spec</code>: Especificaciones del ReplicaSet, que incluye:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>replicas</code>: Número de réplicas deseadas.</p>
</li>
<li>
<p><code>selector</code>: Selector de etiquetas para identificar los pods gestionados.</p>
</li>
<li>
<p><code>template</code>: Plantilla de los pods a crear, que contiene:</p>
<div class="olist lowerroman">
<ol class="lowerroman" type="i">
<li>
<p><code>metadata</code>: Etiquetas y metadatos de los pods.</p>
</li>
<li>
<p><code>spec</code>: Especificación de los contenedores y configuración de los pods.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Ejemplo básico de ReplicaSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: ejemplo-replicaset
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
      - name: nginx
        image: nginx:latest</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los ReplicaSets son útiles para mantener la alta disponibilidad y escalabilidad de las aplicaciones, pero en la práctica se gestionan casi siempre mediante Deployments, que facilitan actualizaciones y rollbacks.</p>
</div>
<div class="sect3">
<h4 id="_ciclo_de_vida_de_un_replicaset">Ciclo de vida de un ReplicaSet</h4>
<div class="paragraph">
<p>El ciclo de vida de un ReplicaSet comienza con su creación a través de un manifiesto YAML o mediante un Deployment. Una vez creado, el ReplicaSet observa continuamente el estado de los pods asociados y asegura que el número de réplicas especificado se mantenga. Si un pod falla o es eliminado, el ReplicaSet crea uno nuevo automáticamente. Si se actualiza el manifiesto (por ejemplo, cambiando el número de réplicas), el ReplicaSet ajusta la cantidad de pods en consecuencia. El ciclo termina cuando el ReplicaSet es eliminado, lo que provoca la eliminación de todos los pods gestionados por él, a menos que tengan un propietario adicional como un Deployment.</p>
</div>
</div>
<div class="sect3">
<h4 id="_estados_de_un_replicaset">Estados de un ReplicaSet</h4>
<div class="paragraph">
<p>Un ReplicaSet se considera saludable cuando el número de pods actuales y disponibles coincide con el número deseado. Puedes consultar el estado de un ReplicaSet con:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get replicaset
kubectl describe replicaset &lt; nombre-del-replicaset &gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_replicasets">Gestión de ReplicaSets</h4>
<div class="paragraph">
<p>La gestión de ReplicaSets se realiza principalmente mediante el uso de manifiestos YAML y la herramienta <code>kubectl</code>. Las operaciones más comunes incluyen la creación, actualización, escalado y eliminación de ReplicaSets.</p>
</div>
<div class="listingblock">
<div class="title">Crear un ReplicaSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f replicaset.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Listar ReplicaSets:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get replicasets</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Escalar un ReplicaSet (cambiar el número de réplicas):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl scale replicaset &lt;nombre-del-replicaset&gt; --replicas=5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Actualizar un ReplicaSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f replicaset.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ver detalles de un ReplicaSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl describe replicaset &lt;nombre-del-replicaset&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Eliminar un ReplicaSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl delete replicaset &lt;nombre-del-replicaset&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>En la práctica, los ReplicaSets suelen ser gestionados indirectamente a través de Deployments, que facilitan la actualización y el control del ciclo de vida de las aplicaciones.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_deployments_gestión_de_actualizaciones">Deployments: gestión de actualizaciones</h3>
<div class="paragraph">
<p>Un <strong>Deployment</strong> gestiona la creación y actualización de ReplicaSets y, por ende, de pods. Permite realizar despliegues declarativos, actualizaciones progresivas (rolling updates) y retrocesos (rollbacks) en caso de fallos. Es el recurso recomendado para gestionar aplicaciones sin tiempo de inactividad.</p>
</div>
<div class="sect3">
<h4 id="_ciclo_de_vida_de_un_deployment">Ciclo de vida de un Deployment</h4>
<div class="paragraph">
<p>El ciclo de vida de un Deployment inicia con la creación del recurso mediante un manifiesto YAML o un comando <code>kubectl</code>. Al crearse, el Deployment genera un ReplicaSet que, a su vez, crea los pods necesarios según la configuración deseada.</p>
</div>
<div class="paragraph">
<p>Cuando se actualiza el Deployment (por ejemplo, cambiando la imagen del contenedor o el número de réplicas), Kubernetes realiza una actualización progresiva (rolling update), reemplazando gradualmente los pods antiguos por nuevos para evitar tiempo de inactividad. Si ocurre un error durante la actualización, el Deployment puede realizar un rollback automático o manual a una versión anterior.</p>
</div>
<div class="paragraph">
<p>El ciclo de vida termina cuando el Deployment es eliminado, lo que provoca la eliminación de los ReplicaSets y pods gestionados por él, a menos que estos tengan otros propietarios.</p>
</div>
<div class="ulist">
<div class="title">Principales etapas:</div>
<ul>
<li>
<p>Creación del Deployment y su ReplicaSet asociado.</p>
</li>
<li>
<p>Escalado automático o manual de réplicas.</p>
</li>
<li>
<p>Actualizaciones progresivas y rollbacks.</p>
</li>
<li>
<p>Eliminación del Deployment y recursos asociados.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_estados_de_un_deployment">Estados de un Deployment</h4>
<div class="paragraph">
<p>El estado de un Deployment se determina por el estado de sus ReplicaSets y pods gestionados.</p>
</div>
<div class="ulist">
<div class="title">Los principales indicadores y condiciones que puedes observar son:</div>
<ul>
<li>
<p><strong>Available Replicas</strong>: Número de pods disponibles y listos para recibir tráfico.</p>
</li>
<li>
<p><strong>Updated Replicas</strong>: Número de pods actualizados con la última especificación del Deployment.</p>
</li>
<li>
<p><strong>Ready Replicas</strong>: Número de pods que han pasado las comprobaciones de estado y están listos para su uso.</p>
</li>
<li>
<p><strong>Unavailable Replicas</strong>: Número de pods que no están disponibles.</p>
</li>
<li>
<p><strong>Conditions</strong>: El Deployment puede mostrar condiciones como <code>Progressing</code> (en proceso de actualización), <code>Available</code> (disponible) o <code>ReplicaFailure</code> (fallo en la creación de réplicas).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Un Deployment se considera saludable cuando el número de pods actualizados, disponibles y listos coincide con el número deseado de réplicas y no hay condiciones de error.</p>
</div>
<div class="paragraph">
<p>Puedes consultar el estado de un Deployment con:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get deployments
kubectl describe deployment &lt;nombre-del-deployment&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_deployments">Gestión de Deployments</h4>
<div class="paragraph">
<p>La gestión de Deployments se realiza principalmente mediante manifiestos YAML y la herramienta <code>kubectl</code>. Permite crear, actualizar, escalar, reiniciar, hacer rollback y eliminar aplicaciones de forma declarativa y controlada.</p>
</div>
<div class="listingblock">
<div class="title">Crear un Deployment:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f deployment.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Listar Deployments:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get deployments</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Escalar un Deployment (cambiar el número de réplicas):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl scale deployment &lt;nombre-del-deployment&gt; --replicas=5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Actualizar la imagen de un Deployment:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl set image deployment/&lt;nombre-del-deployment&gt; &lt;nombre-del-contenedor&gt;=&lt;nueva-imagen&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Reiniciar un Deployment:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl rollout restart deployment/&lt;nombre-del-deployment&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ver el historial de cambios:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl rollout history deployment/&lt;nombre-del-deployment&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Hacer rollback a una versión anterior:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl rollout undo deployment/&lt;nombre-del-deployment&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Eliminar un Deployment:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl delete deployment &lt;nombre-del-deployment&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Los Deployments facilitan la gestión del ciclo de vida de las aplicaciones, permitiendo actualizaciones sin tiempo de inactividad y un control detallado sobre el estado de los despliegues.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_statefulsets_gestión_de_aplicaciones_con_estado">StatefulSets: gestión de aplicaciones con estado</h3>
<div class="paragraph">
<p>Un <strong>StatefulSet</strong> es un recurso de Kubernetes diseñado para gestionar aplicaciones con estado, es decir, aquellas que requieren identidad persistente, almacenamiento estable y un orden específico en el despliegue y actualización de los pods. A diferencia de los Deployments o ReplicaSets, que están pensados para aplicaciones sin estado (stateless), los StatefulSets proporcionan garantías adicionales necesarias para bases de datos, sistemas distribuidos y servicios que dependen de la persistencia de datos y la identidad de red.</p>
</div>
<div class="sect3">
<h4 id="_características_principales_de_los_statefulsets">Características principales de los StatefulSets</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Identidad estable</strong>: Cada pod gestionado por un StatefulSet tiene un nombre único y predecible (por ejemplo, <code>miapp-0</code>, <code>miapp-1</code>, etc.), que se mantiene incluso si el pod es eliminado y recreado.</p>
</li>
<li>
<p><strong>Almacenamiento persistente</strong>: Los StatefulSets pueden asociar un PersistentVolumeClaim (PVC) único a cada pod, asegurando que los datos persisten aunque el pod se reinicie o se reprograme en otro nodo.</p>
</li>
<li>
<p><strong>Orden de despliegue y actualización</strong>: Los pods se crean, actualizan y eliminan en un orden controlado (de menor a mayor índice), lo que es esencial para aplicaciones que requieren inicialización secuencial o dependencias entre instancias.</p>
</li>
<li>
<p><strong>Headless Service</strong>: Para exponer los pods de un StatefulSet y permitir la comunicación directa entre ellos, se utiliza un Service de tipo headless (<code>clusterIP: None</code>), que asigna un DNS único a cada pod.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_casos_de_uso_típicos">Casos de uso típicos</h4>
<div class="ulist">
<ul>
<li>
<p>Bases de datos distribuidas (MongoDB, Cassandra, MySQL Galera, etc.)</p>
</li>
<li>
<p>Sistemas de mensajería (Kafka, RabbitMQ)</p>
</li>
<li>
<p>Aplicaciones que requieren almacenamiento persistente y orden en el despliegue</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_manifiesto_yaml_para_statefulset">Ejemplo de manifiesto YAML para StatefulSet</h4>
<div class="paragraph">
<p>A continuación se muestra un ejemplo básico de StatefulSet para una base de datos MongoDB con 3 réplicas y almacenamiento persistente:</p>
</div>
<div class="listingblock">
<div class="title">Definición del servicio headless y StatefulSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Service
metadata:
  name: mongo
spec:
  clusterIP: None
  selector:
    app: mongo
  ports:
    - port: 27017
      name: mongo

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mongo
spec:
  serviceName: mongo
  replicas: 3
  selector:
    matchLabels:
      app: mongo
  template:
    metadata:
      labels:
        app: mongo
    spec:
      containers:
        - name: mongo
          image: mongo:5.0
          ports:
            - containerPort: 27017
          volumeMounts:
            - name: datos
              mountPath: /data/db
  volumeClaimTemplates:
    - metadata:
        name: datos
      spec:
        accessModes: [ "ReadWriteOnce" ]
        resources:
          requests:
            storage: 5Gi</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para ejecutar este manifiesto, guarda el contenido en un archivo llamado <code>mongo-statefulset.yaml</code> y ejecuta:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f mongo-statefulset.yaml</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>Se crea un Service headless llamado <code>mongo</code> para exponer los pods.</p>
</li>
<li>
<p>El StatefulSet crea 3 pods (<code>mongo-0</code>, <code>mongo-1</code>, <code>mongo-2</code>), cada uno con su propio volumen persistente.</p>
</li>
<li>
<p>Si un pod se elimina, Kubernetes lo recrea con el mismo nombre y volumen.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_comandos_útiles_para_gestionar_statefulsets">Comandos útiles para gestionar StatefulSets</h4>
<div class="listingblock">
<div class="title">Crear el StatefulSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f mongo-statefulset.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Listar los pods creados:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get pods -l app=mongo</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ver los volúmenes persistentes asociados:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get pvc -l app=mongo</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Escalar el StatefulSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl scale statefulset mongo --replicas=5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Eliminar el StatefulSet (los PVC pueden permanecer según la política de retención):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl delete statefulset mongo</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_con_statefulsets">Buenas prácticas con StatefulSets</h4>
<div class="ulist">
<ul>
<li>
<p>Usa StatefulSets solo cuando la aplicación requiera identidad persistente, almacenamiento estable y orden en el despliegue.</p>
</li>
<li>
<p>Define un Service headless para garantizar la resolución DNS individual de los pods.</p>
</li>
<li>
<p>Configura correctamente los PersistentVolumeClaims para asegurar la persistencia de datos.</p>
</li>
<li>
<p>Supervisa el estado de los pods y los volúmenes asociados.</p>
</li>
<li>
<p>Considera la política de retención de volúmenes (<code>Retain</code> o <code>Delete</code>) según la criticidad de los datos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_gráfico">Resumen gráfico</h4>
<div class="imageblock">
<div class="content">
<img src="statefulset-diagram.png" alt="statefulset diagram" width="1014" height="258">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_daemonsets_ejecución_de_pods_en_todos_los_nodos">DaemonSets: ejecución de pods en todos los nodos</h3>
<div class="paragraph">
<p>Un <strong>DaemonSet</strong> es un recurso de Kubernetes que garantiza que una copia de un pod específico se ejecute en cada nodo del clúster (o en un subconjunto de nodos, según la configuración). Es ideal para desplegar agentes de monitorización, logging, proxies, o cualquier servicio que deba estar presente en todos los nodos.</p>
</div>
<div class="sect3">
<h4 id="_características_principales_de_los_daemonsets">Características principales de los DaemonSets</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Despliegue automático en todos los nodos</strong>: Cada vez que se añade un nodo al clúster, el DaemonSet programa automáticamente un pod en ese nodo.</p>
</li>
<li>
<p><strong>Gestión de nodos selectivos</strong>: Puedes limitar la ejecución a ciertos nodos usando <code>nodeSelector</code>, <code>affinity</code> o <code>tolerations</code>.</p>
</li>
<li>
<p><strong>Actualización controlada</strong>: Permite actualizar los pods de forma progresiva usando la estrategia <code>RollingUpdate</code>.</p>
</li>
<li>
<p><strong>Eliminación automática</strong>: Cuando un nodo es eliminado del clúster, el pod correspondiente también se elimina.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_casos_de_uso_típicos_2">Casos de uso típicos</h4>
<div class="ulist">
<ul>
<li>
<p>Agentes de monitorización (Prometheus Node Exporter, Datadog Agent, etc.).</p>
</li>
<li>
<p>Recolectores de logs (Fluentd, Filebeat).</p>
</li>
<li>
<p>Proxies de red o almacenamiento.</p>
</li>
<li>
<p>Herramientas de seguridad y escaneo de nodos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_manifiesto_yaml_para_daemonset">Ejemplo de manifiesto YAML para DaemonSet</h4>
<div class="paragraph">
<p>A continuación, un ejemplo básico de DaemonSet que despliega Prometheus Node Exporter en todos los nodos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: node-exporter
  labels:
    app: node-exporter
spec:
  selector:
    matchLabels:
      app: node-exporter
  template:
    metadata:
      labels:
        app: node-exporter
    spec:
      containers:
        - name: node-exporter
          image: prom/node-exporter:v1.7.0
          ports:
            - containerPort: 9100
          resources:
            limits:
              memory: "128Mi"
              cpu: "100m"
          volumeMounts:
            - name: proc
              mountPath: /host/proc
              readOnly: true
            - name: sys
              mountPath: /host/sys
              readOnly: true
      volumes:
        - name: proc
          hostPath:
            path: /proc
        - name: sys
          hostPath:
            path: /sys</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_comandos_útiles_para_gestionar_daemonsets">Comandos útiles para gestionar DaemonSets</h4>
<div class="listingblock">
<div class="title">Crear el DaemonSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f node-exporter-daemonset.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Listar los pods creados por el DaemonSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get pods -l app=node-exporter -o wide</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ver en qué nodos está corriendo cada pod:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get pods -o wide</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Actualizar el DaemonSet (por ejemplo, nueva imagen):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl set image daemonset/node-exporter node-exporter=prom/node-exporter:v1.8.0</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Eliminar el DaemonSet:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl delete daemonset node-exporter</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_con_daemonsets">Buenas prácticas con DaemonSets</h4>
<div class="ulist">
<ul>
<li>
<p>Usa <code>nodeSelector</code>, <code>affinity</code> o <code>tolerations</code> para limitar la ejecución a nodos específicos si no necesitas que el DaemonSet se ejecute en todos los nodos.</p>
<div class="ulist">
<ul>
<li>
<p><code>nodeSelector</code> permite seleccionar nodos basados en etiquetas.</p>
</li>
<li>
<p><code>affinity</code> ofrece una selección más avanzada, permitiendo definir reglas complejas.</p>
</li>
<li>
<p><code>tolerations</code> permite que los pods se ejecuten en nodos con taints específicos.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Configura <code>hostPath</code> con precaución, ya que puede afectar la seguridad y la portabilidad de los pods.</p>
</li>
<li>
<p>Define recursos (<code>requests</code> y <code>limits</code>) para evitar sobrecargar los nodos.</p>
<div class="ulist">
<ul>
<li>
<p><code>requests</code> especifica la cantidad mínima de recursos que el pod necesita.</p>
</li>
<li>
<p><code>limits</code> define la cantidad máxima de recursos que el pod puede consumir.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Supervisa el estado de los pods del DaemonSet para detectar fallos o nodos no cubiertos.</p>
</li>
<li>
<p>Utiliza la estrategia <code>RollingUpdate</code> para actualizaciones seguras y progresivas.</p>
</li>
<li>
<p>Documenta el propósito de cada DaemonSet y los recursos que gestiona.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jobs_y_cronjobs_ejecución_de_tareas_puntuales_y_programadas">Jobs y CronJobs: ejecución de tareas puntuales y programadas</h3>
<div class="paragraph">
<p>Un <strong>Job</strong> en Kubernetes es un recurso que permite ejecutar tareas puntuales o por lotes, garantizando que una o varias ejecuciones finalicen correctamente. Un <strong>CronJob</strong> extiende este concepto permitiendo programar la ejecución periódica de Jobs según una expresión cron, similar a los cron jobs de sistemas Unix.</p>
</div>
<div class="sect3">
<h4 id="_características_principales_de_los_jobs">Características principales de los Jobs</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Ejecución garantizada</strong>: Un Job asegura que una tarea se ejecute hasta completarse con éxito, recreando pods si es necesario.</p>
</li>
<li>
<p><strong>Control de concurrencia</strong>: Puedes definir cuántos pods se ejecutan en paralelo (<code>parallelism</code>) y cuántas ejecuciones deben completarse (<code>completions</code>).</p>
</li>
<li>
<p><strong>Reintentos automáticos</strong>: Si un pod falla, el Job puede reintentarlo hasta alcanzar el límite definido por <code>backoffLimit</code>.</p>
</li>
<li>
<p><strong>Indexed Jobs</strong>: Permiten asignar un índice único a cada pod, útil para tareas distribuidas o procesamiento de lotes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_básico_de_job">Ejemplo básico de Job</h4>
<div class="paragraph">
<p>A continuación, un manifiesto YAML de un Job que imprime "Hola Kubernetes" y termina:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: batch/v1
kind: Job
metadata:
  name: hola-job
spec:
  template:
    spec:
      containers:
        - name: hola
          image: busybox
          command: ["echo", "Hola Kubernetes"]
      restartPolicy: Never</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Crear el Job:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f hola-job.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Verificar el estado y logs:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get jobs
kubectl get pods --selector=job-name=hola-job
kubectl logs &lt;nombre-del-pod&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_job_con_múltiples_ejecuciones_y_concurrencia">Ejemplo de Job con múltiples ejecuciones y concurrencia</h4>
<div class="paragraph">
<p>Puedes definir Jobs que ejecuten varias tareas en paralelo:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: batch/v1
kind: Job
metadata:
  name: multi-job
spec:
  completions: 5
  parallelism: 2
  template:
    spec:
      containers:
        - name: worker
          image: busybox
          command: ["sh", "-c", "echo Trabajo $((RANDOM % 100))"]
      restartPolicy: Never</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>completions: 5</code>: El Job se considera exitoso cuando 5 ejecuciones han terminado correctamente.</p>
</li>
<li>
<p><code>parallelism: 2</code>: Hasta 2 pods pueden ejecutarse en paralelo.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_indexed_jobs">Indexed Jobs</h4>
<div class="paragraph">
<p>Permiten que cada pod reciba un índice único a través de la variable de entorno <code>JOB_COMPLETION_INDEX</code>, útil para procesamiento distribuido:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: batch/v1
kind: Job
metadata:
  name: indexed-job
spec:
  completions: 3
  parallelism: 3
  completionMode: Indexed
  template:
    spec:
      containers:
        - name: worker
          image: busybox
          command: ["sh", "-c", "echo Soy el índice $JOB_COMPLETION_INDEX"]
      restartPolicy: Never</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_características_principales_de_los_cronjobs">Características principales de los CronJobs</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Programación periódica</strong>: Ejecutan Jobs automáticamente según una expresión cron (<code>schedule</code>).</p>
</li>
<li>
<p><strong>Control de concurrencia</strong>: Puedes definir si se permiten ejecuciones solapadas (<code>concurrencyPolicy</code>).</p>
</li>
<li>
<p><strong>Historial de ejecuciones</strong>: Controla cuántos Jobs exitosos o fallidos se mantienen (<code>successfulJobsHistoryLimit</code>, <code>failedJobsHistoryLimit</code>).</p>
</li>
<li>
<p><strong>Soporte para zonas horarias</strong>: Desde Kubernetes 1.24, puedes especificar la zona horaria (<code>timeZone</code>).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_básico_de_cronjob">Ejemplo básico de CronJob</h4>
<div class="paragraph">
<p>Un CronJob que imprime la fecha y hora cada minuto:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: batch/v1
kind: CronJob
metadata:
  name: fecha-cronjob
spec:
  schedule: "*/1 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - name: fecha
              image: busybox
              command: ["date"]
          restartPolicy: OnFailure</code></pre>
</div>
</div>
<div class="paragraph">
<p>En el ejemplo anterior:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spec</code>: Especificaciones del CronJob, que incluye:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>schedule</code>: Expresión cron que define la programación.</p>
</li>
<li>
<p><code>jobTemplate</code>: Plantilla del Job que se ejecutará según la programación.</p>
</li>
</ol>
</div>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. El objeto schedule define la frecuencia de ejecución usando formato cron estándar:</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expresión</th>
<th class="tableblock halign-left valign-top">Significado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*/1 * * * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cada minuto</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 * * * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cada hora (minuto 0)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 * * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cada día a medianoche</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 * * 0</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cada domingo a medianoche</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 1 * *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primer día de cada mes a medianoche</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 1 1 *</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primer día de enero a medianoche</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0 0 * * 1-5</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lunes a viernes a medianoche</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@hourly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cada hora</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@daily</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cada día</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@weekly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cada semana</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@monthly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cada mes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@yearly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cada año</p></td>
</tr>
</tbody>
</table>
<div class="ulist">
<div class="title">Formato de la expresión cron: <code>minuto hora día-mes mes día-semana</code></div>
<ul>
<li>
<p>Valores de 0-59 para minutos</p>
</li>
<li>
<p>Valores de 0-23 para horas</p>
</li>
<li>
<p>Valores de 1-31 para día del mes</p>
</li>
<li>
<p>Valores de 1-12 para mes</p>
</li>
<li>
<p>Valores de 0-6 para día de la semana (0 = domingo)</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Crear el CronJob:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f fecha-cronjob.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Verificar ejecuciones:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get cronjobs
kubectl get jobs
kubectl get pods --selector=job-name=&lt;nombre-del-job&gt;
kubectl logs &lt;nombre-del-pod&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_cronjob_con_backup_de_base_de_datos">Ejemplo de CronJob con backup de base de datos</h4>
<div class="paragraph">
<p>Un CronJob que ejecuta un script de backup cada hora y almacena el resultado en un volumen persistente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: batch/v1
kind: CronJob
metadata:
  name: backup-db
spec:
  schedule: "0 * * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - name: backup
              image: mysql:8
              command: ["sh", "-c", "mysqldump -h db -u root -p$MYSQL_ROOT_PASSWORD basededatos &gt; /backup/backup.sql"]
              env:
                - name: MYSQL_ROOT_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      name: db-secret
                      key: password
              volumeMounts:
                - name: backup-vol
                  mountPath: /backup
          restartPolicy: OnFailure
          volumes:
            - name: backup-vol
              persistentVolumeClaim:
                claimName: backup-pvc</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_con_jobs_y_cronjobs">Buenas prácticas con Jobs y CronJobs</h4>
<div class="ulist">
<ul>
<li>
<p>Usa restartPolicy: <code>Never</code> o <code>OnFailure</code> según el caso.</p>
<div class="ulist">
<ul>
<li>
<p><code>Never</code>: No reinicia el pod si falla.</p>
</li>
<li>
<p><code>OnFailure</code>: Reinicia el pod si falla, útil para tareas que pueden ser reintentadas.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Controla el número de ejecuciones y la concurrencia para evitar sobrecargar el clúster.</p>
</li>
<li>
<p>Elimina Jobs y pods antiguos para liberar recursos, ajustando los límites de historial.</p>
</li>
<li>
<p>Supervisa el estado y los logs de los Jobs para detectar fallos o ejecuciones incompletas.</p>
</li>
<li>
<p>Usa variables de entorno y Secrets para gestionar credenciales de forma segura.</p>
</li>
<li>
<p>Documenta la programación y el propósito de cada CronJob.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_gráfico_2">Resumen gráfico</h4>
<div class="imageblock">
<div class="content">
<img src="jobs-cronjobs.png" alt="jobs cronjobs" width="407" height="601">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_services_comunicación_entre_componentes">Services: comunicación entre componentes</h3>
<div class="paragraph">
<p>Un <strong>Service</strong> expone uno o varios pods bajo una dirección IP y un nombre DNS estable dentro del clúster. Facilita la comunicación interna y externa entre componentes, gestionando el balanceo de carga y el descubrimiento de servicios. Tipos comunes: ClusterIP, NodePort, LoadBalancer e Ingress.</p>
</div>
<div class="sect3">
<h4 id="_tipos_de_servicios">Tipos de servicios</h4>
<div class="ulist">
<div class="title">Kubernetes ofrece varios tipos de servicios para exponer aplicaciones y gestionar la comunicación entre pods y con el exterior:</div>
<ul>
<li>
<p><strong>ClusterIP</strong>: Es el tipo por defecto. Expone el servicio en una IP interna accesible solo dentro del clúster. Ideal para comunicación interna entre pods.</p>
</li>
<li>
<p><strong>NodePort</strong>: Expone el servicio en un puerto específico de cada nodo del clúster, permitiendo el acceso externo a través de la IP del nodo y el puerto asignado.</p>
</li>
<li>
<p><strong>LoadBalancer</strong>: Proporciona una IP externa mediante un balanceador de carga (usualmente en entornos cloud), permitiendo el acceso desde fuera del clúster.</p>
</li>
<li>
<p><strong>ExternalName</strong>: Asocia el servicio a un nombre DNS externo, redirigiendo el tráfico a recursos fuera del clúster.</p>
</li>
<li>
<p><strong>Headless Service</strong>: Cuando se define con <code>clusterIP: None</code>, no asigna una IP virtual y permite el descubrimiento directo de los pods, útil para bases de datos o aplicaciones stateful.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ciclo_de_vida_de_un_service">Ciclo de vida de un Service</h4>
<div class="paragraph">
<p>El ciclo de vida de un Service en Kubernetes comienza con su creación mediante un manifiesto YAML o un comando <code>kubectl</code>. Una vez creado, el Service asigna una IP virtual y, según el tipo, puede asignar un puerto en los nodos o solicitar un balanceador de carga externo.</p>
</div>
<div class="paragraph">
<p>El Service monitoriza continuamente los endpoints (pods) que coinciden con su selector de labels, actualizando automáticamente la lista de pods disponibles para recibir tráfico. Si los pods asociados cambian (por ejemplo, por escalado o actualización), el Service ajusta sus endpoints sin necesidad de ser recreado.</p>
</div>
<div class="paragraph">
<p>El ciclo de vida termina cuando el Service es eliminado, liberando la IP y los recursos asociados. Durante todo su ciclo, el Service garantiza la conectividad y el balanceo de carga entre los pods y, si corresponde, con el exterior del clúster.</p>
</div>
</div>
<div class="sect3">
<h4 id="_características_principales_de_los_services">Características principales de los Services</h4>
<div class="ulist">
<ul>
<li>
<p><strong>IP virtual</strong>: Cada Service tiene una IP virtual que actúa como punto de acceso para los pods asociados, permitiendo la comunicación sin necesidad de conocer las IPs individuales de los pods.</p>
</li>
<li>
<p><strong>Selector</strong>: Los Services utilizan labels para seleccionar los pods que deben recibir el tráfico. Esto permite agrupar y gestionar dinámicamente los pods asociados.</p>
</li>
<li>
<p><strong>Endpoints</strong>: Los Services mantienen una lista de endpoints (pods) que coinciden con su selector, actualizándola automáticamente a medida que los pods cambian.</p>
</li>
<li>
<p><strong>ClusterIP/External IP</strong>: Indica si el Service tiene asignada una IP interna o externa.</p>
</li>
<li>
<p><strong>Ports</strong>: Puertos expuestos por el Service y su correspondencia con los pods.</p>
</li>
<li>
<p><strong>Session Affinity</strong>: Permite mantener la sesión del cliente en el mismo pod durante un tiempo determinado, útil para aplicaciones que requieren persistencia de sesión.</p>
</li>
<li>
<p><strong>Health Checks</strong>: Comprobaciones de estado que determinan si los pods asociados están disponibles y listos para recibir tráfico.</p>
</li>
<li>
<p><strong>Load Balancing</strong>: Distribución del tráfico entre los pods asociados al Service, garantizando alta disponibilidad y rendimiento.</p>
</li>
<li>
<p><strong>DNS interno</strong>: Kubernetes asigna un nombre DNS al Service, permitiendo que los pods se comuniquen usando ese nombre en lugar de la IP.</p>
</li>
<li>
<p><strong>Annotations</strong>: Metadatos adicionales que pueden ser utilizados por controladores de servicios o herramientas externas para configurar características avanzadas.</p>
</li>
<li>
<p><strong>Labels</strong>: Etiquetas que permiten identificar y seleccionar los pods asociados al Service.</p>
</li>
<li>
<p><strong>Type</strong>: Tipo de Service (ClusterIP, NodePort, LoadBalancer, etc.) que determina cómo se expone el servicio y cómo se accede a él.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Un ejemplo de un Service con gran parte de estas características sería:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Service
metadata:
  name: mi-servicio
  labels:
    app: mi-app
    entorno: produccion
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8080"
spec:
  type: LoadBalancer
  selector:
    app: mi-app
    version: v1
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 8080
    - name: https
      protocol: TCP
      port: 443
      targetPort: 8443
  sessionAffinity: ClientIP
  externalTrafficPolicy: Local</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">En este ejemplo:</div>
<ul>
<li>
<p>El Service se llama <code>mi-servicio</code> y expone dos puertos (HTTP y HTTPS).</p>
</li>
<li>
<p>Usa el tipo <code>LoadBalancer</code> para exponer la aplicación al exterior (en cloud o con MetalLB).</p>
</li>
<li>
<p>Selecciona pods con las etiquetas <code>app: mi-app</code> y <code>version: v1</code>.</p>
</li>
<li>
<p>Incluye labels y annotations útiles para monitorización y organización.</p>
</li>
<li>
<p>Habilita afinidad de sesión (<code>sessionAffinity: ClientIP</code>) para mantener la sesión del cliente en el mismo pod.</p>
</li>
<li>
<p>Usa <code>externalTrafficPolicy: Local</code> para preservar la IP de origen del cliente.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Para lanzar el Service, guarda el contenido en un archivo llamado <code>mi-servicio.yaml</code> y ejecuta:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f mi-servicio.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Puedes consultar y probar el Service con:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get service mi-servicio
kubectl describe service mi-servicio</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_services">Gestión de Services</h4>
<div class="paragraph">
<p>La gestión de Services en Kubernetes se realiza principalmente mediante manifiestos YAML y la herramienta <code>kubectl</code>. Permite crear, listar, actualizar, eliminar y exponer servicios de manera flexible para facilitar la comunicación entre pods y con el exterior.</p>
</div>
<div class="listingblock">
<div class="title">Crear un Service:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f service.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Listar Services:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get services</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ver detalles de un Service:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl describe service &lt;nombre-del-service&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Actualizar un Service:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f service.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Eliminar un Service:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl delete service &lt;nombre-del-service&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Exponer un Deployment como Service:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl expose deployment &lt;nombre-del-deployment&gt; --port=80 --target-port=8080 --type=NodePort</code></pre>
</div>
</div>
<div class="paragraph">
<p>La gestión adecuada de los Services es fundamental para garantizar la conectividad, el balanceo de carga y la exposición segura de las aplicaciones dentro y fuera del clúster.</p>
</div>
</div>
<div class="sect3">
<h4 id="_endpoints_y_descubrimiento_de_servicios">Endpoints y descubrimiento de servicios</h4>
<div class="paragraph">
<p>Un <strong>Endpoint</strong> en Kubernetes representa la lista de direcciones IP y puertos de los pods que están asociados a un Service. Cuando un Service se crea, Kubernetes genera automáticamente un objeto Endpoint que se actualiza dinámicamente conforme los pods coinciden o dejan de coincidir con el selector del Service.</p>
</div>
<div class="ulist">
<div class="title">El descubrimiento de servicios se realiza de dos formas principales:</div>
<ul>
<li>
<p><strong>Variables de entorno</strong>: Kubernetes inyecta variables de entorno en los pods con la información de los servicios disponibles en el mismo namespace.</p>
</li>
<li>
<p><strong>DNS interno</strong>: Kubernetes crea automáticamente registros DNS para cada Service, permitiendo que los pods resuelvan el nombre del servicio (por ejemplo, <code>mi-servicio.mi-namespace.svc.cluster.local</code>) y se comuniquen usando ese nombre.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Puedes consultar los endpoints de un Service con:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get endpoints
kubectl describe service &lt;nombre-del-service&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>El mecanismo de endpoints y el DNS interno facilitan el descubrimiento y la comunicación entre microservicios dentro del clúster, permitiendo arquitecturas dinámicas y escalables.</p>
</div>
</div>
<div class="sect3">
<h4 id="_proxies_y_balanceo_de_carga">Proxies y balanceo de carga</h4>
<div class="paragraph">
<p>En Kubernetes, el balanceo de carga y el proxy de red son fundamentales para distribuir el tráfico entre los pods y garantizar la alta disponibilidad de las aplicaciones.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>kube-proxy</strong>: Es el componente encargado de implementar las reglas de red en cada nodo, actuando como proxy para el tráfico dirigido a los Services. Puede funcionar en modo iptables o IPVS, redirigiendo el tráfico a los pods disponibles según el selector del Service.</p>
</li>
<li>
<p><strong>Balanceo de carga interno</strong>: Todos los Services de tipo ClusterIP y NodePort utilizan kube-proxy para balancear el tráfico entre los pods asociados.</p>
</li>
<li>
<p><strong>Balanceo de carga externo</strong>: Los Services de tipo LoadBalancer solicitan un balanceador de carga externo (por ejemplo, de un proveedor cloud) para exponer la aplicación fuera del clúster y distribuir el tráfico entrante entre los nodos y pods.</p>
</li>
<li>
<p><strong>Ingress</strong>: Para tráfico HTTP/HTTPS, los recursos Ingress y sus controladores permiten balancear y enrutar el tráfico a diferentes servicios internos, aplicando reglas avanzadas como rutas, TLS y autenticación.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El uso de proxies y balanceadores de carga en Kubernetes permite escalar aplicaciones de forma eficiente y garantizar la disponibilidad y el rendimiento ante cambios en el clúster.</p>
</div>
</div>
<div class="sect3">
<h4 id="_dns_interno_de_kubernetes">DNS interno de Kubernetes</h4>
<div class="paragraph">
<p>Kubernetes incluye un servicio de DNS interno que resuelve automáticamente los nombres de los servicios y pods dentro del clúster. Cuando se crea un Service, Kubernetes genera un registro DNS con el formato <code>&lt;nombre-del-service&gt;.&lt;namespace&gt;.svc.cluster.local</code>, permitiendo que cualquier pod pueda comunicarse con el servicio usando ese nombre.</p>
</div>
<div class="paragraph">
<p>El DNS interno es gestionado por el componente <strong>CoreDNS</strong> (o kube-dns en versiones antiguas), que se despliega como un conjunto de pods dentro del clúster. CoreDNS responde a las consultas DNS de los pods y resuelve tanto servicios como pods (si está habilitado el subdominio <code>pod</code>).</p>
</div>
<div class="listingblock">
<div class="title">Un Service llamado <code>miapp</code> en el namespace <code>produccion</code> será accesible desde cualquier pod como:</div>
<div class="content">
<pre>miapp.produccion.svc.cluster.local</pre>
</div>
</div>
<div class="ulist">
<div class="title">Ventajas del DNS interno:</div>
<ul>
<li>
<p>Facilita el descubrimiento y la comunicación entre servicios sin necesidad de conocer direcciones IP.</p>
</li>
<li>
<p>Permite cambiar la infraestructura subyacente sin modificar la configuración de las aplicaciones.</p>
</li>
<li>
<p>Soporta subdominios y nombres cortos para facilitar la usabilidad.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Puedes comprobar la resolución DNS desde un pod ejecutando:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">nslookup &lt;nombre-del-service&gt;
# o
dig &lt;nombre-del-service&gt;.&lt;namespace&gt;.svc.cluster.local</code></pre>
</div>
</div>
<div class="paragraph">
<p>El DNS interno es esencial para arquitecturas de microservicios y despliegues dinámicos en Kubernetes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exposición_de_servicios_al_exterior">Exposición de servicios al exterior</h4>
<div class="paragraph">
<p>Para exponer aplicaciones fuera del clúster de Kubernetes, existen varias opciones según el tipo de acceso y el entorno:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>NodePort</strong>: Expone el servicio en un puerto específico de cada nodo, permitiendo el acceso externo a través de la IP del nodo y el puerto asignado. Es sencillo, pero no recomendado para producción debido a limitaciones de seguridad y escalabilidad.</p>
</li>
<li>
<p><strong>LoadBalancer</strong>: Solicita un balanceador de carga externo (proporcionado por el proveedor cloud) que asigna una IP pública y distribuye el tráfico entrante entre los nodos y pods. Es la opción más común en entornos cloud.</p>
</li>
<li>
<p><strong>Ingress</strong>: Permite exponer múltiples servicios HTTP/HTTPS bajo un mismo punto de entrada, gestionando rutas, certificados TLS y reglas avanzadas mediante un controlador Ingress. Es ideal para aplicaciones web y microservicios.</p>
</li>
<li>
<p><strong>ExternalName</strong>: Redirige el tráfico a un nombre DNS externo, útil para integrar servicios fuera del clúster.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de exposición usando NodePort:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Service
metadata:
  name: mi-servicio
spec:
  type: NodePort
  selector:
    app: mi-app
  ports:
    - port: 80
      targetPort: 8080
      nodePort: 30080</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de exposición usando LoadBalancer:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Service
metadata:
  name: mi-servicio
spec:
  type: LoadBalancer
  selector:
    app: mi-app
  ports:
    - port: 80
      targetPort: 8080</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de exposición usando Ingress:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: mi-ingress
spec:
  rules:
    - host: miapp.ejemplo.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: mi-servicio
                port:
                  number: 80</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de exposición usando ExternalName:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Service
metadata:
  name: mi-servicio-external
spec:
  type: ExternalName
  externalName: ejemplo.com</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ingress_gestión_de_tráfico_http">Ingress: gestión de tráfico HTTP</h4>
<div class="paragraph">
<p>Un <strong>Ingress</strong> es un recurso de Kubernetes que gestiona el acceso externo HTTP y HTTPS a los servicios del clúster. Permite definir reglas de enrutamiento basadas en rutas, dominios y subdominios, así como gestionar certificados TLS para tráfico seguro.</p>
</div>
<div class="paragraph">
<p>El Ingress actúa como punto de entrada único para múltiples servicios, facilitando la publicación de aplicaciones web y microservicios bajo diferentes rutas o dominios.</p>
</div>
<div class="ulist">
<div class="title">Las reglas de Ingress permiten:</div>
<ul>
<li>
<p>Redirigir tráfico a diferentes servicios según la URL o el host.</p>
</li>
<li>
<p>Aplicar certificados TLS para HTTPS.</p>
</li>
<li>
<p>Configurar redirecciones, autenticación y otras políticas avanzadas (según el controlador Ingress utilizado).</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo básico de recurso Ingress:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ejemplo-ingress
spec:
  rules:
    - host: miapp.ejemplo.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: mi-servicio
                port:
                  number: 80</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para que los recursos Ingress funcionen, es necesario desplegar un <strong>Ingress Controller</strong> en el clúster (por ejemplo, NGINX Ingress Controller, Traefik, etc.), que se encargará de procesar las reglas y enrutar el tráfico adecuadamente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ingress_controllers">Ingress Controllers</h4>
<div class="paragraph">
<p>Un <strong>Ingress Controller</strong> es el componente encargado de implementar las reglas definidas en los recursos Ingress y enrutar el tráfico HTTP/HTTPS externo hacia los servicios internos del clúster. Sin un Ingress Controller desplegado, los recursos Ingress no tendrán efecto.</p>
</div>
<div class="ulist">
<div class="title">Existen varios controladores populares, entre ellos:</div>
<ul>
<li>
<p><strong>NGINX Ingress Controller</strong>: El más utilizado, flexible y ampliamente soportado.</p>
</li>
<li>
<p><strong>Traefik</strong>: Sencillo de configurar, con soporte para múltiples protocolos y características avanzadas.</p>
</li>
<li>
<p><strong>HAProxy Ingress</strong>: Basado en HAProxy, ideal para escenarios de alto rendimiento.</p>
</li>
<li>
<p><strong>Controladores específicos de proveedores cloud</strong>: Como AWS ALB Ingress Controller, GKE Ingress, etc.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de despliegue de NGINX Ingress Controller:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.10.1/deploy/static/provider/cloud/deploy.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>Una vez desplegado el Ingress Controller, los recursos Ingress definidos en el clúster comenzarán a funcionar y a enrutar el tráfico según las reglas especificadas.</p>
</div>
<div class="paragraph">
<p>Es importante elegir el Ingress Controller que mejor se adapte a las necesidades de la aplicación y del entorno de despliegue.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_de_ingress">Configuración de Ingress</h4>
<div class="paragraph">
<p>La configuración de un recurso Ingress en Kubernetes se realiza mediante un manifiesto YAML donde se definen las reglas de enrutamiento, los hosts, los paths y, opcionalmente, la configuración de TLS para HTTPS.</p>
</div>
<div class="olist arabic">
<div class="title">Pasos básicos para configurar un Ingress:</div>
<ol class="arabic">
<li>
<p>Asegúrate de tener un Ingress Controller desplegado en el clúster (por ejemplo, NGINX Ingress Controller).</p>
</li>
<li>
<p>Define el recurso Ingress especificando los hosts, paths y servicios de destino.</p>
</li>
<li>
<p>(Opcional) Configura certificados TLS para habilitar HTTPS.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Ejemplo de configuración de Ingress con TLS:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: mi-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  tls:
    - hosts:
        - miapp.ejemplo.com
      secretName: miapp-tls-secret
  rules:
    - host: miapp.ejemplo.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: mi-servicio
                port:
                  number: 80</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Puntos clave:</div>
<ul>
<li>
<p>Las <strong>annotations</strong> permiten personalizar el comportamiento del Ingress Controller (por ejemplo, reescritura de URLs, autenticación, rate limiting, etc.).</p>
</li>
<li>
<p>El bloque <code>tls</code> habilita HTTPS usando un secreto de tipo TLS previamente creado en el mismo namespace.</p>
</li>
<li>
<p>Puedes definir múltiples reglas para enrutar tráfico a diferentes servicios según el host o la ruta.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consulta la documentación del Ingress Controller que utilices para conocer todas las opciones de configuración disponibles.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_para_servicios">Buenas prácticas para servicios</h4>
<div class="ulist">
<div class="title">Algunas recomendaciones incluyen:</div>
<ul>
<li>
<p>Utiliza <strong>selectors</strong> claros y consistentes en los Services para evitar conflictos y facilitar el mantenimiento.</p>
</li>
<li>
<p>Prefiere <strong>ClusterIP</strong> para comunicación interna y expón servicios al exterior solo cuando sea necesario (NodePort, LoadBalancer o Ingress).</p>
</li>
<li>
<p>Asigna <strong>labels</strong> y <strong>annotations</strong> descriptivas a los Services para mejorar la gestión y la observabilidad.</p>
</li>
<li>
<p>Limita el uso de <strong>NodePort</strong> en producción; opta por <strong>LoadBalancer</strong> o <strong>Ingress</strong> para mayor seguridad y escalabilidad.</p>
</li>
<li>
<p>Documenta los puertos y protocolos utilizados por cada Service.</p>
</li>
<li>
<p>Revisa y restringe los endpoints expuestos para minimizar la superficie de ataque.</p>
</li>
<li>
<p>Usa <strong>ExternalName</strong> solo cuando sea imprescindible integrar servicios externos.</p>
</li>
<li>
<p>Versiona y revisa los manifiestos de Service junto con el resto de la infraestructura como código.</p>
</li>
<li>
<p>Supervisa el estado y los endpoints de los Services para detectar problemas de conectividad o balanceo.</p>
</li>
<li>
<p>Elimina los Services que ya no se utilicen para evitar confusiones y posibles riesgos de seguridad.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_namespaces_organización_lógica">Namespaces: organización lógica</h3>
<div class="paragraph">
<p>Los <strong>Namespaces</strong> en Kubernetes permiten dividir los recursos del clúster en espacios lógicos aislados. Son útiles para separar entornos (desarrollo, pruebas, producción), equipos o proyectos dentro de un mismo clúster, facilitando la gestión de permisos, recursos y políticas.</p>
</div>
<div class="ulist">
<div class="title">Características principales:</div>
<ul>
<li>
<p>Aíslan recursos como pods, servicios, ConfigMaps y Secrets.</p>
</li>
<li>
<p>Permiten aplicar cuotas de recursos y límites por namespace.</p>
</li>
<li>
<p>Facilitan la gestión de RBAC (roles y permisos) por entorno o equipo.</p>
</li>
<li>
<p>Los objetos sin namespace explícito se crean en el namespace <code>default</code>.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Comandos útiles:</div>
<ul>
<li>
<p>Listar namespaces:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get namespaces</code></pre>
</div>
</div>
</li>
<li>
<p>Crear un namespace:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl create namespace mi-namespace</code></pre>
</div>
</div>
</li>
<li>
<p>Ejecutar comandos en un namespace específico:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get pods -n mi-namespace</code></pre>
</div>
</div>
</li>
<li>
<p>Definir el namespace en un manifiesto YAML:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: ejemplo-pod
  namespace: mi-namespace
spec:
  containers:
    - name: nginx
      image: nginx</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Buenas prácticas:</div>
<ul>
<li>
<p>Utiliza namespaces para separar entornos y equipos.</p>
</li>
<li>
<p>Aplica políticas de seguridad y cuotas de recursos por namespace.</p>
</li>
<li>
<p>Nombra los namespaces de forma clara y consistente.</p>
</li>
<li>
<p>Supervisa el uso de recursos y la actividad en cada namespace.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El uso adecuado de namespaces mejora la organización, seguridad y escalabilidad en clústeres Kubernetes multiusuario o multiproyecto.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_4_conceptos_avanzados_de_pods_y_recursos">Módulo 4: Conceptos Avanzados de Pods y Recursos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este módulo profundiza en conceptos avanzados para la gestión de pods, control de recursos, scheduling avanzado y patrones de contenedores en Kubernetes.</p>
</div>
<div class="sect2">
<h3 id="_init_containers">Init Containers</h3>
<div class="paragraph">
<p>Los <strong>Init Containers</strong> son contenedores especializados que se ejecutan y completan su ejecución antes de que los contenedores principales de la aplicación inicien. Son útiles para tareas de inicialización como esperar por servicios dependientes, configurar permisos, descargar configuraciones o preparar el entorno.</p>
</div>
<div class="sect3">
<h4 id="_características_de_los_init_containers">Características de los Init Containers</h4>
<div class="ulist">
<ul>
<li>
<p>Se ejecutan secuencialmente en el orden en que están definidos.</p>
</li>
<li>
<p>Cada init container debe completarse exitosamente antes de que el siguiente inicie.</p>
</li>
<li>
<p>Si un init container falla, Kubernetes reinicia el pod hasta que tenga éxito.</p>
</li>
<li>
<p>Pueden tener imágenes diferentes a los contenedores principales.</p>
</li>
<li>
<p>Tienen acceso a Secrets, ConfigMaps y volúmenes del pod.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_casos_de_uso_comunes">Casos de uso comunes</h4>
<div class="ulist">
<ul>
<li>
<p>Esperar a que un servicio externo esté disponible antes de iniciar la aplicación.</p>
</li>
<li>
<p>Clonar repositorios git o descargar archivos de configuración.</p>
</li>
<li>
<p>Ejecutar scripts de inicialización de base de datos.</p>
</li>
<li>
<p>Configurar permisos en volúmenes compartidos.</p>
</li>
<li>
<p>Registrar el pod en un sistema de descubrimiento de servicios.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_init_container">Ejemplo de Init Container</h4>
<div class="listingblock">
<div class="title">Pod con init container que espera por un servicio:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: mi-app
spec:
  initContainers:
    - name: esperar-db
      image: busybox:1.28
      command: ['sh', '-c', 'until nslookup mi-db-service; do echo esperando por db; sleep 2; done']
    - name: configurar-permisos
      image: busybox:1.28
      command: ['sh', '-c', 'chmod 777 /data']
      volumeMounts:
        - name: datos
          mountPath: /data
  containers:
    - name: app
      image: mi-app:latest
      volumeMounts:
        - name: datos
          mountPath: /data
  volumes:
    - name: datos
      emptyDir: {}</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Ejemplo de init container:</div>
<ul>
<li>
<p>El primer init container espera a que el servicio <code>mi-db-service</code> esté disponible en el DNS.</p>
</li>
<li>
<p>El segundo init container configura permisos en el volumen compartido.</p>
</li>
<li>
<p>Los contenedores principales solo inician cuando ambos init containers han completado exitosamente.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_verificación_del_estado_de_init_containers">Verificación del estado de Init Containers</h4>
<div class="listingblock">
<div class="title">Ver el estado de los init containers:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl describe pod mi-app
kubectl get pod mi-app -o jsonpath='{.status.initContainerStatuses[*].state}'</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Mantén los init containers simples y con un propósito único.</p>
</li>
<li>
<p>Define timeouts adecuados para evitar bloqueos indefinidos.</p>
</li>
<li>
<p>Usa imágenes ligeras (como busybox o alpine) cuando sea posible.</p>
</li>
<li>
<p>Documenta el propósito de cada init container.</p>
</li>
<li>
<p>Considera usar readiness probes en lugar de init containers para chequeos simples de disponibilidad.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_health_checks_probes_en_kubernetes">Health Checks: Probes en Kubernetes</h3>
<div class="paragraph">
<p>Las <strong>Probes</strong> (sondas) son mecanismos de Kubernetes para verificar el estado de salud de los contenedores y determinar si están listos para recibir tráfico o si necesitan ser reiniciados. Son fundamentales para lograr alta disponibilidad y self-healing.</p>
</div>
<div class="sect3">
<h4 id="_tipos_de_probes">Tipos de Probes</h4>
<div class="paragraph">
<p>Kubernetes ofrece tres tipos de probes:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Liveness Probe</strong>: Determina si un contenedor está vivo y funcionando correctamente. Si falla, Kubernetes reinicia el contenedor.</p>
</li>
<li>
<p><strong>Readiness Probe</strong>: Determina si un contenedor está listo para recibir tráfico. Si falla, el pod es removido de los endpoints del servicio.</p>
</li>
<li>
<p><strong>Startup Probe</strong>: Verifica si la aplicación ha iniciado correctamente. Útil para aplicaciones con tiempos de inicio lentos.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_métodos_de_verificación">Métodos de verificación</h4>
<div class="paragraph">
<p>Las probes pueden usar tres métodos diferentes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>HTTP GET</strong>: Realiza una petición HTTP a un endpoint. Éxito si el código de respuesta es 2xx o 3xx.</p>
</li>
<li>
<p><strong>TCP Socket</strong>: Intenta abrir una conexión TCP a un puerto. Éxito si la conexión se establece.</p>
</li>
<li>
<p><strong>Exec</strong>: Ejecuta un comando dentro del contenedor. Éxito si el comando retorna código 0.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_liveness_probe">Liveness Probe</h4>
<div class="paragraph">
<p>La liveness probe detecta si un contenedor está en un estado irrecuperable (por ejemplo, deadlock) y necesita ser reiniciado.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo con HTTP GET:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: liveness-http
spec:
  containers:
    - name: app
      image: mi-app:latest
      livenessProbe:
        httpGet:
          path: /healthz
          port: 8080
          httpHeaders:
            - name: Custom-Header
              value: Awesome
        initialDelaySeconds: 15
        periodSeconds: 10
        timeoutSeconds: 5
        failureThreshold: 3
        successThreshold: 1</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo con comando exec:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: liveness-exec
spec:
  containers:
    - name: app
      image: mi-app:latest
      livenessProbe:
        exec:
          command:
            - cat
            - /tmp/healthy
        initialDelaySeconds: 5
        periodSeconds: 5</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_readiness_probe">Readiness Probe</h4>
<div class="paragraph">
<p>La readiness probe determina cuándo un pod está listo para recibir tráfico del servicio.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo con TCP Socket:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: readiness-tcp
spec:
  containers:
    - name: app
      image: mi-app:latest
      readinessProbe:
        tcpSocket:
          port: 8080
        initialDelaySeconds: 5
        periodSeconds: 10</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo combinando readiness y liveness:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
        - name: web
          image: nginx:1.25
          ports:
            - containerPort: 80
          livenessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 5</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_startup_probe">Startup Probe</h4>
<div class="paragraph">
<p>Para aplicaciones que tardan mucho en iniciar, la startup probe evita que la liveness probe reinicie el contenedor prematuramente.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de startup probe:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: startup-example
spec:
  containers:
    - name: app
      image: mi-app-lenta:latest
      startupProbe:
        httpGet:
          path: /started
          port: 8080
        failureThreshold: 30
        periodSeconds: 10
      livenessProbe:
        httpGet:
          path: /healthz
          port: 8080
        periodSeconds: 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Con esta configuración, la aplicación tiene hasta 300 segundos (30 × 10) para iniciar antes de que la liveness probe comience a verificar.</p>
</div>
</div>
<div class="sect3">
<h4 id="_parámetros_de_configuración">Parámetros de configuración</h4>
<div class="ulist">
<ul>
<li>
<p><code>initialDelaySeconds</code>: Tiempo de espera antes de la primera verificación.</p>
</li>
<li>
<p><code>periodSeconds</code>: Frecuencia de las verificaciones.</p>
</li>
<li>
<p><code>timeoutSeconds</code>: Tiempo máximo de espera para una respuesta.</p>
</li>
<li>
<p><code>successThreshold</code>: Número de verificaciones exitosas consecutivas requeridas.</p>
</li>
<li>
<p><code>failureThreshold</code>: Número de fallos consecutivos antes de tomar acción.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_2">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa liveness probes para detectar deadlocks o estados irrecuperables.</p>
</li>
<li>
<p>Usa readiness probes para controlar el tráfico durante inicios o mantenimientos.</p>
</li>
<li>
<p>No uses liveness probes para dependencias externas (usa readiness en su lugar).</p>
</li>
<li>
<p>Ajusta <code>initialDelaySeconds</code> según el tiempo de inicio de tu aplicación.</p>
</li>
<li>
<p>Mantén los endpoints de health check ligeros y rápidos.</p>
</li>
<li>
<p>No incluyas chequeos de dependencias críticas en liveness (podría causar reincios en cascada).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_de_recursos_requests_y_limits">Gestión de Recursos: Requests y Limits</h3>
<div class="paragraph">
<p>El control de recursos es fundamental para garantizar la estabilidad del clúster y un uso eficiente de los recursos disponibles. Kubernetes permite especificar cuántos recursos necesita (requests) y puede consumir (limits) cada contenedor.</p>
</div>
<div class="sect3">
<h4 id="_requests_vs_limits">Requests vs Limits</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Requests</strong>: Cantidad mínima de recursos garantizados para el contenedor. El scheduler usa este valor para decidir en qué nodo colocar el pod.</p>
</li>
<li>
<p><strong>Limits</strong>: Cantidad máxima de recursos que el contenedor puede consumir. Si se excede, el contenedor puede ser throttled (CPU) o killed (memoria).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_requests_y_limits">Ejemplo de requests y limits</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: recursos-ejemplo
spec:
  containers:
    - name: app
      image: nginx
      resources:
        requests:
          memory: "128Mi"
          cpu: "250m"
        limits:
          memory: "256Mi"
          cpu: "500m"</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo:
.Ejemplo de requests y limits:
- El pod requiere al menos 128 MiB de memoria y 0.25 CPU cores.
- Puede usar hasta 256 MiB de memoria y 0.5 CPU cores.</p>
</div>
</div>
<div class="sect3">
<h4 id="_unidades_de_medida">Unidades de medida</h4>
<div class="paragraph">
<p><strong>CPU</strong>:
- Se mide en cores (1 CPU = 1 core físico o virtual).
- Puede especificarse en milicores: <code>100m</code> = 0.1 cores.
- Ejemplos: <code>1</code>, <code>0.5</code>, <code>250m</code>, <code>2000m</code> (= 2 cores).</p>
</div>
<div class="paragraph">
<p><strong>Memoria</strong>:
- Se mide en bytes con sufijos: E, P, T, G, M, K o Ei, Pi, Ti, Gi, Mi, Ki.
- Ejemplos: <code>128Mi</code>, <code>1Gi</code>, <code>500M</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_qos_classes_quality_of_service">QoS Classes (Quality of Service)</h4>
<div class="paragraph">
<p>Según los requests y limits, Kubernetes asigna una clase de QoS a cada pod:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Guaranteed</strong>: Todos los contenedores tienen requests = limits para CPU y memoria.</p>
</li>
<li>
<p><strong>Burstable</strong>: Al menos un contenedor tiene requests &lt; limits.</p>
</li>
<li>
<p><strong>BestEffort</strong>: Ningún contenedor tiene requests ni limits.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Durante eviction por presión de recursos, BestEffort se elimina primero, luego Burstable, y por último Guaranteed.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de pod Guaranteed:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: guaranteed-pod
spec:
  containers:
    - name: app
      image: nginx
      resources:
        requests:
          memory: "200Mi"
          cpu: "500m"
        limits:
          memory: "200Mi"
          cpu: "500m"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_limitrange">LimitRange</h4>
<div class="paragraph">
<p>Un <strong>LimitRange</strong> establece restricciones de recursos por defecto, mínimos y máximos a nivel de namespace. Útil para evitar que pods consuman todos los recursos del clúster.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de LimitRange:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: LimitRange
metadata:
  name: limite-recursos
  namespace: produccion
spec:
  limits:
    - max:
        cpu: "2"
        memory: "2Gi"
      min:
        cpu: "100m"
        memory: "64Mi"
      default:
        cpu: "500m"
        memory: "256Mi"
      defaultRequest:
        cpu: "250m"
        memory: "128Mi"
      type: Container
    - max:
        cpu: "4"
        memory: "4Gi"
      min:
        cpu: "200m"
        memory: "128Mi"
      type: Pod</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ver LimitRanges en un namespace:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get limitrange -n produccion
kubectl describe limitrange limite-recursos -n produccion</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resourcequota">ResourceQuota</h4>
<div class="paragraph">
<p>Un <strong>ResourceQuota</strong> limita el consumo total de recursos en un namespace, controlando la cantidad agregada de recursos que pueden ser solicitados.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de ResourceQuota:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: ResourceQuota
metadata:
  name: cuota-produccion
  namespace: produccion
spec:
  hard:
    requests.cpu: "10"
    requests.memory: "20Gi"
    limits.cpu: "20"
    limits.memory: "40Gi"
    pods: "50"
    services: "10"
    persistentvolumeclaims: "20"
    secrets: "50"
    configmaps: "50"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ver ResourceQuotas:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get resourcequota -n produccion
kubectl describe resourcequota cuota-produccion -n produccion</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_3">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Siempre define requests para CPU y memoria en producción.</p>
</li>
<li>
<p>Establece limits para evitar que un pod consuma todos los recursos del nodo.</p>
</li>
<li>
<p>Usa LimitRange para valores por defecto y límites en namespaces.</p>
</li>
<li>
<p>Implementa ResourceQuotas en namespaces compartidos.</p>
</li>
<li>
<p>Monitorea el uso real de recursos y ajusta requests/limits según métricas.</p>
</li>
<li>
<p>Para aplicaciones críticas, usa QoS Guaranteed.</p>
</li>
<li>
<p>Deja margen entre requests y el total del nodo para el sistema operativo y componentes de Kubernetes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pod_scheduling_avanzado">Pod Scheduling Avanzado</h3>
<div class="paragraph">
<p>El scheduling en Kubernetes determina en qué nodo se ejecutará cada pod. Kubernetes ofrece mecanismos avanzados para controlar esta decisión mediante node selectors, affinity, anti-affinity, taints y tolerations.</p>
</div>
<div class="sect3">
<h4 id="_nodeselector">NodeSelector</h4>
<div class="paragraph">
<p>La forma más simple de restringir pods a nodos específicos. Usa labels en los nodos para seleccionarlos.</p>
</div>
<div class="listingblock">
<div class="title">Añadir label a un nodo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl label nodes worker-node-1 tipo-disco=ssd
kubectl label nodes worker-node-2 entorno=produccion</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Pod con nodeSelector:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-ssd
spec:
  nodeSelector:
    tipo-disco: ssd
  containers:
    - name: app
      image: nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_node_affinity">Node Affinity</h4>
<div class="paragraph">
<p>Ofrece reglas más expresivas y flexibles que nodeSelector. Permite reglas "requeridas" (hard) y "preferidas" (soft).</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de Node Affinity requerida:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: affinity-required
spec:
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: tipo-disco
                operator: In
                values:
                  - ssd
                  - nvme
              - key: zona
                operator: NotIn
                values:
                  - zona-restringida
  containers:
    - name: app
      image: nginx</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de Node Affinity preferida:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: affinity-preferred
spec:
  affinity:
    nodeAffinity:
      preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 80
          preference:
            matchExpressions:
              - key: tipo-disco
                operator: In
                values:
                  - ssd
        - weight: 20
          preference:
            matchExpressions:
              - key: zona
                operator: In
                values:
                  - zona-a
  containers:
    - name: app
      image: nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pod_affinity_y_anti_affinity">Pod Affinity y Anti-Affinity</h4>
<div class="paragraph">
<p>Controla cómo se distribuyen los pods en relación con otros pods, basándose en labels.</p>
</div>
<div class="paragraph">
<p><strong>Pod Affinity</strong>: Coloca pods cerca de otros pods (mismo nodo, zona, etc.).
<strong>Pod Anti-Affinity</strong>: Separa pods de otros pods.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de Pod Anti-Affinity (alta disponibilidad):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-ha
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      affinity:
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                  - key: app
                    operator: In
                    values:
                      - web
              topologyKey: kubernetes.io/hostname
      containers:
        - name: web
          image: nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este deployment asegura que cada réplica se ejecute en un nodo diferente.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de Pod Affinity (colocación):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: cache-client
spec:
  affinity:
    podAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        - labelSelector:
            matchExpressions:
              - key: app
                operator: In
                values:
                  - cache
          topologyKey: kubernetes.io/hostname
  containers:
    - name: app
      image: mi-app</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este pod se ejecutará en el mismo nodo que los pods con label <code>app=cache</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_taints_y_tolerations">Taints y Tolerations</h4>
<div class="paragraph">
<p><strong>Taints</strong> se aplican a nodos para repeler pods que no tengan la tolerancia correspondiente.
<strong>Tolerations</strong> se aplican a pods para permitirles ejecutarse en nodos con taints específicos.</p>
</div>
<div class="listingblock">
<div class="title">Añadir taint a un nodo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl taint nodes worker-node-1 tipo=gpu:NoSchedule
kubectl taint nodes worker-node-2 dedicado=backend:NoExecute
kubectl taint nodes worker-node-3 mantenimiento=true:PreferNoSchedule</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Tipos de efectos disponibles:</div>
<ul>
<li>
<p><code>NoSchedule</code>: No programa pods sin tolerancia (los existentes permanecen).</p>
</li>
<li>
<p><code>PreferNoSchedule</code>: Intenta no programar, pero no es estricto.</p>
</li>
<li>
<p><code>NoExecute</code>: No programa nuevos pods y elimina los existentes sin tolerancia.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Pod con tolerations:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-gpu
spec:
  tolerations:
    - key: "tipo"
      operator: "Equal"
      value: "gpu"
      effect: "NoSchedule"
    - key: "dedicado"
      operator: "Equal"
      value: "backend"
      effect: "NoExecute"
      tolerationSeconds: 3600
  containers:
    - name: app
      image: tensorflow/tensorflow:latest-gpu</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Eliminar taint de un nodo:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl taint nodes worker-node-1 tipo=gpu:NoSchedule-</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_casos_de_uso_comunes_2">Casos de uso comunes</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Node Affinity</strong>: Ejecutar pods en nodos con hardware específico (GPU, SSD, alta CPU).</p>
</li>
<li>
<p><strong>Pod Anti-Affinity</strong>: Distribuir réplicas en diferentes nodos/zonas para alta disponibilidad.</p>
</li>
<li>
<p><strong>Pod Affinity</strong>: Colocar cache cerca de aplicaciones para reducir latencia.</p>
</li>
<li>
<p><strong>Taints/Tolerations</strong>: Dedicar nodos a cargas específicas o aislar nodos con problemas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_4">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Usa nodeSelector para reglas simples, node affinity para lógica compleja.</p>
</li>
<li>
<p>Implementa pod anti-affinity para aplicaciones críticas que requieren alta disponibilidad.</p>
</li>
<li>
<p>Usa taints para dedicar nodos a cargas específicas (GPU, alta memoria, etc.).</p>
</li>
<li>
<p>Combina affinity/anti-affinity con topologyKey apropiado (hostname, zona, región).</p>
</li>
<li>
<p>Documenta las reglas de scheduling aplicadas en tus manifiestos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pod_disruption_budgets_pdb">Pod Disruption Budgets (PDB)</h3>
<div class="paragraph">
<p>Los <strong>Pod Disruption Budgets</strong> definen el número mínimo de pods que deben permanecer disponibles durante interrupciones voluntarias como actualizaciones de nodos, drain o escalado del clúster. Protegen la disponibilidad de las aplicaciones durante mantenimientos.</p>
</div>
<div class="sect3">
<h4 id="_qué_son_las_disrupciones_voluntarias">¿Qué son las disrupciones voluntarias?</h4>
<div class="ulist">
<ul>
<li>
<p>Drain de nodos para mantenimiento.</p>
</li>
<li>
<p>Actualizaciones de clúster.</p>
</li>
<li>
<p>Eliminación manual de pods.</p>
</li>
<li>
<p>Escalado de deployments hacia abajo.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Las disrupciones involuntarias (fallos de hardware, crashes) no son controladas por PDB.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_pdb">Ejemplo de PDB</h4>
<div class="listingblock">
<div class="title">PDB que mantiene al menos 2 pods disponibles:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: web-pdb
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: web</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">PDB que permite hasta 1 pod no disponible:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: backend-pdb
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app: backend</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">PDB con porcentaje:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: cache-pdb
spec:
  minAvailable: 50%
  selector:
    matchLabels:
      app: cache</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_verificar_estado_de_pdb">Verificar estado de PDB</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get pdb
kubectl describe pdb web-pdb</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_5">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Define PDB para todas las aplicaciones críticas en producción.</p>
</li>
<li>
<p>Usa <code>minAvailable</code> para aplicaciones que requieren quorum (bases de datos distribuidas).</p>
</li>
<li>
<p>Usa <code>maxUnavailable: 1</code> para actualizaciones progresivas seguras.</p>
</li>
<li>
<p>Asegúrate de que el deployment tenga suficientes réplicas para cumplir el PDB.</p>
</li>
<li>
<p>Revisa PDBs antes de realizar drain de nodos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_priorityclass">PriorityClass</h3>
<div class="paragraph">
<p>Las <strong>PriorityClasses</strong> permiten asignar prioridades a los pods, determinando qué pods son más importantes cuando el clúster tiene recursos limitados. Kubernetes puede desalojar (evict) pods de menor prioridad para hacer espacio a pods de mayor prioridad.</p>
</div>
<div class="sect3">
<h4 id="_creación_de_priorityclass">Creación de PriorityClass</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: high-priority
value: 1000000
globalDefault: false
description: "Esta prioridad se usa para pods críticos del sistema"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: low-priority
value: 100
globalDefault: false
description: "Esta prioridad se usa para jobs de procesamiento batch"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_uso_de_priorityclass_en_pods">Uso de PriorityClass en Pods</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-critico
spec:
  priorityClassName: high-priority
  containers:
    - name: app
      image: app-critica:latest</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_priorityclasses_del_sistema">PriorityClasses del sistema</h4>
<div class="paragraph">
<p>Kubernetes incluye dos priority classes por defecto:
.Priority classes predefinidas:
- <code>system-cluster-critical</code>: Para componentes críticos del clúster (valor: 2000000000).
- <code>system-node-critical</code>: Para componentes críticos del nodo (valor: 2000001000).</p>
</div>
<div class="listingblock">
<div class="title">Ver PriorityClasses:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get priorityclasses
kubectl describe priorityclass high-priority</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_preemption">Preemption</h4>
<div class="paragraph">
<p>Cuando un pod de alta prioridad no puede ser programado por falta de recursos, Kubernetes puede:
1. Identificar nodos donde eliminar pods de menor prioridad liberaría recursos.
2. Desalojar (evict) esos pods de menor prioridad.
3. Programar el pod de alta prioridad en el nodo liberado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_6">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Define múltiples niveles de prioridad según la criticidad de las aplicaciones.</p>
</li>
<li>
<p>No abuses de prioridades altas para evitar desalojos excesivos.</p>
</li>
<li>
<p>Usa prioridades bajas para jobs batch o procesamiento no urgente.</p>
</li>
<li>
<p>Documenta la estrategia de prioridades en tu organización.</p>
</li>
<li>
<p>Combina con PDB para proteger pods críticos durante eviction.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_security_context">Security Context</h3>
<div class="paragraph">
<p>El <strong>Security Context</strong> define privilegios y configuraciones de seguridad para pods y contenedores, controlando permisos de acceso, capabilities de Linux, usuarios, grupos y más.</p>
</div>
<div class="sect3">
<h4 id="_security_context_a_nivel_de_pod">Security Context a nivel de Pod</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: security-context-pod
spec:
  securityContext:
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000
    supplementalGroups: [4000]
    sysctls:
      - name: net.ipv4.ip_local_port_range
        value: "1024 65000"
  containers:
    - name: app
      image: nginx
      volumeMounts:
        - name: datos
          mountPath: /data
  volumes:
    - name: datos
      emptyDir: {}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_security_context_a_nivel_de_container">Security Context a nivel de Container</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: security-context-container
spec:
  containers:
    - name: app
      image: nginx
      securityContext:
        runAsUser: 2000
        runAsNonRoot: true
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        capabilities:
          drop:
            - ALL
          add:
            - NET_BIND_SERVICE
      volumeMounts:
        - name: cache
          mountPath: /var/cache/nginx
        - name: run
          mountPath: /var/run
  volumes:
    - name: cache
      emptyDir: {}
    - name: run
      emptyDir: {}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_opciones_principales">Opciones principales</h4>
<div class="paragraph">
<p><strong>A nivel de Pod:</strong>
- <code>runAsUser</code>: UID del usuario que ejecuta los contenedores.
- <code>runAsGroup</code>: GID primario del usuario.
- <code>fsGroup</code>: GID para volúmenes montados.
- <code>supplementalGroups</code>: GIDs adicionales.</p>
</div>
<div class="paragraph">
<p><strong>A nivel de Container:</strong>
- <code>runAsNonRoot</code>: Rechaza si la imagen ejecuta como root.
- <code>allowPrivilegeEscalation</code>: Controla si un proceso puede ganar más privilegios.
- <code>readOnlyRootFilesystem</code>: Sistema de archivos raíz de solo lectura.
- <code>capabilities</code>: Añadir/eliminar capabilities de Linux.
- <code>privileged</code>: Ejecutar en modo privilegiado (desaconsejado).
- <code>seLinuxOptions</code>: Opciones de SELinux.
- <code>seccompProfile</code>: Perfil seccomp para filtrar syscalls.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_pod_seguro">Ejemplo de pod seguro</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-seguro
spec:
  securityContext:
    runAsUser: 1000
    runAsGroup: 3000
    fsGroup: 2000
    seccompProfile:
      type: RuntimeDefault
  containers:
    - name: app
      image: mi-app:latest
      securityContext:
        runAsNonRoot: true
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: true
        capabilities:
          drop:
            - ALL
      volumeMounts:
        - name: tmp
          mountPath: /tmp
  volumes:
    - name: tmp
      emptyDir: {}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_7">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Nunca ejecutes contenedores como root en producción.</p>
</li>
<li>
<p>Usa <code>runAsNonRoot: true</code> para validar.</p>
</li>
<li>
<p>Elimina todas las capabilities con <code>drop: [ALL]</code> y añade solo las necesarias.</p>
</li>
<li>
<p>Implementa <code>readOnlyRootFilesystem: true</code> cuando sea posible.</p>
</li>
<li>
<p>Usa <code>allowPrivilegeEscalation: false</code> para prevenir escalación de privilegios.</p>
</li>
<li>
<p>Define seccomp profiles para limitar syscalls disponibles.</p>
</li>
<li>
<p>Evita <code>privileged: true</code> excepto en casos muy específicos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tipos_de_volúmenes">Tipos de Volúmenes</h3>
<div class="paragraph">
<p>Kubernetes soporta diversos tipos de volúmenes para diferentes casos de uso. A continuación se explican los más comunes además de los PersistentVolumes.</p>
</div>
<div class="sect3">
<h4 id="_emptydir">emptyDir</h4>
<div class="paragraph">
<p>Volumen temporal que se crea cuando un pod es asignado a un nodo y existe mientras el pod exista. Útil para compartir datos entre contenedores del mismo pod o como cache temporal.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: emptydir-example
spec:
  containers:
    - name: app
      image: nginx
      volumeMounts:
        - name: cache
          mountPath: /cache
    - name: sidecar
      image: busybox
      command: ['sh', '-c', 'while true; do echo $(date) &gt;&gt; /cache/log.txt; sleep 5; done']
      volumeMounts:
        - name: cache
          mountPath: /cache
  volumes:
    - name: cache
      emptyDir: {}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">emptyDir en memoria (tmpfs):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">volumes:
  - name: cache-mem
    emptyDir:
      medium: Memory
      sizeLimit: 128Mi</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_hostpath">hostPath</h4>
<div class="paragraph">
<p>Monta un archivo o directorio del sistema de archivos del nodo en el pod. Útil para acceder a recursos del host, pero vincula el pod a un nodo específico.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: hostpath-example
spec:
  containers:
    - name: app
      image: nginx
      volumeMounts:
        - name: host-logs
          mountPath: /var/log/host
          readOnly: true
  volumes:
    - name: host-logs
      hostPath:
        path: /var/log
        type: Directory</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Tipos de hostPath:</div>
<ul>
<li>
<p><code>DirectoryOrCreate</code>: Directorio, crea si no existe.</p>
</li>
<li>
<p><code>Directory</code>: Directorio debe existir.</p>
</li>
<li>
<p><code>FileOrCreate</code>: Archivo, crea si no existe.</p>
</li>
<li>
<p><code>File</code>: Archivo debe existir.</p>
</li>
<li>
<p><code>Socket</code>: Socket UNIX debe existir.</p>
</li>
<li>
<p><code>CharDevice</code>: Dispositivo de caracteres debe existir.</p>
</li>
<li>
<p><code>BlockDevice</code>: Dispositivo de bloques debe existir.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>⚠️ <strong>Advertencia</strong>: hostPath puede ser un riesgo de seguridad. Úsalo solo cuando sea absolutamente necesario.</p>
</div>
</div>
<div class="sect3">
<h4 id="_configmap_y_secret_como_volúmenes">configMap y secret como volúmenes</h4>
<div class="paragraph">
<p>Ya cubiertos en el módulo de configuración, pero vale mencionar que se montan como volúmenes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: config-volume-example
spec:
  containers:
    - name: app
      image: nginx
      volumeMounts:
        - name: config
          mountPath: /etc/config
        - name: secrets
          mountPath: /etc/secrets
          readOnly: true
  volumes:
    - name: config
      configMap:
        name: mi-config
    - name: secrets
      secret:
        secretName: mi-secret</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_downwardapi">downwardAPI</h4>
<div class="paragraph">
<p>Expone información del pod como archivos en un volumen, permitiendo que la aplicación acceda a metadatos del pod.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: downward-api-example
  labels:
    app: web
    entorno: produccion
spec:
  containers:
    - name: app
      image: busybox
      command: ['sh', '-c', 'while true; do cat /etc/podinfo/*; sleep 10; done']
      volumeMounts:
        - name: podinfo
          mountPath: /etc/podinfo
  volumes:
    - name: podinfo
      downwardAPI:
        items:
          - path: "labels"
            fieldRef:
              fieldPath: metadata.labels
          - path: "annotations"
            fieldRef:
              fieldPath: metadata.annotations
          - path: "pod-name"
            fieldRef:
              fieldPath: metadata.name
          - path: "namespace"
            fieldRef:
              fieldPath: metadata.namespace
          - path: "cpu-limit"
            resourceFieldRef:
              containerName: app
              resource: limits.cpu
          - path: "memory-limit"
            resourceFieldRef:
              containerName: app
              resource: limits.memory</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_projected">projected</h4>
<div class="paragraph">
<p>Combina múltiples fuentes de volúmenes (secrets, configMaps, downwardAPI, serviceAccountToken) en un solo directorio.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: projected-volume-example
spec:
  containers:
    - name: app
      image: nginx
      volumeMounts:
        - name: all-in-one
          mountPath: /projected
          readOnly: true
  volumes:
    - name: all-in-one
      projected:
        sources:
          - secret:
              name: mi-secret
              items:
                - key: password
                  path: secrets/password.txt
          - configMap:
              name: mi-config
              items:
                - key: config.json
                  path: config/app.json
          - downwardAPI:
              items:
                - path: "metadata/labels"
                  fieldRef:
                    fieldPath: metadata.labels</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_para_volúmenes">Buenas prácticas para volúmenes</h4>
<div class="ulist">
<ul>
<li>
<p>Usa <code>emptyDir</code> para datos temporales o cache que no necesitan persistir.</p>
</li>
<li>
<p>Usa <code>PersistentVolumes</code> para datos que deben sobrevivir al ciclo de vida del pod.</p>
</li>
<li>
<p>Evita <code>hostPath</code> excepto para casos específicos de acceso al host.</p>
</li>
<li>
<p>Usa <code>configMap</code> y <code>secret</code> para inyectar configuración y credenciales.</p>
</li>
<li>
<p>Usa <code>downwardAPI</code> cuando la aplicación necesite conocer metadatos del pod.</p>
</li>
<li>
<p>Usa <code>projected</code> para simplificar el montaje de múltiples fuentes.</p>
</li>
<li>
<p>Define <code>readOnly: true</code> en montajes que no requieren escritura.</p>
</li>
<li>
<p>Especifica <code>subPath</code> si solo necesitas montar un archivo específico de un volumen.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_5_configuración_de_aplicaciones">Módulo 5: Configuración de Aplicaciones</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La configuración de aplicaciones en Kubernetes es fundamental para gestionar la información sensible y las variables de entorno necesarias para el correcto funcionamiento de los pods. Kubernetes ofrece varias formas de manejar configuraciones, como ConfigMaps y Secrets, así como la posibilidad de inyectar variables de entorno y montar volúmenes.</p>
</div>
<div class="sect2">
<h3 id="_configmaps_y_secrets">ConfigMaps y Secrets</h3>
<div class="sect3">
<h4 id="_configmaps">ConfigMaps</h4>
<div class="paragraph">
<p><strong>ConfigMaps</strong> permiten almacenar datos de configuración no sensibles en pares clave-valor, facilitando la separación de la configuración del código de la aplicación. Los ConfigMaps pueden ser montados como archivos en un volumen o inyectados como variables de entorno en los contenedores.</p>
</div>
<div class="paragraph">
<p>Para crear un ConfigMap, puedes usar un archivo YAML o el comando <code>kubectl create configmap</code>. Los ConfigMaps pueden contener múltiples entradas y se pueden actualizar sin necesidad de volver a desplegar los pods.</p>
</div>
<div class="ulist">
<div class="title">Los ConfigMaps son ideales para almacenar:</div>
<ul>
<li>
<p>Parámetros de configuración (URLs, puertos, flags).</p>
</li>
<li>
<p>Archivos de configuración (JSON, YAML, INI).</p>
</li>
<li>
<p>Datos que pueden cambiar entre entornos (desarrollo, pruebas, producción).</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de ConfigMap:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: mi-configmap
data:
  APP_ENV: produccion
  APP_DEBUG: "false"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Un pod que usa el ConfigMap:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: ejemplo-pod
spec:
  containers:
    - name: app
      image: mi-app:latest
      env:
        - name: APP_ENV
          valueFrom:
            configMapKeyRef:
              name: mi-configmap
              key: APP_ENV
        - name: APP_DEBUG
          valueFrom:
            configMapKeyRef:
              name: mi-configmap
              key: APP_DEBUG</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_secrets">Secrets</h4>
<div class="paragraph">
<p><strong>Secrets</strong> almacenan información sensible como contraseñas, tokens o claves, codificada en base64. Al igual que los ConfigMaps, pueden ser montados como archivos o variables de entorno, pero con mayor control de acceso y restricciones de visibilidad.</p>
</div>
<div class="ulist">
<div class="title">Los tipos de Secrets incluyen:</div>
<ul>
<li>
<p><strong>Opaque</strong>: Tipo genérico para datos arbitrarios.</p>
</li>
<li>
<p><strong>kubernetes.io/dockerconfigjson</strong>: Para credenciales de registro de contenedores.</p>
</li>
<li>
<p><strong>kubernetes.io/tls</strong>: Para certificados TLS.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de Secret:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Secret
metadata:
  name: mi-secret
type: Opaque
data:
  PASSWORD: cGFzc3dvcmQ=  # "password" en base64</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Un pod que usa el Secret:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: ejemplo-pod
spec:
  containers:
    - name: app
      image: mi-app:latest
      env:
        - name: PASSWORD
          valueFrom:
            secretKeyRef:
              name: mi-secret
              key: PASSWORD</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Usos comunes:</div>
<ul>
<li>
<p>Inyectar variables de entorno en los contenedores.</p>
</li>
<li>
<p>Montar archivos de configuración en rutas específicas del pod.</p>
</li>
<li>
<p>Separar información sensible (Secrets) de la configuración general (ConfigMaps).</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Buenas prácticas:</div>
<ul>
<li>
<p>Usa ConfigMaps para datos no sensibles y Secrets para información confidencial.</p>
</li>
<li>
<p>Limita el acceso a los Secrets mediante RBAC.</p>
</li>
<li>
<p>No almacenes información sensible en ConfigMaps.</p>
</li>
<li>
<p>Versiona y documenta los cambios en la configuración.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_variables_de_entorno">Variables de entorno</h3>
<div class="paragraph">
<p>Las variables de entorno permiten pasar información de configuración a los contenedores de forma dinámica y flexible. En Kubernetes, puedes definir variables de entorno directamente en el manifiesto del pod o referenciar valores almacenados en ConfigMaps y Secrets.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de variables de entorno en un pod:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: ejemplo-pod
spec:
  containers:
    - name: app
      image: mi-app:latest
      env:
        - name: APP_ENV
          value: "produccion"
        - name: APP_DEBUG
          value: "false"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de variables de entorno desde ConfigMap y Secret:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: ejemplo-pod
spec:
  containers:
    - name: app
      image: mi-app:latest
      env:
        - name: APP_ENV
          valueFrom:
            configMapKeyRef:
              name: mi-configmap
              key: APP_ENV
        - name: PASSWORD
          valueFrom:
            secretKeyRef:
              name: mi-secret
              key: PASSWORD</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Buenas prácticas:</div>
<ul>
<li>
<p>Usa variables de entorno para valores que cambian entre entornos o despliegues.</p>
</li>
<li>
<p>Prefiere referenciar ConfigMaps y Secrets para separar la configuración del código.</p>
</li>
<li>
<p>No almacenes información sensible directamente en variables de entorno; utiliza Secrets.</p>
</li>
<li>
<p>Documenta las variables de entorno requeridas por cada aplicación.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_de_configuraciones">Gestión de configuraciones</h3>
<div class="paragraph">
<p>La gestión de configuraciones en Kubernetes se basa en el uso de ConfigMaps, Secrets y variables de entorno para desacoplar la configuración del código de la aplicación. Esto permite modificar el comportamiento de las aplicaciones sin necesidad de reconstruir imágenes ni redeplegar contenedores.</p>
</div>
<div class="ulist">
<div class="title">Puntos clave:</div>
<ul>
<li>
<p>Utiliza ConfigMaps para almacenar parámetros de configuración no sensibles.</p>
</li>
<li>
<p>Usa Secrets para información confidencial como contraseñas, tokens o claves.</p>
</li>
<li>
<p>Inyecta la configuración en los pods mediante variables de entorno o montando volúmenes.</p>
</li>
<li>
<p>Actualiza ConfigMaps y Secrets con <code>kubectl apply</code> o <code>kubectl edit</code> para reflejar cambios en la configuración.</p>
</li>
<li>
<p>Supervisa y versiona los cambios en la configuración para facilitar el rollback y la trazabilidad.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de actualización de un ConfigMap:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl edit configmap mi-configmap</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de recarga de configuración en un Deployment:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl rollout restart deployment &lt;nombre-del-deployment&gt;</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Buenas prácticas:</div>
<ul>
<li>
<p>Mantén la configuración fuera de la imagen del contenedor.</p>
</li>
<li>
<p>Versiona los archivos de configuración junto con el código fuente.</p>
</li>
<li>
<p>Limita el acceso a los Secrets mediante políticas de RBAC.</p>
</li>
<li>
<p>Documenta las variables y parámetros de configuración requeridos por cada aplicación.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_montaje_de_volúmenes_de_configuración">Montaje de volúmenes de configuración</h3>
<div class="paragraph">
<p>Tanto <strong>ConfigMaps</strong> como <strong>Secrets</strong> pueden montarse como volúmenes dentro de los pods, permitiendo que los datos de configuración se expongan como archivos en el sistema de archivos del contenedor. Esto es útil para aplicaciones que requieren archivos de configuración en rutas específicas o para cargar certificados, claves y otros datos sensibles.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de montaje de ConfigMap como volumen:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: ejemplo-pod
spec:
  containers:
    - name: app
      image: mi-app:latest
      volumeMounts:
        - name: config-vol
          mountPath: /etc/config
  volumes:
    - name: config-vol
      configMap:
        name: mi-configmap</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de montaje de Secret como volumen:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: ejemplo-pod
spec:
  containers:
    - name: app
      image: mi-app:latest
      volumeMounts:
        - name: secret-vol
          mountPath: /etc/secret
          readOnly: true
  volumes:
    - name: secret-vol
      secret:
        secretName: mi-secret</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Puntos clave:</div>
<ul>
<li>
<p>Los archivos generados por ConfigMaps y Secrets montados como volúmenes se actualizan automáticamente si el recurso cambia (según la implementación de la aplicación).</p>
</li>
<li>
<p>Es recomendable montar los Secrets como solo lectura (<code>readOnly: true</code>) para mayor seguridad.</p>
</li>
<li>
<p>Puedes especificar subclaves o rutas personalizadas usando la propiedad <code>items</code> en la definición del volumen.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El montaje de volúmenes de configuración facilita la gestión centralizada y segura de parámetros y datos sensibles en aplicaciones desplegadas en Kubernetes.</p>
</div>
</div>
<div class="sect2">
<h3 id="_buenas_prácticas_para_configuraciones">Buenas prácticas para configuraciones</h3>
<div class="ulist">
<div class="title">Algunas recomendaciones incluyen:</div>
<ul>
<li>
<p>Separa la configuración del código fuente utilizando ConfigMaps y Secrets.</p>
</li>
<li>
<p>Usa Secrets exclusivamente para información sensible y limita su acceso mediante RBAC.</p>
</li>
<li>
<p>Versiona y documenta los cambios en los archivos de configuración.</p>
</li>
<li>
<p>Evita almacenar datos sensibles en ConfigMaps.</p>
</li>
<li>
<p>Valida y prueba la configuración en entornos de desarrollo antes de aplicarla en producción.</p>
</li>
<li>
<p>Utiliza variables de entorno para valores que cambian entre entornos o despliegues.</p>
</li>
<li>
<p>Elimina configuraciones obsoletas para evitar confusiones y riesgos de seguridad.</p>
</li>
<li>
<p>Limita el acceso a los archivos de configuración montados como volúmenes, especialmente los Secrets, usando <code>readOnly: true</code>.</p>
</li>
<li>
<p>Supervisa y revisa periódicamente los recursos de configuración para detectar posibles errores o fugas de información.</p>
</li>
<li>
<p>Mantén la configuración centralizada y gestionada como parte de la infraestructura como código.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_6_almacenamiento_en_kubernetes">Módulo 6: Almacenamiento en Kubernetes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_conceptos_de_almacenamiento_persistente">Conceptos de almacenamiento persistente</h3>
<div class="paragraph">
<p>El almacenamiento persistente en Kubernetes permite que los datos generados y utilizados por los pods sobrevivan a reinicios, reprogramaciones o eliminaciones de los mismos. A diferencia del almacenamiento efímero (almacenamiento local del pod), el almacenamiento persistente asegura la durabilidad y disponibilidad de los datos más allá del ciclo de vida de los contenedores.</p>
</div>
<div class="ulist">
<div class="title">Principales conceptos:</div>
<ul>
<li>
<p><strong>Persistencia</strong>: Los datos almacenados no se pierden aunque el pod sea destruido o recreado.</p>
</li>
<li>
<p><strong>Desacoplamiento</strong>: El almacenamiento está desacoplado del ciclo de vida de los pods, permitiendo que diferentes pods accedan a los mismos datos.</p>
</li>
<li>
<p><strong>Portabilidad</strong>: Kubernetes abstrae el almacenamiento subyacente, permitiendo usar soluciones locales, en red o en la nube (NFS, iSCSI, EBS, GCE Persistent Disk, etc.).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El almacenamiento persistente es fundamental para aplicaciones que requieren guardar información de manera fiable, como bases de datos, sistemas de archivos compartidos o aplicaciones stateful.</p>
</div>
<div class="paragraph">
<p>En Kubernetes, la gestión del almacenamiento persistente se realiza principalmente a través de los recursos <strong>PersistentVolume</strong> (PV) y <strong>PersistentVolumeClaim</strong> (PVC), que permiten solicitar, aprovisionar y consumir almacenamiento de forma dinámica y flexible.</p>
</div>
</div>
<div class="sect2">
<h3 id="_persistentvolumes_y_persistentvolumeclaims">PersistentVolumes y PersistentVolumeClaims</h3>
<div class="paragraph">
<p>Un <strong>PersistentVolume</strong> (PV) es un recurso del clúster que representa una porción de almacenamiento físico (local, en red o en la nube) gestionada por el administrador o aprovisionada dinámicamente. Un <strong>PersistentVolumeClaim</strong> (PVC) es una solicitud de almacenamiento realizada por un usuario o aplicación, especificando el tamaño y las características requeridas.</p>
</div>
<div class="olist arabic">
<div class="title">El ciclo de uso es el siguiente:</div>
<ol class="arabic">
<li>
<p>El administrador define uno o varios PVs, o se configuran StorageClasses para aprovisionamiento dinámico.</p>
</li>
<li>
<p>El usuario crea un PVC solicitando almacenamiento.</p>
</li>
<li>
<p>Kubernetes enlaza automáticamente el PVC con un PV disponible que cumpla los requisitos.</p>
</li>
<li>
<p>El pod consume el almacenamiento reclamado a través del PVC.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="title">Ejemplo de PersistentVolume:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: my-pv
spec:
  capacity:
    storage: 1Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  storageClassName: manual
  hostPath:
    path: "/mnt/data"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de PersistentVolumeClaim:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: manual</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de uso de un PVC en un pod:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-with-pv
spec:
  containers:
    - name: app
      image: nginx
      volumeMounts:
        - mountPath: "/usr/share/nginx/html"
          name: my-volume
  volumes:
    - name: my-volume
      persistentVolumeClaim:
        claimName: my-pvc</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Puntos clave:</div>
<ul>
<li>
<p>Los PV y PVC desacoplan la gestión del almacenamiento del ciclo de vida de los pods.</p>
</li>
<li>
<p>El acceso puede ser <strong>ReadWriteOnce</strong> (un nodo), <strong>ReadOnlyMany</strong> o <strong>ReadWriteMany</strong> (varios nodos, según el backend).</p>
</li>
<li>
<p>El almacenamiento puede ser aprovisionado estática o dinámicamente usando StorageClasses.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_storageclasses">StorageClasses</h3>
<div class="paragraph">
<p>Una <strong>StorageClass</strong> en Kubernetes define las características y el tipo de almacenamiento dinámico que puede ser aprovisionado para los PersistentVolumeClaims (PVC). Permite abstraer detalles como el tipo de disco, el rendimiento, la replicación o el proveedor de almacenamiento (local, NFS, EBS, GCE, etc.).</p>
</div>
<div class="paragraph">
<p>Cuando un usuario crea un PVC y especifica una StorageClass, Kubernetes aprovisiona automáticamente un PersistentVolume (PV) con las características definidas en esa clase.</p>
</div>
<div class="ulist">
<div class="title">Características principales:</div>
<ul>
<li>
<p>Permite aprovisionamiento dinámico de volúmenes.</p>
</li>
<li>
<p>Define parámetros como tipo de almacenamiento, políticas de retención y proveedor.</p>
</li>
<li>
<p>Facilita la gestión de diferentes tipos de almacenamiento en un mismo clúster.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de StorageClass para volúmenes estándar:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: mi-storageclass
provisioner: kubernetes.io/aws-ebs
parameters:
  type: gp2
reclaimPolicy: Delete
mountOptions:
  - debug</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de PVC usando una StorageClass:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-con-storageclass
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: mi-storageclass</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Puntos clave:</div>
<ul>
<li>
<p>El parámetro <code>provisioner</code> indica el plugin de almacenamiento a utilizar.</p>
</li>
<li>
<p><code>parameters</code> define opciones específicas del backend (tipo de disco, IOPS, etc.).</p>
</li>
<li>
<p><code>reclaimPolicy</code> controla qué ocurre con el volumen cuando el PVC es eliminado (<code>Delete</code> o <code>Retain</code>).</p>
</li>
<li>
<p>Si no se especifica una StorageClass, se usará la clase por defecto del clúster si existe.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>El uso de StorageClasses permite a los administradores ofrecer diferentes calidades y tipos de almacenamiento a los usuarios de forma sencilla y flexible.</p>
</div>
</div>
<div class="sect2">
<h3 id="_administración_de_volúmenes">Administración de volúmenes</h3>
<div class="paragraph">
<p>La administración de volúmenes en Kubernetes implica la creación, asignación, monitoreo y eliminación de recursos de almacenamiento persistente para los pods. Los volúmenes pueden ser efímeros (vinculados al ciclo de vida del pod) o persistentes (gestionados mediante PV y PVC).</p>
</div>
<div class="ulist">
<div class="title">Pasos comunes en la administración de volúmenes:</div>
<ul>
<li>
<p>Crear PersistentVolumes (PV) y PersistentVolumeClaims (PVC) según las necesidades de la aplicación.</p>
</li>
<li>
<p>Asignar PVCs a los pods mediante la sección <code>volumes</code> en los manifiestos.</p>
</li>
<li>
<p>Monitorear el estado de los volúmenes y su uso con:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get pv
kubectl get pvc
kubectl describe pv &lt;nombre-del-pv&gt;
kubectl describe pvc &lt;nombre-del-pvc&gt;</code></pre>
</div>
</div>
</li>
<li>
<p>Eliminar PVCs y PVs cuando ya no sean necesarios, teniendo en cuenta la política de retención (<code>reclaimPolicy</code>) para liberar o conservar los datos.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Buenas prácticas:</div>
<ul>
<li>
<p>Utiliza StorageClasses para aprovisionamiento dinámico y flexibilidad.</p>
</li>
<li>
<p>Define políticas de retención adecuadas (<code>Delete</code> o <code>Retain</code>) según la criticidad de los datos.</p>
</li>
<li>
<p>Supervisa el uso de almacenamiento y ajusta cuotas o tamaños según el crecimiento de la aplicación.</p>
</li>
<li>
<p>Documenta el uso de volúmenes y su relación con los pods y aplicaciones.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La administración eficiente de volúmenes es clave para garantizar la disponibilidad, durabilidad y rendimiento de las aplicaciones stateful en Kubernetes.</p>
</div>
</div>
<div class="sect2">
<h3 id="_soluciones_de_almacenamiento_para_kubernetes">Soluciones de almacenamiento para Kubernetes</h3>
<div class="paragraph">
<p>Kubernetes soporta una amplia variedad de soluciones de almacenamiento, tanto locales como en red y en la nube, para satisfacer las necesidades de aplicaciones stateful y persistentes.</p>
</div>
<div class="ulist">
<div class="title">Algunas de las soluciones más comunes incluyen:</div>
<ul>
<li>
<p><strong>NFS (Network File System)</strong>: Proporciona almacenamiento compartido en red, ideal para entornos de desarrollo y pruebas.</p>
</li>
<li>
<p><strong>iSCSI</strong>: Permite conectar volúmenes de almacenamiento en red como si fueran discos locales.</p>
</li>
<li>
<p><strong>Ceph</strong>: Plataforma de almacenamiento distribuido que ofrece bloques, archivos y objetos, muy utilizada en entornos empresariales.</p>
</li>
<li>
<p><strong>GlusterFS</strong>: Sistema de archivos distribuido y escalable, adecuado para grandes volúmenes de datos.</p>
</li>
<li>
<p><strong>Longhorn</strong>: Solución nativa de almacenamiento distribuido para Kubernetes, fácil de instalar y administrar.</p>
</li>
<li>
<p><strong>OpenEBS</strong>: Proporciona almacenamiento local y distribuido basado en contenedores, pensado para Kubernetes.</p>
</li>
<li>
<p><strong>Portworx</strong>: Plataforma avanzada de almacenamiento empresarial para Kubernetes, con soporte para replicación, snapshots y cifrado.</p>
</li>
<li>
<p><strong>Soluciones cloud</strong>:</p>
<div class="ulist">
<ul>
<li>
<p><strong>AWS EBS (Elastic Block Store)</strong></p>
</li>
<li>
<p><strong>Google Persistent Disk</strong></p>
</li>
<li>
<p><strong>Azure Disk/Files</strong></p>
</li>
<li>
<p><strong>Amazon EFS (Elastic File System)</strong></p>
</li>
<li>
<p><strong>Azure NetApp Files</strong></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Puntos clave al elegir una solución:</div>
<ul>
<li>
<p>Compatibilidad con el entorno (on-premise, cloud, híbrido).</p>
</li>
<li>
<p>Soporte para aprovisionamiento dinámico mediante StorageClasses.</p>
</li>
<li>
<p>Características como replicación, snapshots, cifrado y rendimiento.</p>
</li>
<li>
<p>Facilidad de integración y administración dentro del clúster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La elección de la solución de almacenamiento adecuada depende de los requisitos de la aplicación, el entorno de despliegue y las necesidades de rendimiento y disponibilidad.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_7_redes_en_kubernetes">Módulo 7: Redes en Kubernetes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_modelo_de_red_de_kubernetes">Modelo de red de Kubernetes</h3>
<div class="paragraph">
<p>El modelo de red de Kubernetes es fundamental para el funcionamiento de los clústeres, ya que permite la comunicación entre los diferentes componentes y aplicaciones desplegadas. A continuación se explica en detalle cómo funciona este modelo:</p>
</div>
<div class="sect3">
<h4 id="_principios_básicos">Principios básicos</h4>
<div class="paragraph">
<p>Kubernetes define un modelo de red plano, donde:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Todos los pods pueden comunicarse entre sí sin NAT</strong>: No importa en qué nodo estén, todos los pods tienen una dirección IP única y pueden comunicarse directamente.</p>
</li>
<li>
<p><strong>Los nodos pueden comunicarse con cualquier pod</strong>: Los nodos del clúster pueden acceder a cualquier pod usando su IP.</p>
</li>
<li>
<p><strong>La comunicación es bidireccional</strong>: No hay restricciones de firewall internas por defecto, aunque se pueden aplicar políticas de red.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_componentes_principales">Componentes principales</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Pod Network</strong>: Cada pod recibe una IP única dentro de un rango definido para el clúster. Esta red es gestionada por un complemento de red (CNI, Container Network Interface).</p>
</li>
<li>
<p><strong>Service Network</strong>: Los servicios de Kubernetes exponen aplicaciones a través de una IP virtual y un nombre DNS, permitiendo el balanceo de carga interno.</p>
</li>
<li>
<p><strong>Node Network</strong>: Los nodos del clúster también tienen sus propias IPs y pueden comunicarse entre sí y con los pods.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_plugins_de_red_cni">Plugins de red (CNI)</h4>
<div class="ulist">
<div class="title">Kubernetes no implementa la red por sí mismo, sino que utiliza plugins CNI como:</div>
<ul>
<li>
<p><strong>Calico</strong></p>
</li>
<li>
<p><strong>Flannel</strong></p>
</li>
<li>
<p><strong>Weave</strong></p>
</li>
<li>
<p><strong>Cilium</strong></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_comunicación">Ejemplo de comunicación</h4>
<div class="paragraph">
<p>Para ilustrar cómo funciona la comunicación en el modelo de red de Kubernetes, consideremos el siguiente escenario:</p>
</div>
<div class="sect4">
<h5 id="_escenario">Escenario</h5>
<div class="paragraph">
<p>Supongamos que tenemos dos pods desplegados en diferentes nodos del clúster:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Pod A</code> en el <code>Nodo 1</code></p>
</li>
<li>
<p><code>Pod B</code> en el <code>Nodo 2</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ambos pods forman parte de la misma red definida por el complemento CNI (por ejemplo, Calico o Flannel).</p>
</div>
</div>
<div class="sect4">
<h5 id="_archivos_de_configuración_yaml">Archivos de configuración YAML</h5>
<div class="paragraph">
<p>A continuación se muestran los archivos <code>.yml</code> necesarios para desplegar ambos pods y un servicio para exponer <code>Pod B</code>:</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de configuración para <code>Pod A</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># pod-a.yml
apiVersion: v1
kind: Pod
metadata:
  name: pod-a
  labels:
    app: demo
spec:
  containers:
    - name: app
      image: busybox
      command: ["sleep", "3600"]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de configuración para <code>Pod B</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># pod-b.yml
apiVersion: v1
kind: Pod
metadata:
  name: pod-b
  labels:
    app: demo
spec:
  containers:
    - name: app
      image: busybox
      command: ["sleep", "3600"]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de configuración para el servicio <code>service-b</code>: que expone <code>Pod B</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># service-b.yml
apiVersion: v1
kind: Service
metadata:
  name: service-b
spec:
  selector:
    app: demo
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_flujo_de_comunicación">Flujo de comunicación</h5>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Asignación de IPs</strong>: Al crearse, cada pod recibe una dirección IP única dentro del rango de red del clúster.</p>
</li>
<li>
<p><strong>Solicitud de comunicación</strong>: <code>Pod A</code> puede enviar datos a <code>Pod B</code> usando la IP de este último o a través del servicio <code>service-b</code>.</p>
</li>
<li>
<p><strong>Enrutamiento transparente</strong>: El complemento de red configura las rutas necesarias en ambos nodos para que el tráfico pueda fluir directamente entre los pods, sin necesidad de NAT.</p>
</li>
<li>
<p><strong>Recepción de datos</strong>: <code>Pod B</code> recibe la solicitud directamente desde <code>Pod A</code>, como si estuvieran en la misma red local, aunque estén en nodos distintos.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="_diagrama_de_ejemplo">Diagrama de ejemplo</h5>
<div class="imageblock">
<div class="content">
<img src="pod-communication.png" alt="pod communication" width="275" height="289">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_puntos_clave">Puntos clave</h5>
<div class="ulist">
<ul>
<li>
<p>No importa en qué nodo esté cada pod; la red de Kubernetes garantiza la conectividad directa.</p>
</li>
<li>
<p>El tráfico entre pods no pasa por NAT ni por proxies intermedios, a menos que se apliquen políticas de red o servicios específicos.</p>
</li>
<li>
<p>Este modelo facilita la escalabilidad y la simplicidad en la comunicación entre microservicios.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_gráfico_3">Resumen gráfico</h4>
<div class="imageblock">
<div class="content">
<img src="network-model.png" alt="network model" width="262" height="289">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_proxies_y_balanceadores_de_carga">Proxies y balanceadores de carga</h3>
<div class="paragraph">
<p>En Kubernetes, los proxies y balanceadores de carga son componentes esenciales para gestionar el tráfico de red hacia y entre las aplicaciones desplegadas en el clúster. A continuación se explica en detalle su funcionamiento y sus diferentes tipos:</p>
</div>
<div class="sect3">
<h4 id="_qué_es_un_proxy">¿Qué es un proxy?</h4>
<div class="paragraph">
<p>Un proxy es un intermediario que recibe solicitudes de red y las reenvía a uno o varios servidores de destino. En Kubernetes, los proxies ayudan a dirigir el tráfico hacia los pods correctos, facilitando la escalabilidad y la tolerancia a fallos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_qué_es_un_balanceador_de_carga">¿Qué es un balanceador de carga?</h4>
<div class="paragraph">
<p>Un balanceador de carga distribuye el tráfico de red entre varios servidores o pods, asegurando que ninguno se sobrecargue y que las solicitudes se atiendan de manera eficiente. Esto mejora la disponibilidad y el rendimiento de las aplicaciones.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tipos_de_proxies_y_balanceadores_en_kubernetes">Tipos de proxies y balanceadores en Kubernetes</h4>
<div class="ulist">
<ul>
<li>
<p><strong>kube-proxy</strong>: Es el componente nativo de Kubernetes que implementa la lógica de red para los servicios. kube-proxy puede funcionar en modo iptables, IPVS o userspace, y se encarga de reenviar el tráfico a los pods correctos según las reglas de los servicios.</p>
</li>
<li>
<p><strong>Service de tipo ClusterIP</strong>: Crea una IP virtual interna para acceder a un conjunto de pods. kube-proxy distribuye el tráfico entre los pods asociados.</p>
</li>
<li>
<p><strong>Service de tipo NodePort</strong>: Expone un servicio en un puerto específico de cada nodo del clúster, permitiendo el acceso externo a través de la IP del nodo y el puerto asignado.</p>
</li>
<li>
<p><strong>Service de tipo LoadBalancer</strong>: Integra un balanceador de carga externo (por ejemplo, de un proveedor cloud) que distribuye el tráfico entrante entre los nodos y, a su vez, entre los pods.</p>
</li>
<li>
<p><strong>Ingress</strong>: Es un recurso que gestiona el acceso HTTP/HTTPS externo al clúster. Utiliza controladores (Ingress Controllers) como NGINX o Traefik, que actúan como proxies inversos y balanceadores de carga a nivel de aplicación.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_flujo_de_tráfico">Ejemplo de flujo de tráfico</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Un usuario externo accede a una aplicación a través de un balanceador de carga (LoadBalancer o Ingress).</p>
</li>
<li>
<p>El balanceador de carga recibe la solicitud y la dirige a uno de los nodos del clúster.</p>
</li>
<li>
<p>kube-proxy en el nodo recibe la solicitud y la reenvía a uno de los pods disponibles según la configuración del servicio.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_ventajas_de_usar_proxies_y_balanceadores">Ventajas de usar proxies y balanceadores</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Alta disponibilidad</strong>: Si un pod falla, el tráfico se redirige automáticamente a otros pods sanos.</p>
</li>
<li>
<p><strong>Escalabilidad</strong>: Permite añadir o quitar pods sin interrumpir el servicio.</p>
</li>
<li>
<p><strong>Flexibilidad</strong>: Se pueden definir reglas avanzadas de enrutamiento y seguridad.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_gráfico_4">Resumen gráfico</h4>
<div id="myId" class="imageblock">
<div class="content">
<img src="diag-plantuml-md5-99f65fe7421a2c67dc9d88c2b78819bc.png" alt="Diagram" width="329" height="401">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_políticas_de_red_en_kubernetes">Políticas de red en Kubernetes</h3>
<div class="paragraph">
<p>Las políticas de red (<code>NetworkPolicy</code>) en Kubernetes son un mecanismo fundamental para controlar el flujo de tráfico entre los pods y otros recursos de red dentro del clúster. Permiten definir reglas declarativas que especifican qué conexiones están permitidas y cuáles no, mejorando así la seguridad y el aislamiento de las aplicaciones.</p>
</div>
<div class="sect3">
<h4 id="_qué_es_una_networkpolicy">¿Qué es una NetworkPolicy?</h4>
<div class="paragraph">
<p>Una NetworkPolicy es un recurso de Kubernetes que define cómo los pods pueden comunicarse entre sí y con otros endpoints (otros pods, namespaces, direcciones IP externas, etc.). Por defecto, si no hay ninguna política aplicada, todo el tráfico entre pods está permitido. Al aplicar una NetworkPolicy, solo el tráfico explícitamente permitido por las reglas será aceptado; el resto será bloqueado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_cómo_funcionan_las_networkpolicies">¿Cómo funcionan las NetworkPolicies?</h4>
<div class="paragraph">
<p>Las NetworkPolicies funcionan seleccionando pods mediante etiquetas (<code>labels</code>) y definiendo reglas de entrada (<code>ingress</code>) y salida (<code>egress</code>). Estas reglas pueden restringir el tráfico según:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El origen o destino (otros pods, namespaces, IPs).</p>
</li>
<li>
<p>El puerto y el protocolo.</p>
</li>
<li>
<p>Las etiquetas de los pods.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para que las NetworkPolicies tengan efecto, el clúster debe usar un plugin de red compatible con este recurso, como Calico, Cilium o Weave.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_didáctico_permitir_solo_tráfico_de_frontend_a_backend">Ejemplo didáctico: Permitir solo tráfico de frontend a backend</h4>
<div class="paragraph">
<p>Supongamos que tienes dos aplicaciones: un frontend y un backend, cada una en su propio pod. Solo quieres permitir que el frontend se comunique con el backend, y bloquear el resto del tráfico.</p>
</div>
<div class="listingblock">
<div class="title">Primero, define los pods con sus etiquetas:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># pod-frontend.yml
apiVersion: v1
kind: Pod
metadata:
  name: frontend
  labels:
    app: frontend
spec:
  containers:
    - name: app
      image: nginx
      ports:
        - containerPort: 80</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># pod-backend.yml
apiVersion: v1
kind: Pod
metadata:
  name: backend
  labels:
    app: backend
spec:
  containers:
    - name: app
      image: nginx
      ports:
        - containerPort: 80</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ahora, crea la NetworkPolicy para permitir solo el tráfico de los pods con la etiqueta <code>app: frontend</code> hacia los pods con la etiqueta <code>app: backend</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># networkpolicy-backend.yml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
    - Ingress
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app: frontend
      ports:
        - protocol: TCP
          port: 80</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Con esta configuración:</div>
<ul>
<li>
<p>Solo los pods con la etiqueta <code>app: frontend</code> podrán acceder al puerto 80 de los pods con la etiqueta <code>app: backend</code>.</p>
</li>
<li>
<p>Todo el tráfico de entrada desde otros pods o fuentes será bloqueado.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_avanzado_permitir_tráfico_de_salida_solo_a_internet">Ejemplo avanzado: Permitir tráfico de salida solo a Internet</h4>
<div class="paragraph">
<p>Supón que quieres que tus pods solo puedan acceder a Internet (por ejemplo, para actualizaciones o APIs externas), pero no a otros pods del clúster.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># networkpolicy-egress-internet.yml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-egress-to-internet
spec:
  podSelector: {} # Aplica a todos los pods del namespace
  policyTypes:
    - Egress
  egress:
    - to:
        - ipBlock:
            cidr: 0.0.0.0/0
      ports:
        - protocol: TCP
          port: 443
        - protocol: TCP
          port: 80</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Esta política:</div>
<ul>
<li>
<p>Permite a todos los pods del namespace realizar conexiones de salida (egress) solo a cualquier dirección IP (Internet) en los puertos 80 y 443.</p>
</li>
<li>
<p>Bloquea el tráfico de salida a otros pods del clúster, a menos que se definan reglas adicionales.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_8">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Principio de menor privilegio</strong>: Solo permite el tráfico estrictamente necesario.</p>
</li>
<li>
<p><strong>Prueba en entornos de desarrollo</strong> antes de aplicar en producción.</p>
</li>
<li>
<p><strong>Documenta</strong> cada política y su propósito.</p>
</li>
<li>
<p><strong>Combina políticas</strong> para cubrir diferentes escenarios de seguridad (por ejemplo, tráfico interno y externo).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ingress_controllers_2">Ingress Controllers</h3>
<div class="paragraph">
<p>Un <strong>Ingress Controller</strong> es un componente esencial en Kubernetes que implementa las reglas definidas en los recursos Ingress y enruta el tráfico HTTP/HTTPS externo hacia los servicios internos del clúster. Sin un Ingress Controller desplegado, los recursos Ingress no tendrán efecto y el tráfico externo no podrá ser gestionado mediante reglas avanzadas de enrutamiento.</p>
</div>
<div class="sect3">
<h4 id="_qué_es_un_ingress_controller">¿Qué es un Ingress Controller?</h4>
<div class="paragraph">
<p>El recurso Ingress en Kubernetes solo define las reglas de enrutamiento, pero necesita un controlador que las interprete y actúe como proxy inverso y balanceador de carga. El Ingress Controller escucha los cambios en los recursos Ingress y configura automáticamente el proxy para enrutar el tráfico según las reglas especificadas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_tipos_de_ingress_controllers">Tipos de Ingress Controllers</h4>
<div class="ulist">
<div class="title">Existen múltiples implementaciones de Ingress Controller, cada una con características y ventajas particulares:</div>
<ul>
<li>
<p><strong>NGINX Ingress Controller</strong>: El más popular y ampliamente soportado, ideal para la mayoría de escenarios.</p>
</li>
<li>
<p><strong>Traefik</strong>: Sencillo de configurar, con soporte para múltiples protocolos y funcionalidades avanzadas.</p>
</li>
<li>
<p><strong>HAProxy Ingress</strong>: Basado en HAProxy, recomendado para entornos de alto rendimiento.</p>
</li>
<li>
<p><strong>Controladores cloud</strong>: AWS ALB Ingress Controller, GKE Ingress Controller, Azure Application Gateway, etc.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La elección depende de los requisitos de la aplicación, el entorno y las características deseadas (TLS, autenticación, reescritura de URLs, etc.).</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_despliegue_de_nginx_ingress_controller">Ejemplo: Despliegue de NGINX Ingress Controller</h4>
<div class="paragraph">
<p>Para instalar el NGINX Ingress Controller en un clúster Kubernetes, puedes aplicar el manifiesto oficial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.10.1/deploy/static/provider/cloud/deploy.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto desplegará los recursos necesarios (Deployment, Service, RBAC, ConfigMap, etc.) en el namespace <code>ingress-nginx</code>.</p>
</div>
<div class="listingblock">
<div class="title">Verifica que el controlador está en funcionamiento:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get pods -n ingress-nginx
kubectl get services -n ingress-nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>El Service de tipo LoadBalancer o NodePort expone el Ingress Controller al exterior.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_recurso_ingress">Ejemplo de recurso Ingress</h4>
<div class="paragraph">
<p>Una vez desplegado el Ingress Controller, puedes definir un recurso Ingress para enrutar tráfico HTTP/HTTPS a tus servicios internos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ejemplo-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
    - host: miapp.ejemplo.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: mi-servicio
                port:
                  number: 80</code></pre>
</div>
</div>
<div class="paragraph">
<p>Opcionalmente, puedes añadir soporte para TLS:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ejemplo-ingress-tls
spec:
  tls:
    - hosts:
        - miapp.ejemplo.com
      secretName: miapp-tls-secret
  rules:
    - host: miapp.ejemplo.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: mi-servicio
                port:
                  number: 80</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para que funcione HTTPS, debes crear un Secret de tipo TLS con tu certificado y clave privada:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl create secret tls miapp-tls-secret --cert=certificado.crt --key=clave.key</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_funcionamiento_general">Funcionamiento general</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El usuario accede a <code>miapp.ejemplo.com</code>.</p>
</li>
<li>
<p>El Ingress Controller recibe la petición en el puerto 80 o 443.</p>
</li>
<li>
<p>El controlador consulta las reglas Ingress y enruta la petición al Service correspondiente.</p>
</li>
<li>
<p>El Service balancea el tráfico entre los pods disponibles.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_9">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Despliega el Ingress Controller en un namespace dedicado.</p>
</li>
<li>
<p>Usa anotaciones para personalizar el comportamiento (reescritura de URLs, autenticación, rate limiting, etc.).</p>
</li>
<li>
<p>Protege los endpoints de administración del Ingress Controller.</p>
</li>
<li>
<p>Usa certificados TLS válidos para producción.</p>
</li>
<li>
<p>Supervisa el estado del Ingress Controller y revisa los logs ante problemas de enrutamiento.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_gráfico_5">Resumen gráfico</h4>
<div class="imageblock">
<div class="content">
<img src="ingress-controller.png" alt="ingress controller" width="251" height="561">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_service_mesh">Service Mesh</h3>
<div class="paragraph">
<p>Un <strong>Service Mesh</strong> es una capa de infraestructura dedicada a gestionar la comunicación entre servicios (microservicios) dentro de un clúster de Kubernetes. Proporciona funcionalidades avanzadas como balanceo de carga, descubrimiento de servicios, seguridad, observabilidad, control de tráfico y recuperación ante fallos, todo ello sin modificar el código de las aplicaciones.</p>
</div>
<div class="sect3">
<h4 id="_por_qué_usar_un_service_mesh">¿Por qué usar un Service Mesh?</h4>
<div class="paragraph">
<p>En arquitecturas de microservicios, la complejidad de la comunicación entre servicios crece rápidamente. Un Service Mesh ayuda a resolver retos como:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Balanceo de carga inteligente</strong> entre instancias de servicios.</p>
</li>
<li>
<p><strong>Encriptación de tráfico interno</strong> (mTLS) para mayor seguridad.</p>
</li>
<li>
<p><strong>Control de tráfico</strong>: redirección, canary releases, circuit breaking, retries, timeouts.</p>
</li>
<li>
<p><strong>Observabilidad</strong>: métricas, trazas distribuidas y logs detallados de las llamadas entre servicios.</p>
</li>
<li>
<p><strong>Gestión de políticas</strong>: control de acceso, autenticación y autorización entre servicios.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_arquitectura_de_un_service_mesh">Arquitectura de un Service Mesh</h4>
<div class="paragraph">
<p>La mayoría de los Service Mesh modernos, como Istio o Linkerd, utilizan el patrón <strong>sidecar proxy</strong>. Esto significa que junto a cada pod de la aplicación se despliega un contenedor adicional (sidecar) que intercepta y gestiona todo el tráfico de red del pod.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="service-mesh-architecture.png" alt="service mesh architecture" width="329" height="379">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Data Plane</strong>: Los sidecars gestionan el tráfico entre servicios.</p>
</li>
<li>
<p><strong>Control Plane</strong>: Un componente centralizado (por ejemplo, Istio Pilot) gestiona la configuración y políticas de los sidecars.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_despliegue_básico_de_istio">Ejemplo: Despliegue básico de Istio</h4>
<div class="paragraph">
<p>A continuación se muestra cómo instalar Istio, uno de los Service Mesh más populares, y cómo inyectar el sidecar en un deployment.</p>
</div>
<div class="listingblock">
<div class="title">Instalar Istio en el clúster:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">curl -L https://istio.io/downloadIstio | sh -
cd istio-*
export PATH=$PWD/bin:$PATH
istioctl install --set profile=demo -y
kubectl label namespace default istio-injection=enabled</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de deployment con sidecar automático:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-demo
spec:
  replicas: 2
  selector:
    matchLabels:
      app: demo
  template:
    metadata:
      labels:
        app: demo
    spec:
      containers:
        - name: app
          image: nginx
          ports:
            - containerPort: 80</code></pre>
</div>
</div>
<div class="paragraph">
<p>Cuando el namespace tiene la etiqueta <code>istio-injection=enabled</code>, Istio inyecta automáticamente el sidecar Envoy en cada pod.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de configuración de política de tráfico (VirtualService):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: demo-route
spec:
  hosts:
    - app-demo
  http:
    - route:
        - destination:
            host: app-demo
            subset: v1</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de política de seguridad (PeerAuthentication):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
  namespace: default
spec:
  mtls:
    mode: STRICT</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_funcionalidades_clave_de_un_service_mesh">Funcionalidades clave de un Service Mesh</h4>
<div class="ulist">
<ul>
<li>
<p><strong>mTLS (Mutual TLS)</strong>: Cifra el tráfico entre servicios y autentica los extremos.</p>
</li>
<li>
<p><strong>Control de tráfico</strong>: Permite implementar blue/green, canary releases, A/B testing, etc.</p>
</li>
<li>
<p><strong>Circuit breaking y retries</strong>: Mejora la resiliencia ante fallos.</p>
</li>
<li>
<p><strong>Rate limiting y quotas</strong>: Controla el uso de recursos y protege servicios críticos.</p>
</li>
<li>
<p><strong>Trazabilidad y métricas</strong>: Exporta métricas a Prometheus y trazas a Jaeger/Zipkin.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_observabilidad_con_istio">Ejemplo de observabilidad con Istio</h4>
<div class="paragraph">
<p>Istio integra herramientas como Prometheus, Grafana y Kiali para monitorizar el tráfico y visualizar la topología de servicios.</p>
</div>
<div class="listingblock">
<div class="title">Desplegar addons de observabilidad:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f samples/addons</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Acceder a Kiali (dashboard de topología y métricas):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl port-forward svc/kiali -n istio-system 20001:20001
# Luego abre http://localhost:20001 en tu navegador</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_otros_service_mesh_populares">Otros Service Mesh populares</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Linkerd</strong>: Enfocado en simplicidad y bajo consumo de recursos.</p>
</li>
<li>
<p><strong>Consul Connect</strong>: De HashiCorp, integra descubrimiento de servicios y mTLS.</p>
</li>
<li>
<p><strong>AWS App Mesh</strong>: Service Mesh gestionado para AWS.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_10">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Evalúa la complejidad y el valor añadido antes de adoptar un Service Mesh.</p>
</li>
<li>
<p>Empieza con un entorno de pruebas y migra gradualmente los servicios.</p>
</li>
<li>
<p>Supervisa el impacto en el rendimiento y ajusta la configuración según las necesidades.</p>
</li>
<li>
<p>Documenta las políticas y flujos de tráfico implementados.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_exposición_de_servicios_al_exterior_2">Exposición de servicios al exterior</h3>
<div class="paragraph">
<p>Exponer servicios al exterior en Kubernetes es fundamental para que las aplicaciones sean accesibles fuera del clúster. Kubernetes ofrece varias estrategias para lograrlo, cada una adecuada para diferentes escenarios y necesidades de seguridad, escalabilidad y facilidad de gestión.</p>
</div>
<div class="sect3">
<h4 id="_opciones_principales_para_exponer_servicios">Opciones principales para exponer servicios</h4>
<div class="ulist">
<ul>
<li>
<p><strong>NodePort</strong>: Expone el servicio en un puerto específico de cada nodo del clúster. Permite el acceso externo a través de la IP del nodo y el puerto asignado. Es sencillo, pero tiene limitaciones de seguridad y escalabilidad.</p>
</li>
<li>
<p><strong>LoadBalancer</strong>: Solicita un balanceador de carga externo (usualmente proporcionado por el proveedor cloud) que asigna una IP pública y distribuye el tráfico entrante entre los nodos y pods. Es la opción más común en entornos cloud.</p>
</li>
<li>
<p><strong>Ingress</strong>: Permite exponer múltiples servicios HTTP/HTTPS bajo un mismo punto de entrada, gestionando rutas, certificados TLS y reglas avanzadas mediante un Ingress Controller. Es ideal para aplicaciones web y microservicios.</p>
</li>
<li>
<p><strong>ExternalName</strong>: Redirige el tráfico a un nombre DNS externo, útil para integrar servicios fuera del clúster.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_service_tipo_nodeport">Ejemplo de Service tipo NodePort</h4>
<div class="paragraph">
<p>Este tipo de servicio expone la aplicación en un puerto alto (por defecto entre 30000 y 32767) de cada nodo del clúster.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Service
metadata:
  name: mi-servicio-nodeport
spec:
  type: NodePort
  selector:
    app: mi-app
  ports:
    - port: 80
      targetPort: 8080
      nodePort: 30080</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Acceso: <code><a href="http://&lt;IP-del-nodo&gt;:30080" class="bare">http://&lt;IP-del-nodo&gt;:30080</a></code></p>
</li>
<li>
<p>Útil para pruebas o entornos pequeños.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_service_tipo_loadbalancer">Ejemplo de Service tipo LoadBalancer</h4>
<div class="paragraph">
<p>En entornos cloud, este tipo de servicio crea automáticamente un balanceador de carga externo y asigna una IP pública.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Service
metadata:
  name: mi-servicio-lb
spec:
  type: LoadBalancer
  selector:
    app: mi-app
  ports:
    - port: 80
      targetPort: 8080</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Acceso: <code><a href="http://&lt;IP-pública-asignada&gt" class="bare">http://&lt;IP-pública-asignada&gt</a>;</code></p>
</li>
<li>
<p>Requiere soporte del proveedor cloud.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_exposición_usando_ingress">Ejemplo de exposición usando Ingress</h4>
<div class="paragraph">
<p>Ingress permite exponer varios servicios HTTP/HTTPS bajo un mismo dominio o IP, gestionando rutas y certificados TLS.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: mi-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
    - host: miapp.ejemplo.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: mi-servicio-lb
                port:
                  number: 80
  tls:
    - hosts:
        - miapp.ejemplo.com
      secretName: miapp-tls-secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para habilitar HTTPS, crea un Secret TLS:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl create secret tls miapp-tls-secret --cert=certificado.crt --key=clave.key</code></pre>
</div>
</div>
<div class="paragraph">
<p>Recuerda que para que Ingress funcione, necesitas desplegar un Ingress Controller (por ejemplo, NGINX Ingress Controller).</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_service_tipo_externalname">Ejemplo de Service tipo ExternalName</h4>
<div class="paragraph">
<p>Este tipo de servicio actúa como un alias DNS para servicios externos al clúster.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Service
metadata:
  name: mi-servicio-external
spec:
  type: ExternalName
  externalName: ejemplo.com</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Acceso: Los pods que consulten <code>mi-servicio-external</code> serán redirigidos a <code>ejemplo.com</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_11">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Prefiere LoadBalancer o Ingress para producción, ya que ofrecen mayor flexibilidad y seguridad.</p>
</li>
<li>
<p>Usa NodePort solo para pruebas o entornos controlados.</p>
</li>
<li>
<p>Protege los servicios expuestos con TLS y autenticación cuando sea necesario.</p>
</li>
<li>
<p>Limita la exposición de servicios solo a los estrictamente necesarios.</p>
</li>
<li>
<p>Documenta los endpoints y puertos expuestos para facilitar la gestión y el mantenimiento.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_8_escalabilidad_y_alta_disponibilidad">Módulo 8: Escalabilidad y Alta Disponibilidad</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La escalabilidad y la alta disponibilidad son pilares fundamentales en Kubernetes para garantizar que las aplicaciones puedan crecer según la demanda y mantenerse operativas ante fallos. Este módulo aborda los mecanismos y mejores prácticas para lograr estos objetivos.</p>
</div>
<div class="sect2">
<h3 id="_escalado_horizontal_de_pods_hpa">Escalado horizontal de pods (HPA)</h3>
<div class="paragraph">
<p>El <strong>Horizontal Pod Autoscaler</strong> (HPA) es un recurso de Kubernetes que ajusta automáticamente el número de réplicas de un Deployment, ReplicaSet o StatefulSet en función de métricas como el uso de CPU, memoria u otras métricas personalizadas. Esto permite que las aplicaciones escalen dinámicamente según la demanda, mejorando la eficiencia y la disponibilidad.</p>
</div>
<div class="sect3">
<h4 id="_cómo_funciona_el_hpa">¿Cómo funciona el HPA?</h4>
<div class="paragraph">
<p>El HPA monitoriza las métricas especificadas (por ejemplo, el uso promedio de CPU) y, si se supera un umbral definido, incrementa el número de pods. Si la carga disminuye, reduce el número de réplicas para optimizar el uso de recursos.</p>
</div>
<div class="paragraph">
<p>Para que el HPA funcione, es necesario tener instalado el <strong>Metrics Server</strong> en el clúster, ya que este componente recopila y expone las métricas de los pods.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_paso_a_paso">Ejemplo paso a paso</h4>
<div class="listingblock">
<div class="title">1. Instala Metrics Server (si no está instalado):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">2. Define un Deployment con recursos solicitados:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 2
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
        - name: webapp
          image: nginx
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "500m"
              memory: "256Mi"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">3. Crea un recurso HPA para escalar según el uso de CPU:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: webapp-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: webapp
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 50</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este HPA mantendrá entre 2 y 10 réplicas del Deployment <code>webapp</code>, ajustando el número de pods para mantener el uso promedio de CPU cerca del 50%.</p>
</div>
<div class="listingblock">
<div class="title">4. Verifica el estado del HPA:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get hpa
kubectl describe hpa webapp-hpa</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">5. (Opcional) Genera carga para observar el escalado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl run -i --tty load-generator --rm --image=busybox -- /bin/sh
# Dentro del pod, ejecuta:
while true; do wget -q -O- http://webapp; done</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_12">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Define correctamente los recursos (<code>requests</code> y <code>limits</code>) en los contenedores para que el HPA funcione de forma eficiente.</p>
</li>
<li>
<p>Ajusta los valores de <code>minReplicas</code> y <code>maxReplicas</code> según la capacidad del clúster y la criticidad de la aplicación.</p>
</li>
<li>
<p>Supervisa el comportamiento del HPA y revisa las métricas para evitar escalados innecesarios o insuficientes.</p>
</li>
<li>
<p>Considera el uso de métricas personalizadas (por ejemplo, latencia, número de peticiones) para escenarios avanzados.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_escalado_vertical">Escalado vertical</h3>
<div class="paragraph">
<p>El <strong>Vertical Pod Autoscaler</strong> (VPA) es un recurso de Kubernetes que ajusta automáticamente los recursos asignados (CPU y memoria) a los pods en función de su uso real. Es especialmente útil para aplicaciones que no pueden escalar horizontalmente o que requieren ajustes dinámicos de recursos para optimizar el rendimiento y la eficiencia.</p>
</div>
<div class="sect3">
<h4 id="_cómo_funciona_el_vpa">¿Cómo funciona el VPA?</h4>
<div class="paragraph">
<p>El VPA monitoriza el consumo de recursos de los pods y recomienda o aplica automáticamente nuevos valores de <code>requests</code> y <code>limits</code> para CPU y memoria. Cuando detecta que un pod necesita más (o menos) recursos, puede reiniciar el pod con los valores actualizados, asegurando que la aplicación tenga siempre los recursos adecuados.</p>
</div>
<div class="ulist">
<div class="title">Existen tres modos de funcionamiento:</div>
<ul>
<li>
<p><code>Off</code>: Solo recomienda recursos, pero no los aplica.</p>
</li>
<li>
<p><code>Auto</code>: Aplica automáticamente los cambios y reinicia los pods si es necesario.</p>
</li>
<li>
<p><code>Initial</code>: Solo ajusta los recursos al crear el pod, pero no los modifica después.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_despliegue_de_vpa">Ejemplo de despliegue de VPA</h4>
<div class="listingblock">
<div class="title">1. Instala el VPA en el clúster (si no está instalado):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f https://github.com/kubernetes/autoscaler/releases/latest/download/vertical-pod-autoscaler.yaml</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">2. Define un Deployment para la aplicación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 2
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
        - name: webapp
          image: nginx
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "500m"
              memory: "256Mi"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">3. Crea un recurso VPA asociado al Deployment:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: webapp-vpa
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind: Deployment
    name: webapp
  updatePolicy:
    updateMode: "Auto"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Con esta configuración, el VPA monitoriza el uso de recursos de los pods del Deployment <code>webapp</code> y ajusta automáticamente los valores de CPU y memoria según la demanda.</p>
</div>
</div>
<div class="sect3">
<h4 id="_comandos_útiles">Comandos útiles</h4>
<div class="ulist">
<ul>
<li>
<p>Ver recomendaciones del VPA:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl describe vpa webapp-vpa</code></pre>
</div>
</div>
</li>
<li>
<p>Ver los recursos actuales de los pods:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get pods -o jsonpath="{range .items[*]}{.metadata.name}{'\t'}{.spec.containers[*].resources}{'\n'}{end}"</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_13">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Las siguientes son algunas recomendaciones para el uso efectivo de VPA:</div>
<ul>
<li>
<p>Usa VPA para aplicaciones que no pueden escalar horizontalmente o que requieren ajustes finos de recursos.</p>
</li>
<li>
<p>No combines HPA y VPA en modo <code>Auto</code> sobre el mismo recurso, ya que pueden entrar en conflicto (usa HPA para réplicas y VPA para recursos, pero con precaución).</p>
</li>
<li>
<p>Supervisa el comportamiento tras aplicar VPA, ya que los pods pueden ser reiniciados automáticamente.</p>
</li>
<li>
<p>Ajusta los límites mínimos y máximos de recursos si es necesario para evitar asignaciones excesivas o insuficientes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_actualizaciones_sin_tiempo_de_inactividad">Actualizaciones sin tiempo de inactividad</h3>
<div class="paragraph">
<p>Kubernetes permite realizar actualizaciones de aplicaciones sin interrumpir el servicio mediante el mecanismo de <strong>rolling updates</strong> gestionado por los Deployments. Esto es fundamental para mantener la disponibilidad y la experiencia del usuario durante despliegues de nuevas versiones, correcciones o cambios de configuración.</p>
</div>
<div class="sect3">
<h4 id="_cómo_funcionan_las_actualizaciones_sin_downtime">¿Cómo funcionan las actualizaciones sin downtime?</h4>
<div class="paragraph">
<p>Cuando actualizas un Deployment (por ejemplo, cambiando la imagen del contenedor), Kubernetes crea gradualmente nuevos pods con la nueva versión y elimina los antiguos solo cuando los nuevos están listos. Este proceso se controla mediante los parámetros <code>maxUnavailable</code> y <code>maxSurge</code>, que definen cuántos pods pueden estar fuera de servicio y cuántos nuevos pueden crearse por encima del número deseado de réplicas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_deployment_con_estrategia_de_rolling_update">Ejemplo de Deployment con estrategia de rolling update</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
        - name: webapp
          image: nginx:1.25
          ports:
            - containerPort: 80</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>maxUnavailable: 1</code> permite que, como máximo, un pod no esté disponible durante la actualización.</p>
</li>
<li>
<p><code>maxSurge: 1</code> permite crear un pod adicional por encima del número de réplicas durante el despliegue.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_proceso_de_actualización_paso_a_paso">Proceso de actualización paso a paso</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Modifica el manifiesto del Deployment (por ejemplo, cambia la versión de la imagen).</p>
</li>
<li>
<p>Aplica el cambio:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f deployment.yaml</code></pre>
</div>
</div>
</li>
<li>
<p>Kubernetes inicia la actualización, creando nuevos pods y eliminando los antiguos de forma progresiva.</p>
</li>
<li>
<p>Puedes monitorizar el progreso con:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl rollout status deployment/webapp</code></pre>
</div>
</div>
</li>
<li>
<p>Si ocurre un error, puedes hacer rollback a la versión anterior:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl rollout undo deployment/webapp</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_14">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Define probes de <strong>readiness</strong> y <strong>liveness</strong> en los contenedores para asegurar que solo los pods listos reciban tráfico.</p>
</li>
<li>
<p>Usa <code>maxUnavailable</code> y <code>maxSurge</code> según la criticidad de la aplicación y la capacidad del clúster.</p>
</li>
<li>
<p>Supervisa el despliegue y revisa los logs para detectar posibles problemas.</p>
</li>
<li>
<p>Documenta el proceso de actualización y los parámetros utilizados.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_probes_en_el_deployment">Ejemplo de probes en el Deployment</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: webapp
    spec:
      containers:
        - name: webapp
          image: nginx:1.25
          ports:
            - containerPort: 80
          readinessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 15
            periodSeconds: 20</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estrategias_de_despliegue_avanzadas">Estrategias de despliegue avanzadas</h3>
<div class="paragraph">
<p>Las estrategias de despliegue avanzadas en Kubernetes permiten minimizar el impacto de los cambios en producción, reducir riesgos y facilitar la validación progresiva de nuevas versiones. Las más utilizadas son <strong>Blue/Green</strong>, <strong>Canary</strong> y <strong>A/B Testing</strong>. Todas ellas se pueden implementar combinando Deployments, Services, etiquetas y, en muchos casos, recursos Ingress o Service Mesh.</p>
</div>
<div class="sect3">
<h4 id="_bluegreen_deployment">Blue/Green Deployment</h4>
<div class="paragraph">
<p>En esta estrategia, existen dos entornos idénticos: uno activo (Blue) y otro inactivo (Green). El entorno Green se actualiza con la nueva versión y, tras las pruebas, el tráfico se redirige completamente del entorno Blue al Green.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de implementación con Deployments y Services:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Deployment Blue (versión actual)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-blue
spec:
  replicas: 3
  selector:
    matchLabels:
      app: webapp
      version: blue
  template:
    metadata:
      labels:
        app: webapp
        version: blue
    spec:
      containers:
        - name: webapp
          image: mi-app:v1</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Deployment Green (nueva versión)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-green
spec:
  replicas: 3
  selector:
    matchLabels:
      app: webapp
      version: green
  template:
    metadata:
      labels:
        app: webapp
        version: green
    spec:
      containers:
        - name: webapp
          image: mi-app:v2</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Service apuntando a la versión activa
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
spec:
  selector:
    app: webapp
    version: blue # Cambia a 'green' para hacer el switch
  ports:
    - port: 80
      targetPort: 80</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_canary_deployment">Canary Deployment</h4>
<div class="paragraph">
<div class="title">Para cambiar el tráfico a la nueva versión, solo actualiza el selector del Service a <code>version: green</code>.</div>
<p>Permite liberar la nueva versión a un pequeño porcentaje de usuarios/pods y, si no hay problemas, aumentar progresivamente el tráfico.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de implementación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Deployment estable (90% del tráfico)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-stable
spec:
  replicas: 9
  selector:
    matchLabels:
      app: webapp
      track: stable
  template:
    metadata:
      labels:
        app: webapp
        track: stable
    spec:
      containers:
        - name: webapp
          image: mi-app:v1</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Deployment canary (10% del tráfico)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-canary
spec:
  replicas: 1
  selector:
    matchLabels:
      app: webapp
      track: canary
  template:
    metadata:
      labels:
        app: webapp
        track: canary
    spec:
      containers:
        - name: webapp
          image: mi-app:v2</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Service balanceando entre ambas versiones
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
spec:
  selector:
    app: webapp
  ports:
    - port: 80
      targetPort: 80</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ab_testing">A/B Testing</h4>
<div class="paragraph">
<div class="title">Para un control más granular (por ejemplo, por porcentaje real de tráfico HTTP), utiliza un Ingress Controller avanzado (NGINX, Traefik) o un Service Mesh como Istio.</div>
<p>Similar al canary, pero el enrutamiento se basa en características del usuario, cabeceras HTTP, cookies, etc. Requiere un Ingress Controller avanzado o Service Mesh.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de regla de Ingress para A/B Testing con NGINX:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ab-ingress
  annotations:
    nginx.ingress.kubernetes.io/canary: "true"
    nginx.ingress.kubernetes.io/canary-by-header: "X-User-Type"
    nginx.ingress.kubernetes.io/canary-by-header-value: "beta"
spec:
  rules:
    - host: miapp.ejemplo.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: webapp-canary
                port:
                  number: 80</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_15">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Los usuarios que envíen la cabecera <code>X-User-Type: beta</code> serán dirigidos a la versión canary.</div>
<ul>
<li>
<p>Automatiza los despliegues y cambios de tráfico usando herramientas de CI/CD.</p>
</li>
<li>
<p>Supervisa métricas y logs durante el despliegue para detectar problemas rápidamente.</p>
</li>
<li>
<p>Define criterios claros de rollback y monitorea la experiencia del usuario.</p>
</li>
<li>
<p>Documenta cada estrategia y los pasos para revertir cambios si es necesario.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_gráfico_6">Resumen gráfico</h4>
<div class="imageblock">
<div class="content">
<img src="advanced-deploy-strategies.png" alt="advanced deploy strategies" width="262" height="515">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_autoscaling_basado_en_métricas">Autoscaling basado en métricas</h3>
<div class="paragraph">
<p>El autoscaling basado en métricas permite que Kubernetes ajuste automáticamente los recursos de las aplicaciones en función de métricas observadas, como el uso de CPU, memoria o métricas personalizadas (por ejemplo, número de peticiones, latencia, etc.). Esto garantiza que las aplicaciones puedan responder a cambios en la demanda de forma eficiente y automática.</p>
</div>
<div class="sect3">
<h4 id="_tipos_de_autoscaling_en_kubernetes">Tipos de autoscaling en Kubernetes</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Horizontal Pod Autoscaler (HPA)</strong>: Escala el número de pods de un Deployment, ReplicaSet o StatefulSet según métricas como CPU, memoria o métricas personalizadas.</p>
</li>
<li>
<p><strong>Vertical Pod Autoscaler (VPA)</strong>: Ajusta los recursos (CPU y memoria) asignados a los pods en función de su uso real.</p>
</li>
<li>
<p><strong>Cluster Autoscaler</strong>: Escala el número de nodos del clúster según la demanda de recursos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_hpa_basado_en_cpu_y_memoria">Ejemplo de HPA basado en CPU y memoria</h4>
<div class="paragraph">
<p>Para usar HPA con métricas de CPU y memoria, asegúrate de tener instalado el <strong>Metrics Server</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de Deployment:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: mi-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: mi-app
  template:
    metadata:
      labels:
        app: mi-app
    spec:
      containers:
        - name: mi-app
          image: nginx
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "500m"
              memory: "256Mi"</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de HPA usando CPU y memoria:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: mi-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: mi-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 60
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 70</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este HPA escalará el número de pods para mantener el uso promedio de CPU en 60% y de memoria en 70%.</p>
</div>
</div>
<div class="sect3">
<h4 id="_autoscaling_con_métricas_personalizadas">Autoscaling con métricas personalizadas</h4>
<div class="paragraph">
<p>Puedes escalar en función de métricas personalizadas (por ejemplo, número de peticiones HTTP, latencia, etc.) usando el <strong>Custom Metrics API</strong> y herramientas como Prometheus Adapter.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de HPA con métrica personalizada:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: mi-app-hpa-custom
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: mi-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Pods
      pods:
        metric:
          name: http_requests_per_second
        target:
          type: AverageValue
          averageValue: "100"</code></pre>
</div>
</div>
<div class="paragraph">
<p>En este ejemplo, el HPA escalará los pods para mantener un promedio de 100 peticiones HTTP por segundo por pod.</p>
</div>
</div>
<div class="sect3">
<h4 id="_cluster_autoscaler">Cluster Autoscaler</h4>
<div class="paragraph">
<p>El <strong>Cluster Autoscaler</strong> ajusta automáticamente el número de nodos en el clúster según la demanda de recursos. Es especialmente útil en entornos cloud, donde se pueden añadir o eliminar nodos dinámicamente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_16">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Para instalar el Cluster Autoscaler en GKE, EKS o AKS, consulta la documentación oficial de tu proveedor cloud.</div>
<ul>
<li>
<p>Define correctamente los recursos (<code>requests</code> y <code>limits</code>) en los contenedores para que el autoscaling funcione de forma eficiente.</p>
</li>
<li>
<p>Supervisa el comportamiento del autoscaling y ajusta los umbrales según la carga real de la aplicación.</p>
</li>
<li>
<p>Usa métricas personalizadas para escenarios avanzados y ajusta el HPA según las necesidades del negocio.</p>
</li>
<li>
<p>Considera el uso combinado de HPA, VPA y Cluster Autoscaler para una escalabilidad completa, pero revisa posibles conflictos.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_9_seguridad_en_kubernetes">Módulo 9: Seguridad en Kubernetes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La seguridad es un aspecto crítico en cualquier entorno de Kubernetes, ya que los clústeres suelen ejecutar aplicaciones sensibles y exponer servicios tanto internos como externos. Este módulo aborda los principales mecanismos y buenas prácticas para proteger los recursos, controlar el acceso y minimizar los riesgos.</p>
</div>
<div class="sect2">
<h3 id="_rbac_control_de_acceso_basado_en_roles">RBAC (Control de Acceso Basado en Roles)</h3>
<div class="paragraph">
<p>El <strong>Role-Based Access Control</strong> (RBAC) es el mecanismo principal de Kubernetes para gestionar los permisos y el acceso a los recursos del clúster. Permite definir de forma granular quién puede realizar qué acciones sobre qué recursos, mejorando la seguridad y el control operativo.</p>
</div>
<div class="sect3">
<h4 id="_conceptos_clave">Conceptos clave</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Role</strong>: Define un conjunto de permisos (acciones sobre recursos) dentro de un namespace específico.</p>
</li>
<li>
<p><strong>ClusterRole</strong>: Similar a Role, pero los permisos aplican a todos los namespaces o a recursos globales del clúster.</p>
</li>
<li>
<p><strong>RoleBinding</strong>: Asocia un Role a un usuario, grupo o ServiceAccount dentro de un namespace.</p>
</li>
<li>
<p><strong>ClusterRoleBinding</strong>: Asocia un ClusterRole a usuarios, grupos o ServiceAccounts a nivel de clúster.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_básico_de_role_y_rolebinding">Ejemplo básico de Role y RoleBinding</h4>
<div class="paragraph">
<p>Supón que quieres permitir que un usuario o ServiceAccount solo pueda listar y ver pods en el namespace <code>produccion</code>.</p>
</div>
<div class="listingblock">
<div class="title">Role:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: produccion
  name: lector-pods
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">RoleBinding:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vincular-lector
  namespace: produccion
subjects:
  - kind: User
    name: juan
    apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: lector-pods
  apiGroup: rbac.authorization.k8s.io</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_clusterrole_y_clusterrolebinding">Ejemplo de ClusterRole y ClusterRoleBinding</h4>
<div class="paragraph">
<p>Para otorgar permisos de solo lectura sobre todos los pods del clúster a un ServiceAccount:</p>
</div>
<div class="listingblock">
<div class="title">ClusterRole:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cluster-lector-pods
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">ClusterRoleBinding:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cluster-vincular-lector
subjects:
  - kind: ServiceAccount
    name: lector
    namespace: produccion
roleRef:
  kind: ClusterRole
  name: cluster-lector-pods
  apiGroup: rbac.authorization.k8s.io</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_17">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Algunas recomendaciones para implementar RBAC de forma efectiva:</div>
<ul>
<li>
<p>Aplica el principio de menor privilegio: otorga solo los permisos estrictamente necesarios.</p>
</li>
<li>
<p>Usa ServiceAccounts para aplicaciones y automatizaciones, no usuarios personales.</p>
</li>
<li>
<p>Prefiere Role/RoleBinding para permisos en un namespace y ClusterRole/ClusterRoleBinding solo cuando sea necesario.</p>
</li>
<li>
<p>Revisa y audita periódicamente los permisos asignados.</p>
</li>
<li>
<p>Documenta los roles y bindings creados para facilitar el mantenimiento y la seguridad.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_service_accounts">Service Accounts</h3>
<div class="paragraph">
<p>Las <strong>Service Accounts</strong> en Kubernetes son identidades especiales que utilizan los pods y procesos dentro del clúster para autenticarse y acceder a la API de Kubernetes. A diferencia de los usuarios humanos, las Service Accounts están pensadas para aplicaciones, controladores y scripts automatizados que necesitan interactuar con recursos del clúster.</p>
</div>
<div class="sect3">
<h4 id="_para_qué_se_usan_las_service_accounts">¿Para qué se usan las Service Accounts?</h4>
<div class="ulist">
<ul>
<li>
<p>Permitir que los pods accedan a la API de Kubernetes de forma segura y controlada.</p>
</li>
<li>
<p>Asociar permisos específicos a aplicaciones mediante RBAC.</p>
</li>
<li>
<p>Separar los permisos de las aplicaciones de los usuarios humanos.</p>
</li>
<li>
<p>Facilitar la rotación y gestión de credenciales de acceso.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Por defecto, cada namespace tiene una Service Account llamada <code>default</code>, pero es recomendable crear cuentas específicas para cada aplicación o componente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_creación_y_uso_de_una_service_account">Ejemplo de creación y uso de una Service Account</h4>
<div class="listingblock">
<div class="title">1. Crea una Service Account personalizada:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: ServiceAccount
metadata:
  name: mi-app-sa
  namespace: produccion</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">2. Asocia la Service Account a un pod o deployment:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: mi-app
  namespace: produccion
spec:
  replicas: 2
  selector:
    matchLabels:
      app: mi-app
  template:
    metadata:
      labels:
        app: mi-app
    spec:
      serviceAccountName: mi-app-sa
      containers:
        - name: app
          image: nginx</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">3. Otorga permisos a la Service Account usando RBAC:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: lector-configmaps
  namespace: produccion
rules:
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vincular-lector-configmaps
  namespace: produccion
subjects:
  - kind: ServiceAccount
    name: mi-app-sa
    namespace: produccion
roleRef:
  kind: Role
  name: lector-configmaps
  apiGroup: rbac.authorization.k8s.io</code></pre>
</div>
</div>
<div class="paragraph">
<p>Con esta configuración, los pods del deployment <code>mi-app</code> podrán listar y obtener ConfigMaps en el namespace <code>produccion</code>, pero no tendrán permisos adicionales.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_18">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Estas son algunas recomendaciones para gestionar Service Accounts de forma segura:</div>
<ul>
<li>
<p>Crea una Service Account específica para cada aplicación o componente que requiera acceso a la API.</p>
</li>
<li>
<p>Usa RBAC para limitar los permisos de cada Service Account al mínimo necesario (principio de menor privilegio).</p>
</li>
<li>
<p>No uses la Service Account <code>default</code> para aplicaciones en producción.</p>
</li>
<li>
<p>Rota y gestiona los tokens de acceso de las Service Accounts según las políticas de seguridad de tu organización.</p>
</li>
<li>
<p>Supervisa el uso de Service Accounts y revisa los permisos asignados periódicamente.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_network_policies">Network Policies</h3>
<div class="paragraph">
<p>Las <strong>Network Policies</strong> en Kubernetes son recursos que permiten controlar el tráfico de red entre pods y otros recursos dentro del clúster. Son esenciales para mejorar la seguridad, ya que definen de manera declarativa qué conexiones están permitidas y cuáles no, limitando la superficie de ataque y el movimiento lateral en caso de compromisos.</p>
</div>
<div class="sect3">
<h4 id="_qué_es_una_networkpolicy_2">¿Qué es una NetworkPolicy?</h4>
<div class="paragraph">
<p>Una NetworkPolicy es un objeto de Kubernetes que especifica cómo los pods pueden comunicarse entre sí y con otros endpoints (otros pods, namespaces, direcciones IP externas, etc.). Por defecto, si no hay ninguna política aplicada, todo el tráfico entre pods está permitido. Al aplicar una NetworkPolicy, solo el tráfico explícitamente permitido por las reglas será aceptado; el resto será bloqueado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_cómo_funcionan_las_networkpolicies_2">¿Cómo funcionan las NetworkPolicies?</h4>
<div class="paragraph">
<p>Las NetworkPolicies funcionan seleccionando pods mediante etiquetas (<code>labels</code>) y definiendo reglas de entrada (<code>ingress</code>) y salida (<code>egress</code>). Estas reglas pueden restringir el tráfico según:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>El origen o destino (otros pods, namespaces, IPs).</p>
</li>
<li>
<p>El puerto y el protocolo.</p>
</li>
<li>
<p>Las etiquetas de los pods.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Para que las NetworkPolicies tengan efecto, el clúster debe usar un plugin de red compatible con este recurso, como Calico, Cilium o Weave.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_básico_permitir_solo_tráfico_de_frontend_a_backend">Ejemplo básico: Permitir solo tráfico de frontend a backend</h4>
<div class="paragraph">
<p>Supón que tienes dos aplicaciones: un frontend y un backend, cada una en su propio pod. Solo quieres permitir que el frontend se comunique con el backend, y bloquear el resto del tráfico.</p>
</div>
<div class="listingblock">
<div class="title">Primero, define los pods con sus etiquetas:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># pod-frontend.yml
apiVersion: v1
kind: Pod
metadata:
  name: frontend
  labels:
    app: frontend
spec:
  containers:
    - name: app
      image: nginx
      ports:
        - containerPort: 80</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># pod-backend.yml
apiVersion: v1
kind: Pod
metadata:
  name: backend
  labels:
    app: backend
spec:
  containers:
    - name: app
      image: nginx
      ports:
        - containerPort: 80</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ahora, crea la NetworkPolicy para permitir solo el tráfico de los pods con la etiqueta <code>app: frontend</code> hacia los pods con la etiqueta <code>app: backend</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># networkpolicy-backend.yml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-frontend-to-backend
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
    - Ingress
  ingress:
    - from:
        - podSelector:
            matchLabels:
              app: frontend
      ports:
        - protocol: TCP
          port: 80</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Con esta configuración:</div>
<ul>
<li>
<p>Solo los pods con la etiqueta <code>app: frontend</code> podrán acceder al puerto 80 de los pods con la etiqueta <code>app: backend</code>.</p>
</li>
<li>
<p>Todo el tráfico de entrada desde otros pods o fuentes será bloqueado.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_avanzado_permitir_tráfico_de_salida_solo_a_internet_2">Ejemplo avanzado: Permitir tráfico de salida solo a Internet</h4>
<div class="paragraph">
<p>Supón que quieres que tus pods solo puedan acceder a Internet (por ejemplo, para actualizaciones o APIs externas), pero no a otros pods del clúster.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># networkpolicy-egress-internet.yml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-egress-to-internet
spec:
  podSelector: {} # Aplica a todos los pods del namespace
  policyTypes:
    - Egress
  egress:
    - to:
        - ipBlock:
            cidr: 0.0.0.0/0
      ports:
        - protocol: TCP
          port: 443
        - protocol: TCP
          port: 80</code></pre>
</div>
</div>
<div class="ulist">
<div class="title">Esta política:</div>
<ul>
<li>
<p>Permite a todos los pods del namespace realizar conexiones de salida (egress) solo a cualquier dirección IP (Internet) en los puertos 80 y 443.</p>
</li>
<li>
<p>Bloquea el tráfico de salida a otros pods del clúster, a menos que se definan reglas adicionales.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_tipos_de_reglas">Tipos de reglas</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Ingress</strong>: Controla el tráfico entrante a los pods seleccionados.</p>
</li>
<li>
<p><strong>Egress</strong>: Controla el tráfico saliente desde los pods seleccionados.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_19">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Aplica el principio de menor privilegio: solo permite el tráfico necesario.</p>
</li>
<li>
<p>Prueba las políticas en entornos de desarrollo antes de aplicarlas en producción.</p>
</li>
<li>
<p>Documenta las reglas y mantenlas actualizadas.</p>
</li>
<li>
<p>Supervisa el tráfico y revisa los logs para detectar intentos de acceso no autorizados.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_diagrama_explicativo">Diagrama explicativo</h4>
<div class="imageblock">
<div class="content">
<img src="network-policy-example.png" alt="network policy example" width="264" height="243">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_pod_security_policies">Pod Security Policies</h3>
<div class="paragraph">
<p>Las <strong>Pod Security Policies</strong> (PSP) fueron un mecanismo de Kubernetes para controlar la seguridad a nivel de pod, definiendo qué características de seguridad están permitidas al crear pods en el clúster. Aunque PSP está oficialmente deprecated desde Kubernetes 1.21 y eliminado en 1.25, es importante conocer su funcionamiento y las alternativas modernas.</p>
</div>
<div class="sect3">
<h4 id="_qué_es_una_pod_security_policy">¿Qué es una Pod Security Policy?</h4>
<div class="paragraph">
<p>Una PSP es un recurso que especifica un conjunto de condiciones que los pods deben cumplir para ser aceptados por el clúster. Permite restringir aspectos como:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Uso de privilegios (privileged)</p>
</li>
<li>
<p>Montaje de volúmenes hostPath</p>
</li>
<li>
<p>Usuarios y grupos de ejecución (runAsUser, fsGroup)</p>
</li>
<li>
<p>Capabilities de Linux permitidas o bloqueadas</p>
</li>
<li>
<p>Acceso a la red, puertos, seccomp, AppArmor, etc.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_pod_security_policy">Ejemplo de Pod Security Policy</h4>
<div class="paragraph">
<p>El siguiente ejemplo solo permite pods que no sean privilegiados, no usen hostPath y ejecuten como un usuario no root:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: ejemplo-psp
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    - 'persistentVolumeClaim'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  supplementalGroups:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para que una PSP tenga efecto, debe asociarse a usuarios o ServiceAccounts mediante RBAC:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: usar-psp
  namespace: produccion
rules:
  - apiGroups: ['policy']
    resources: ['podsecuritypolicies']
    verbs: ['use']
    resourceNames: ['ejemplo-psp']
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: vincular-psp
  namespace: produccion
subjects:
  - kind: ServiceAccount
    name: mi-app-sa
    namespace: produccion
roleRef:
  kind: Role
  name: usar-psp
  apiGroup: rbac.authorization.k8s.io</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_limitaciones_y_estado_actual">Limitaciones y estado actual</h4>
<div class="ulist">
<ul>
<li>
<p>PSP está deprecated y eliminado en versiones recientes de Kubernetes.</p>
</li>
<li>
<p>Su configuración era compleja y difícil de mantener en clústeres grandes.</p>
</li>
<li>
<p>No cubría todos los escenarios de seguridad y podía ser bypassed accidentalmente.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_alternativas_modernas_pod_security_admission_psa">Alternativas modernas: Pod Security Admission (PSA)</h4>
<div class="paragraph">
<p>Kubernetes recomienda usar el <strong>Pod Security Admission</strong> (PSA), disponible desde la versión 1.22, que implementa tres niveles de políticas predefinidas:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Privileged</strong>: Sin restricciones (para pods de sistema o administración).</p>
</li>
<li>
<p><strong>Baseline</strong>: Permite buenas prácticas mínimas de seguridad.</p>
</li>
<li>
<p><strong>Restricted</strong>: Aplica las restricciones más estrictas (no root, sin privilegios, sin hostPath, etc.).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>La configuración se realiza mediante labels en los namespaces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl label namespace produccion pod-security.kubernetes.io/enforce=restricted
kubectl label namespace produccion pod-security.kubernetes.io/audit=baseline
kubectl label namespace produccion pod-security.kubernetes.io/warn=restricted</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_20">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Las siguientes son algunas recomendaciones para implementar políticas de seguridad efectivas:</div>
<ul>
<li>
<p>Usa PSA en lugar de PSP en clústeres modernos.</p>
</li>
<li>
<p>Aplica el nivel <code>restricted</code> en producción para máxima seguridad.</p>
</li>
<li>
<p>Documenta y revisa las políticas aplicadas en cada namespace.</p>
</li>
<li>
<p>Complementa con herramientas como OPA Gatekeeper, Kyverno o Kubewarden para políticas personalizadas.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_escaneo_de_vulnerabilidades_en_contenedores">Escaneo de vulnerabilidades en contenedores</h3>
<div class="paragraph">
<p>El escaneo de vulnerabilidades en contenedores es una práctica esencial para garantizar la seguridad de las aplicaciones desplegadas en Kubernetes. Consiste en analizar las imágenes de contenedor en busca de vulnerabilidades conocidas en los sistemas operativos, librerías y dependencias incluidas en la imagen.</p>
</div>
<div class="sect3">
<h4 id="_por_qué_es_importante_el_escaneo_de_vulnerabilidades">¿Por qué es importante el escaneo de vulnerabilidades?</h4>
<div class="ulist">
<ul>
<li>
<p>Las imágenes de contenedor pueden contener vulnerabilidades heredadas de sus bases o dependencias.</p>
</li>
<li>
<p>El escaneo ayuda a identificar y corregir problemas antes de que lleguen a producción.</p>
</li>
<li>
<p>Permite cumplir con normativas y estándares de seguridad (como CIS, NIST, PCI-DSS).</p>
</li>
<li>
<p>Reduce el riesgo de explotación de vulnerabilidades conocidas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_herramientas_populares_de_escaneo">Herramientas populares de escaneo</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Trivy</strong>: Sencilla, rápida y soporta múltiples fuentes de vulnerabilidades.</p>
</li>
<li>
<p><strong>Clair</strong>: Integrable con registries y plataformas CI/CD.</p>
</li>
<li>
<p><strong>Anchore Engine</strong>: Ofrece análisis profundo y políticas personalizadas.</p>
</li>
<li>
<p><strong>Grype</strong>: Escáner de vulnerabilidades de Syft, fácil de integrar.</p>
</li>
<li>
<p><strong>Aqua Microscanner</strong> y <strong>Snyk</strong>: Soluciones comerciales y SaaS con integración CI/CD.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_escaneo_con_trivy">Ejemplo de escaneo con Trivy</h4>
<div class="listingblock">
<div class="title">Instala Trivy:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">sudo apt-get install trivy
# o usando Homebrew:
brew install aquasecurity/trivy/trivy</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Escanea una imagen local o remota:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">trivy image nginx:latest</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_integración_en_pipelines_cicd">Integración en pipelines CI/CD</h4>
<div class="paragraph">
<div class="title">El resultado mostrará las vulnerabilidades encontradas, su severidad y recomendaciones de actualización.</div>
<p>El escaneo de vulnerabilidades debe integrarse en el ciclo de vida de desarrollo y despliegue:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Añade pasos de escaneo en pipelines de CI (GitLab CI, GitHub Actions, Jenkins, etc.).</p>
</li>
<li>
<p>Falla el pipeline si se detectan vulnerabilidades críticas o altas.</p>
</li>
<li>
<p>Genera reportes automáticos y alertas para el equipo de desarrollo.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de paso en GitLab CI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">scan:
  image: aquasec/trivy:latest
  script:
    - trivy image $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_escaneo_continuo_en_kubernetes">Escaneo continuo en Kubernetes</h4>
<div class="paragraph">
<p>Además del escaneo previo al despliegue, es recomendable realizar escaneo continuo de las imágenes en uso en el clúster:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Usa herramientas como <strong>Kube-bench</strong> para auditar la configuración del clúster.</p>
</li>
<li>
<p>Implementa soluciones como <strong>Trivy Operator</strong> o <strong>Starboard</strong> para escanear imágenes de pods en ejecución y generar reportes como recursos de Kubernetes.</p>
</li>
<li>
<p>Configura alertas para nuevas vulnerabilidades descubiertas en imágenes ya desplegadas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_21">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Escanea todas las imágenes antes de subirlas al registry y antes de desplegarlas.</p>
</li>
<li>
<p>Mantén las imágenes y dependencias actualizadas.</p>
</li>
<li>
<p>Usa imágenes oficiales y minimizadas (distroless, Alpine, etc.).</p>
</li>
<li>
<p>Elimina dependencias y paquetes innecesarios de las imágenes.</p>
</li>
<li>
<p>Automatiza el escaneo y la gestión de vulnerabilidades en el pipeline de CI/CD.</p>
</li>
<li>
<p>Documenta y sigue un proceso de remediación para vulnerabilidades detectadas.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_10_monitorización_y_observabilidad">Módulo 10: Monitorización y Observabilidad</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La monitorización y la observabilidad son fundamentales para operar aplicaciones y clústeres Kubernetes en producción. Permiten detectar problemas, analizar el comportamiento de los sistemas y anticipar incidencias antes de que afecten a los usuarios. Este módulo cubre las herramientas y prácticas clave para lograr una observabilidad completa en Kubernetes.</p>
</div>
<div class="sect2">
<h3 id="_stack_de_monitorización_prometheus">Stack de monitorización (Prometheus)</h3>
<div class="paragraph">
<p>Prometheus es la herramienta estándar para la monitorización de clústeres Kubernetes. Permite recolectar, almacenar y consultar métricas de los nodos, pods, servicios y aplicaciones, facilitando la detección de problemas y el análisis de tendencias.</p>
</div>
<div class="sect3">
<h4 id="_cómo_funciona_prometheus_en_kubernetes">¿Cómo funciona Prometheus en Kubernetes?</h4>
<div class="ulist">
<ul>
<li>
<p>Prometheus se despliega como un pod o conjunto de pods dentro del clúster.</p>
</li>
<li>
<p>Descubre automáticamente los endpoints de métricas de los componentes de Kubernetes y de las aplicaciones instrumentadas.</p>
</li>
<li>
<p>Almacena las métricas en una base de datos de series temporales.</p>
</li>
<li>
<p>Permite definir alertas y consultas usando PromQL.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_despliegue_de_prometheus_con_helm">Despliegue de Prometheus con Helm</h4>
<div class="paragraph">
<p>La forma más sencilla y recomendada de instalar Prometheus en Kubernetes es usando el chart oficial de Helm, que incluye Prometheus, Alertmanager, node-exporter y kube-state-metrics.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
helm install prometheus prometheus-community/kube-prometheus-stack</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto desplegará todo el stack de monitorización en el namespace por defecto. Puedes personalizar la instalación usando valores de Helm.</p>
</div>
</div>
<div class="sect3">
<h4 id="_exponer_la_interfaz_web_de_prometheus">Exponer la interfaz web de Prometheus</h4>
<div class="paragraph">
<p>Para acceder a la interfaz web de Prometheus desde tu máquina local:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl port-forward svc/prometheus-kube-prometheus-prometheus 9090:9090
# Luego abre http://localhost:9090 en tu navegador</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_monitorización_de_aplicaciones_personalizadas">Monitorización de aplicaciones personalizadas</h4>
<div class="paragraph">
<p>Para que Prometheus recolecte métricas de tus aplicaciones, estas deben exponer un endpoint <code>/metrics</code> en formato Prometheus. Puedes usar librerías como <code>prometheus-client</code> en Python, Go, Java, etc.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de ServiceMonitor para una aplicación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: mi-app-monitor
  labels:
    release: prometheus
spec:
  selector:
    matchLabels:
      app: mi-app
  endpoints:
    - port: http
      path: /metrics
      interval: 15s</code></pre>
</div>
</div>
<div class="paragraph">
<p>Asegúrate de que el Service de tu aplicación tenga el label <code>app: mi-app</code> y exponga el puerto adecuado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_alertas_con_alertmanager">Alertas con Alertmanager</h4>
<div class="paragraph">
<p>Prometheus puede enviar alertas a través de Alertmanager cuando se cumplen ciertas condiciones (por ejemplo, alto uso de CPU, pods caídos, etc.).</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de regla de alerta:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: high-cpu-usage
  labels:
    release: prometheus
spec:
  groups:
    - name: example.rules
      rules:
        - alert: HighCpuUsage
          expr: sum(rate(container_cpu_usage_seconds_total{image!=""}[5m])) by (pod) &gt; 0.8
          for: 5m
          labels:
            severity: warning
          annotations:
            summary: "Alto uso de CPU en el pod"
            description: "El pod {{ $labels.pod }} está usando más del 80% de CPU durante 5 minutos."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alertmanager puede integrarse con email, Slack, PagerDuty y otros sistemas de notificación.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_22">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Instrumenta tus aplicaciones para exponer métricas relevantes.</p>
</li>
<li>
<p>Usa ServiceMonitors para descubrir y recolectar métricas de servicios personalizados.</p>
</li>
<li>
<p>Define alertas proactivas para anticipar problemas.</p>
</li>
<li>
<p>Protege el acceso a la interfaz de Prometheus y Alertmanager.</p>
</li>
<li>
<p>Almacena las métricas en un almacenamiento persistente si necesitas retención a largo plazo.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_visualización_con_grafana">Visualización con Grafana</h3>
<div class="paragraph">
<p><strong>Grafana</strong> es la herramienta más popular para la visualización de métricas y datos de monitorización en Kubernetes. Permite crear dashboards interactivos y personalizables a partir de las métricas recolectadas por Prometheus u otras fuentes, facilitando el análisis visual del estado y rendimiento del clúster y las aplicaciones.</p>
</div>
<div class="sect3">
<h4 id="_cómo_funciona_grafana_en_kubernetes">¿Cómo funciona Grafana en Kubernetes?</h4>
<div class="ulist">
<ul>
<li>
<p>Grafana se despliega como un pod dentro del clúster, generalmente junto con Prometheus.</p>
</li>
<li>
<p>Se conecta a Prometheus (u otras fuentes de datos) para consultar y graficar métricas.</p>
</li>
<li>
<p>Permite crear dashboards personalizados para visualizar el uso de CPU, memoria, estado de pods, tráfico de red, latencia, etc.</p>
</li>
<li>
<p>Soporta alertas visuales y notificaciones integradas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_despliegue_de_grafana_con_helm">Despliegue de Grafana con Helm</h4>
<div class="paragraph">
<p>La forma más sencilla de instalar Grafana en Kubernetes es usando el mismo chart de Helm que instala Prometheus (kube-prometheus-stack), ya que incluye Grafana preconfigurado.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo update
helm install prometheus prometheus-community/kube-prometheus-stack</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto desplegará Grafana junto con Prometheus y otros componentes en el clúster.</p>
</div>
</div>
<div class="sect3">
<h4 id="_acceso_a_la_interfaz_de_grafana">Acceso a la interfaz de Grafana</h4>
<div class="paragraph">
<p>Para acceder a la interfaz web de Grafana desde tu máquina local:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl port-forward svc/prometheus-grafana 3000:80
# Luego abre http://localhost:3000 en tu navegador</code></pre>
</div>
</div>
<div class="paragraph">
<p>El usuario y contraseña por defecto suelen ser <code>admin</code> / <code>prom-operator</code> (puedes consultarlo en los secrets del namespace).</p>
</div>
</div>
<div class="sect3">
<h4 id="_dashboards_recomendados">Dashboards recomendados</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Kubernetes / Compute Resources / Cluster</strong>: Uso de CPU y memoria por nodo y por pod.</p>
</li>
<li>
<p><strong>Kubernetes / Networking / Namespace (Pods)</strong>: Tráfico de red por namespace y pod.</p>
</li>
<li>
<p><strong>Kubernetes / Resources / Persistent Volumes</strong>: Estado y uso de volúmenes persistentes.</p>
</li>
<li>
<p><strong>Custom dashboards</strong>: Puedes crear dashboards personalizados para tus aplicaciones, servicios o métricas específicas.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Puedes importar dashboards desde <a href="https://grafana.com/grafana/dashboards/" class="bare">https://grafana.com/grafana/dashboards/</a> usando el ID correspondiente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_configuración_de_datasource_en_grafana">Ejemplo de configuración de datasource en Grafana</h4>
<div class="paragraph">
<p>Si despliegas Grafana por separado, debes configurar Prometheus como fuente de datos:</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_23">Buenas prácticas</h4>
<div class="ulist">
<div class="title">3. Usa la URL interna del servicio Prometheus, por ejemplo: <code><a href="http://prometheus-kube-prometheus-prometheus.monitoring.svc.cluster.local:9090" class="bare">http://prometheus-kube-prometheus-prometheus.monitoring.svc.cluster.local:9090</a></code>.</div>
<ul>
<li>
<p>Protege el acceso a Grafana con autenticación y, si es posible, Single Sign-On (SSO).</p>
</li>
<li>
<p>Usa dashboards compartidos para equipos de desarrollo, operaciones y negocio.</p>
</li>
<li>
<p>Automatiza la provisión de dashboards usando ConfigMaps o el API de Grafana.</p>
</li>
<li>
<p>Configura alertas visuales y notificaciones para eventos críticos.</p>
</li>
<li>
<p>Versiona y documenta los dashboards más importantes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_trazabilidad_con_jaegerzipkin">Trazabilidad con Jaeger/Zipkin</h3>
<div class="paragraph">
<p>La trazabilidad (tracing) es un pilar fundamental de la observabilidad en arquitecturas de microservicios. Permite seguir el recorrido de una petición a través de los diferentes servicios y componentes, identificando cuellos de botella, errores y latencias. En Kubernetes, las herramientas más populares para trazabilidad distribuida son <strong>Jaeger</strong> y <strong>Zipkin</strong>.</p>
</div>
<div class="sect3">
<h4 id="_por_qué_es_importante_la_trazabilidad">¿Por qué es importante la trazabilidad?</h4>
<div class="ulist">
<ul>
<li>
<p>Permite visualizar el flujo de las peticiones entre microservicios.</p>
</li>
<li>
<p>Ayuda a identificar servicios lentos o problemáticos.</p>
</li>
<li>
<p>Facilita el análisis de dependencias y la detección de errores en entornos complejos.</p>
</li>
<li>
<p>Es clave para el troubleshooting y la optimización de aplicaciones distribuidas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_jaeger_y_zipkin_características_principales">Jaeger y Zipkin: características principales</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Jaeger</strong>: Proyecto de la CNCF, soporta almacenamiento escalable, visualización avanzada y múltiples backends. Se integra fácilmente con Istio, OpenTelemetry y otros frameworks.</p>
</li>
<li>
<p><strong>Zipkin</strong>: Ligero y sencillo, ideal para entornos pequeños o pruebas rápidas. Compatible con OpenTracing y OpenTelemetry.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ambas herramientas recolectan y almacenan <strong>spans</strong> (fragmentos de trazas) generados por las aplicaciones instrumentadas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_despliegue_de_jaeger_en_kubernetes">Despliegue de Jaeger en Kubernetes</h4>
<div class="paragraph">
<p>La forma más sencilla de desplegar Jaeger es usando el operador oficial o Helm.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl create namespace observabilidad
kubectl apply -f https://github.com/jaegertracing/jaeger-operator/releases/download/v1.56.0/jaeger-operator.yaml -n observabilidad</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Crear una instancia de Jaeger:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: jaegertracing.io/v1
kind: Jaeger
metadata:
  name: jaeger-demo
  namespace: observabilidad
spec:
  strategy: allInOne</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Acceso a la interfaz web de Jaeger:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl port-forward service/jaeger-demo-query -n observabilidad 16686:16686
# Luego abre http://localhost:16686 en tu navegador</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_despliegue_de_zipkin_en_kubernetes">Despliegue de Zipkin en Kubernetes</h4>
<div class="paragraph">
<p>Puedes desplegar Zipkin usando un manifiesto oficial o Helm:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl create deployment zipkin --image=openzipkin/zipkin
kubectl expose deployment zipkin --port=9411
kubectl port-forward svc/zipkin 9411:9411
# Accede a http://localhost:9411</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_instrumentación_de_aplicaciones">Instrumentación de aplicaciones</h4>
<div class="paragraph">
<p>Para aprovechar Jaeger o Zipkin, tus aplicaciones deben estar instrumentadas para generar trazas. Puedes usar librerías de OpenTelemetry, OpenTracing o clientes específicos para Jaeger/Zipkin en tu lenguaje de programación.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo básico en Python con OpenTelemetry:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-python hljs" data-lang="python">from opentelemetry import trace
from opentelemetry.exporter.jaeger.thrift import JaegerExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor

trace.set_tracer_provider(TracerProvider())
jaeger_exporter = JaegerExporter(agent_host_name="jaeger-demo-agent", agent_port=6831)
trace.get_tracer_provider().add_span_processor(BatchSpanProcessor(jaeger_exporter))

tracer = trace.get_tracer(__name__)
with tracer.start_as_current_span("mi-operacion"):
    # Lógica de la aplicación
    pass</code></pre>
</div>
</div>
<div class="paragraph">
<p>En otros lenguajes (Java, Go, Node.js, etc.) existen librerías equivalentes.</p>
</div>
</div>
<div class="sect3">
<h4 id="_integración_con_service_mesh_istio">Integración con Service Mesh (Istio)</h4>
<div class="paragraph">
<p>Si usas Istio, la inyección automática de sidecars Envoy permite recolectar trazas de todo el tráfico entre servicios sin modificar el código de las aplicaciones. Solo debes habilitar la integración con Jaeger o Zipkin en la configuración de Istio.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">istioctl install --set values.tracing.enabled=true</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_24">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Instrumenta todos los servicios críticos para obtener trazas completas.</p>
</li>
<li>
<p>Usa headers estándar (<code>traceparent</code>, <code>b3</code>) para propagar el contexto de trazas entre servicios.</p>
</li>
<li>
<p>Almacena las trazas el tiempo suficiente para análisis y troubleshooting, pero define políticas de retención.</p>
</li>
<li>
<p>Integra la trazabilidad con tus dashboards de observabilidad (Grafana, Kiali, etc.).</p>
</li>
<li>
<p>Supervisa el impacto en el rendimiento y ajusta el muestreo de trazas según la carga.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_resumen">Resumen</h4>
<div class="paragraph">
<p>La trazabilidad distribuida con Jaeger o Zipkin permite visualizar y analizar el flujo de peticiones en arquitecturas de microservicios sobre Kubernetes. Su integración facilita la detección de problemas, la optimización de la experiencia de usuario y la mejora continua de las aplicaciones.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_alertas_y_notificaciones">Alertas y notificaciones</h3>
<div class="paragraph">
<p>Las alertas y notificaciones son componentes clave de la observabilidad en Kubernetes, ya que permiten detectar y responder rápidamente a incidentes, anomalías o degradaciones en el clúster y las aplicaciones. Un sistema de alertas bien configurado ayuda a minimizar el tiempo de inactividad y a mejorar la fiabilidad operativa.</p>
</div>
<div class="sect3">
<h4 id="_cómo_funcionan_las_alertas_en_kubernetes">¿Cómo funcionan las alertas en Kubernetes?</h4>
<div class="paragraph">
<p>Las alertas suelen configurarse sobre métricas recolectadas por Prometheus. Cuando una métrica supera un umbral definido (por ejemplo, uso de CPU alto, pods no disponibles, errores en aplicaciones), Prometheus genera una alerta que es gestionada por Alertmanager.</p>
</div>
<div class="ulist">
<div class="title">Funciones de Alertmanager:</div>
<ul>
<li>
<p>Agrupar, silenciar y deduplicar alertas.</p>
</li>
<li>
<p>Enviar notificaciones a canales como email, Slack, Microsoft Teams, PagerDuty, Opsgenie, Webhooks, etc.</p>
</li>
<li>
<p>Aplicar reglas de enrutamiento y escalado de alertas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_regla_de_alerta_en_prometheus">Ejemplo de regla de alerta en Prometheus</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: reglas-alerta
  labels:
    release: prometheus
spec:
  groups:
    - name: reglas.ejemplo
      rules:
        - alert: PodDown
          expr: kube_pod_status_phase{phase="Failed"} &gt; 0
          for: 2m
          labels:
            severity: critical
          annotations:
            summary: "Pod fallido detectado"
            description: "Uno o más pods están en estado Failed por más de 2 minutos."
        - alert: HighMemoryUsage
          expr: sum(container_memory_usage_bytes{container!=""}) by (pod) &gt; 500000000
          for: 5m
          labels:
            severity: warning
          annotations:
            summary: "Alto uso de memoria"
            description: "El pod {{ $labels.pod }} está usando más de 500MB de memoria durante 5 minutos."</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuración_básica_de_alertmanager">Configuración básica de Alertmanager</h4>
<div class="paragraph">
<p>Alertmanager se despliega junto con Prometheus (por ejemplo, usando kube-prometheus-stack) y se configura mediante un archivo YAML.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de configuración para enviar alertas por email y Slack:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">global:
  smtp_smarthost: 'smtp.gmail.com:587'
  smtp_from: 'alertas@miempresa.com'
  smtp_auth_username: 'alertas@miempresa.com'
  smtp_auth_password: 'contraseña'

route:
  receiver: 'equipo-devops'

receivers:
  - name: 'equipo-devops'
    email_configs:
      - to: 'devops@miempresa.com'
    slack_configs:
      - api_url: 'https://hooks.slack.com/services/XXX/YYY/ZZZ'
        channel: '#alertas-k8s'</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puedes montar este archivo como ConfigMap en el pod de Alertmanager.</p>
</div>
</div>
<div class="sect3">
<h4 id="_acceso_y_pruebas_de_alertmanager">Acceso y pruebas de Alertmanager</h4>
<div class="paragraph">
<p>Para acceder a la interfaz web de Alertmanager:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl port-forward svc/prometheus-kube-prometheus-alertmanager 9093:9093
# Luego abre http://localhost:9093 en tu navegador</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para probar una alerta, puedes forzar una condición o usar la API de Alertmanager para enviar alertas manualmente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_25">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Aquí hay algunas recomendaciones para configurar alertas efectivas en Kubernetes:</div>
<ul>
<li>
<p>Define alertas para condiciones críticas (caída de pods, uso excesivo de recursos, errores de aplicaciones, etc.).</p>
</li>
<li>
<p>Ajusta los umbrales y tiempos (<code>for:</code>) para evitar alertas falsas o ruido excesivo.</p>
</li>
<li>
<p>Usa etiquetas (<code>severity</code>, <code>team</code>, etc.) para clasificar y enrutar alertas según su importancia.</p>
</li>
<li>
<p>Silencia alertas durante mantenimientos programados para evitar notificaciones innecesarias.</p>
</li>
<li>
<p>Integra Alertmanager con los canales de comunicación de tu equipo (Slack, email, PagerDuty, etc.).</p>
</li>
<li>
<p>Documenta las alertas y su significado para facilitar la respuesta y el troubleshooting.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_11_helm_gestor_de_paquetes">Módulo 11: Helm: Gestor de Paquetes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Helm es el gestor de paquetes de facto para Kubernetes. Permite definir, instalar y actualizar aplicaciones complejas mediante "charts", que son plantillas reutilizables de recursos Kubernetes. Helm simplifica la gestión del ciclo de vida de aplicaciones, fomenta la reutilización y facilita la integración con pipelines de CI/CD.</p>
</div>
<div class="sect2">
<h3 id="_introducción_a_helm">Introducción a Helm</h3>
<div class="paragraph">
<p>Helm es el gestor de paquetes más utilizado en Kubernetes. Permite definir, instalar, actualizar y gestionar aplicaciones complejas mediante "charts", que son plantillas reutilizables de recursos Kubernetes. Helm simplifica la gestión del ciclo de vida de las aplicaciones, fomenta la reutilización y facilita la integración con pipelines de CI/CD.</p>
</div>
<div class="sect3">
<h4 id="_qué_es_un_chart_de_helm">¿Qué es un chart de Helm?</h4>
<div class="ulist">
<div class="title">Un <strong>chart</strong> es un paquete que contiene:</div>
<ul>
<li>
<p>Plantillas YAML parametrizables para recursos de Kubernetes (Deployments, Services, ConfigMaps, etc.).</p>
</li>
<li>
<p>Un archivo <code>values.yaml</code> con los valores por defecto y configurables.</p>
</li>
<li>
<p>Metadatos (<code>Chart.yaml</code>) y documentación opcional (<code>README.md</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Esto permite desplegar aplicaciones con diferentes configuraciones de forma sencilla y repetible.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ventajas_de_usar_helm">Ventajas de usar Helm</h4>
<div class="ulist">
<ul>
<li>
<p>Instalación y actualización sencilla de aplicaciones complejas.</p>
</li>
<li>
<p>Parametrización de despliegues mediante archivos de valores.</p>
</li>
<li>
<p>Gestión de dependencias entre aplicaciones.</p>
</li>
<li>
<p>Rollbacks automáticos en caso de errores.</p>
</li>
<li>
<p>Reutilización y compartición de charts a través de repositorios públicos o privados.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_instalación_de_helm">Instalación de Helm</h4>
<div class="paragraph">
<p>Puedes instalar Helm en tu máquina local con:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
# o usando un gestor de paquetes:
sudo apt-get install helm
brew install helm</code></pre>
</div>
</div>
<div class="paragraph">
<p>Verifica la instalación con:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm version</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_primeros_pasos_con_helm">Primeros pasos con Helm</h4>
<div class="listingblock">
<div class="title">1. Añade un repositorio de charts (por ejemplo, Bitnami):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo update</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">2. Busca un chart disponible:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm search repo bitnami/nginx</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">3. Instala una aplicación usando un chart:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm install mi-nginx bitnami/nginx</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">4. Lista los releases instalados:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm list</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">5. Actualiza la configuración de un release:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm upgrade mi-nginx bitnami/nginx --set service.type=LoadBalancer</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">6. Elimina un release:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm uninstall mi-nginx</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_estructura_básica_de_un_chart">Estructura básica de un chart</h4>
<div class="paragraph">
<p>Al crear un chart personalizado, la estructura típica es:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mi-chart/
  Chart.yaml
  values.yaml
  templates/
    deployment.yaml
    service.yaml
    ...</pre>
</div>
</div>
<div class="paragraph">
<p>Puedes crear un chart base con:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm create mi-chart</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto genera una plantilla lista para personalizar.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_26">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Algunas recomendaciones para trabajar con Helm y charts:</div>
<ul>
<li>
<p>Versiona tus charts y almacénalos en un repositorio (por ejemplo, Git).</p>
</li>
<li>
<p>Usa archivos <code>values.yaml</code> para separar la configuración del código.</p>
</li>
<li>
<p>Documenta los parámetros configurables en el README del chart.</p>
</li>
<li>
<p>Prueba los charts en entornos de desarrollo antes de usarlos en producción.</p>
</li>
<li>
<p>Automatiza despliegues y actualizaciones usando Helm en tus pipelines de CI/CD.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_charts_y_repositorios">Charts y repositorios</h3>
<div class="paragraph">
<p>En Helm, un <strong>chart</strong> es un paquete que contiene todos los recursos necesarios para desplegar una aplicación en Kubernetes. Los charts pueden ser reutilizados, versionados y compartidos a través de repositorios públicos o privados, facilitando la gestión y el despliegue de aplicaciones complejas.</p>
</div>
<div class="sect3">
<h4 id="_estructura_de_un_chart">Estructura de un chart</h4>
<div class="paragraph">
<p>Un chart típico tiene la siguiente estructura de directorios y archivos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mi-chart/
  Chart.yaml         # Metadatos del chart (nombre, versión, descripción)
  values.yaml        # Valores por defecto y configurables
  templates/         # Plantillas YAML de recursos Kubernetes (Deployment, Service, etc.)
    deployment.yaml
    service.yaml
    ...
  charts/            # Dependencias de otros charts (opcional)
  README.md          # Documentación del chart (opcional)</pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Chart.yaml</code>: Define el nombre, versión, descripción y dependencias del chart.</p>
</li>
<li>
<p><code>values.yaml</code>: Permite parametrizar el despliegue, facilitando la reutilización y personalización.</p>
</li>
<li>
<p><code>templates/</code>: Contiene los manifiestos de Kubernetes como plantillas Go, que se rellenan con los valores definidos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_repositorios_de_charts">Repositorios de charts</h4>
<div class="paragraph">
<p>Un <strong>repositorio de charts</strong> es una colección de charts accesibles mediante una URL. Existen repositorios públicos (como ArtifactHub, Bitnami, prometheus-community) y puedes crear repositorios privados para tu organización.</p>
</div>
<div class="listingblock">
<div class="title">Para añadir y listar repositorios:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm repo add bitnami https://charts.bitnami.com/bitnami
helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
helm repo list</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para buscar charts en los repositorios añadidos:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm search repo nginx</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para actualizar la lista de charts disponibles:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm repo update</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_instalación_de_aplicaciones_desde_un_repositorio">Instalación de aplicaciones desde un repositorio</h4>
<div class="paragraph">
<p>Puedes instalar cualquier chart disponible en un repositorio con un solo comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm install mi-release bitnami/nginx</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puedes personalizar la instalación usando el parámetro <code>--set</code> o un archivo de valores propio:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm install mi-release bitnami/nginx --set service.type=LoadBalancer
# o
helm install mi-release bitnami/nginx -f valores-personalizados.yaml</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_versionado_y_actualización_de_charts">Versionado y actualización de charts</h4>
<div class="paragraph">
<p>Cada chart y cada release tiene una versión. Puedes instalar una versión específica de un chart:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm install mi-release bitnami/nginx --version 15.0.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para actualizar una aplicación instalada:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm upgrade mi-release bitnami/nginx --set replicaCount=3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_creación_de_repositorios_privados">Creación de repositorios privados</h4>
<div class="paragraph">
<p>Puedes crear tu propio repositorio de charts usando un servidor web estático, GitHub Pages o herramientas como ChartMuseum.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo básico con ChartMuseum:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker run -d -p 8080:8080 \
  -v /ruta/a/mis/charts:/charts \
  chartmuseum/chartmuseum:latest \
  --storage-local-rootdir=/charts</code></pre>
</div>
</div>
<div class="paragraph">
<p>Luego añade tu repositorio privado a Helm:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm repo add mi-repo http://localhost:8080</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_27">Buenas prácticas</h4>
<div class="ulist">
<div class="title">A continuación, algunas recomendaciones para trabajar con Helm y repositorios de charts:</div>
<ul>
<li>
<p>Versiona y documenta todos tus charts.</p>
</li>
<li>
<p>Usa repositorios privados para aplicaciones internas o charts personalizados.</p>
</li>
<li>
<p>Actualiza regularmente los repositorios para obtener mejoras y parches de seguridad.</p>
</li>
<li>
<p>Revisa las dependencias y valores por defecto antes de instalar charts de terceros.</p>
</li>
<li>
<p>Automatiza la publicación de charts en tus pipelines de CI/CD.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creación_de_charts_personalizados">Creación de charts personalizados</h3>
<div class="paragraph">
<p>La creación de charts personalizados en Helm te permite empaquetar, versionar y reutilizar la configuración de tus aplicaciones para Kubernetes, facilitando despliegues consistentes y automatizados en diferentes entornos.</p>
</div>
<div class="sect3">
<h4 id="_estructura_básica_de_un_chart_2">Estructura básica de un chart</h4>
<div class="paragraph">
<p>Al crear un chart, Helm genera una estructura de directorios estándar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>mi-chart/
  Chart.yaml         # Metadatos del chart (nombre, versión, descripción)
  values.yaml        # Valores por defecto y configurables
  templates/         # Plantillas YAML de recursos Kubernetes
    deployment.yaml
    service.yaml
    ...
  charts/            # Dependencias de otros charts (opcional)
  README.md          # Documentación del chart (opcional)</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_creación_de_un_chart_desde_cero">Creación de un chart desde cero</h4>
<div class="paragraph">
<p>Puedes crear un nuevo chart con el comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm create mi-chart</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto genera una plantilla básica con ejemplos de Deployment, Service y otros recursos en el directorio <code>templates/</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_personalización_de_plantillas">Personalización de plantillas</h4>
<div class="paragraph">
<p>Las plantillas en el directorio <code>templates/</code> usan la sintaxis de Go templating, lo que permite parametrizar cualquier campo usando los valores definidos en <code>values.yaml</code>.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de fragmento de <code>deployment.yaml</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "mi-chart.fullname" . }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app: {{ include "mi-chart.name" . }}
  template:
    metadata:
      labels:
        app: {{ include "mi-chart.name" . }}
    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
          ports:
            - containerPort: {{ .Values.service.port }}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de <code>values.yaml</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">replicaCount: 2

image:
  repository: nginx
  tag: "1.25"

service:
  type: ClusterIP
  port: 80</code></pre>
</div>
</div>
<div class="paragraph">
<p>Puedes añadir o modificar parámetros según las necesidades de tu aplicación.</p>
</div>
</div>
<div class="sect3">
<h4 id="_instalación_y_prueba_del_chart_personalizado">Instalación y prueba del chart personalizado</h4>
<div class="paragraph">
<p>Para instalar tu chart en el clúster:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm install mi-release ./mi-chart</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para probar cambios en los valores:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm install mi-release ./mi-chart --set replicaCount=3,image.tag=1.26
# o usando un archivo de valores personalizado
helm install mi-release ./mi-chart -f valores-dev.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para actualizar el chart tras cambios:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm upgrade mi-release ./mi-chart</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_uso_de_helpers_y_funciones">Uso de helpers y funciones</h4>
<div class="paragraph">
<p>En el archivo <code>_helpers.tpl</code> puedes definir funciones reutilizables para nombres, etiquetas, anotaciones, etc., mejorando la consistencia y evitando duplicación.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de helper:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gotemplate hljs" data-lang="gotemplate">{{- define "mi-chart.fullname" -}}
{{ .Release.Name }}-{{ .Chart.Name }}
{{- end -}}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_28">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Para crear charts personalizados de calidad, sigue estas recomendaciones:</div>
<ul>
<li>
<p>Mantén los valores configurables en <code>values.yaml</code> y documenta cada parámetro.</p>
</li>
<li>
<p>Usa helpers para nombres y etiquetas consistentes.</p>
</li>
<li>
<p>Versiona y almacena tus charts en un repositorio (Git o ChartMuseum).</p>
</li>
<li>
<p>Añade pruebas de linting con <code>helm lint</code> y pruebas de despliegue en entornos de staging.</p>
</li>
<li>
<p>Documenta el uso y los parámetros en el <code>README.md</code> del chart.</p>
</li>
<li>
<p>Reutiliza plantillas y subcharts para componentes comunes.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_del_ciclo_de_vida_de_aplicaciones">Gestión del ciclo de vida de aplicaciones</h3>
<div class="paragraph">
<p>La gestión del ciclo de vida de aplicaciones en Kubernetes implica controlar todas las fases por las que pasa una aplicación: despliegue, actualización, escalado, monitorización, mantenimiento y eliminación. Kubernetes, junto con herramientas como Helm y sistemas de CI/CD, permite automatizar y simplificar estas tareas, asegurando despliegues consistentes, actualizaciones seguras y una operación eficiente.</p>
</div>
<div class="sect3">
<h4 id="_fases_del_ciclo_de_vida_de_una_aplicación_en_kubernetes">Fases del ciclo de vida de una aplicación en Kubernetes</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Despliegue inicial</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Se crea el manifiesto YAML o el chart de Helm con los recursos necesarios (Deployments, Services, ConfigMaps, etc.).</p>
</li>
<li>
<p>Se aplica al clúster usando <code>kubectl apply -f</code> o <code>helm install</code>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Actualización</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Se modifican los manifiestos o los valores de Helm para reflejar nuevas versiones, cambios de configuración o escalado.</p>
</li>
<li>
<p>Se aplican los cambios con <code>kubectl apply</code> o <code>helm upgrade</code>, aprovechando mecanismos como rolling updates para evitar downtime.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Escalado</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Se ajusta el número de réplicas manualmente (<code>kubectl scale</code>) o automáticamente mediante HPA/VPA.</p>
</li>
<li>
<p>Se puede escalar horizontalmente (más pods) o verticalmente (más recursos por pod).</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Monitorización y observabilidad</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Se recolectan métricas, logs y trazas usando Prometheus, Grafana, EFK/ELK, Jaeger, etc.</p>
</li>
<li>
<p>Se configuran alertas y dashboards para anticipar y detectar problemas.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Mantenimiento</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Se gestionan configuraciones y secretos de forma segura.</p>
</li>
<li>
<p>Se aplican parches de seguridad y actualizaciones de imágenes.</p>
</li>
<li>
<p>Se realiza limpieza de recursos obsoletos y ajuste de cuotas.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Rollback y recuperación</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Si una actualización falla, se puede hacer rollback a una versión anterior con <code>kubectl rollout undo</code> o <code>helm rollback</code>.</p>
</li>
<li>
<p>Se restauran backups de datos y configuraciones si es necesario.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Eliminación</strong>:</p>
<div class="ulist">
<ul>
<li>
<p>Se eliminan los recursos con <code>kubectl delete</code> o <code>helm uninstall</code>.</p>
</li>
<li>
<p>Se limpian volúmenes, configuraciones y otros artefactos asociados.</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_ciclo_de_vida_con_helm">Ejemplo de ciclo de vida con Helm</h4>
<div class="listingblock">
<div class="title">1. Despliegue inicial:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm install mi-app ./mi-chart</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">2. Actualización de la aplicación (por ejemplo, nueva imagen o configuración):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm upgrade mi-app ./mi-chart --set image.tag=2.0.0</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">3. Escalado manual:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl scale deployment mi-app --replicas=5</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">4. Rollback en caso de error:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm rollback mi-app 1</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">5. Eliminación de la aplicación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm uninstall mi-app</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_integración_con_cicd">Integración con CI/CD</h4>
<div class="paragraph">
<p>La gestión eficiente del ciclo de vida se potencia integrando Kubernetes con pipelines de CI/CD (por ejemplo, Jenkins, GitLab CI, GitHub Actions, ArgoCD, Flux):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Automatiza el build, test y despliegue de aplicaciones.</p>
</li>
<li>
<p>Aplica despliegues progresivos (canary, blue/green) y validaciones automáticas.</p>
</li>
<li>
<p>Realiza rollbacks automáticos ante fallos detectados en producción.</p>
</li>
<li>
<p>Versiona y audita todos los cambios en la infraestructura y la configuración.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de pipeline básico en GitLab CI:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">stages:
  - build
  - deploy

build:
  stage: build
  script:
    - docker build -t registry.example.com/mi-app:$CI_COMMIT_SHA .
    - docker push registry.example.com/mi-app:$CI_COMMIT_SHA

deploy:
  stage: deploy
  script:
    - helm upgrade --install mi-app ./mi-chart --set image.tag=$CI_COMMIT_SHA
  only:
    - main</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_29">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Formas de gestionar el ciclo de vida de aplicaciones en Kubernetes:</div>
<ul>
<li>
<p>Versiona todos los manifiestos y charts en un sistema de control de versiones (Git).</p>
</li>
<li>
<p>Automatiza despliegues y actualizaciones usando pipelines de CI/CD.</p>
</li>
<li>
<p>Usa estrategias de despliegue seguras (rolling update, canary, blue/green).</p>
</li>
<li>
<p>Supervisa el estado de las aplicaciones y configura alertas proactivas.</p>
</li>
<li>
<p>Documenta los procedimientos de despliegue, actualización y rollback.</p>
</li>
<li>
<p>Realiza pruebas de rollback y recuperación periódicamente.</p>
</li>
<li>
<p>Elimina recursos obsoletos para evitar consumo innecesario de recursos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_integraciones_con_cicd">Integraciones con CI/CD</h3>
<div class="paragraph">
<p>La integración de Kubernetes con sistemas de CI/CD (Integración Continua y Despliegue Continuo) es fundamental para automatizar el ciclo de vida de las aplicaciones, garantizar despliegues repetibles y reducir errores humanos. Las pipelines de CI/CD permiten construir, testear, empaquetar y desplegar aplicaciones en Kubernetes de forma automática tras cada cambio en el código fuente.</p>
</div>
<div class="sect3">
<h4 id="_beneficios_de_la_integración_cicd_con_kubernetes">Beneficios de la integración CI/CD con Kubernetes</h4>
<div class="ulist">
<ul>
<li>
<p>Automatización de builds, tests y despliegues.</p>
</li>
<li>
<p>Despliegues consistentes y repetibles en diferentes entornos.</p>
</li>
<li>
<p>Rollbacks automáticos ante fallos.</p>
</li>
<li>
<p>Validación de cambios antes de llegar a producción.</p>
</li>
<li>
<p>Auditoría y trazabilidad de todos los cambios.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_herramientas_populares_de_cicd_para_kubernetes">Herramientas populares de CI/CD para Kubernetes</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Jenkins</strong>: Ampliamente usado, con plugins para Kubernetes y Helm.</p>
</li>
<li>
<p><strong>GitLab CI/CD</strong>: Integración nativa con Kubernetes, despliegue automático de aplicaciones y entornos review.</p>
</li>
<li>
<p><strong>GitHub Actions</strong>: Workflows YAML para construir y desplegar en Kubernetes.</p>
</li>
<li>
<p><strong>ArgoCD</strong> y <strong>Flux</strong>: Herramientas GitOps para despliegue continuo basado en cambios en el repositorio Git.</p>
</li>
<li>
<p><strong>Tekton</strong>: Framework nativo de Kubernetes para pipelines declarativas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_pipeline_de_cicd_con_gitlab_ci">Ejemplo de pipeline de CI/CD con GitLab CI</h4>
<div class="listingblock">
<div class="title">Ejemplo básico de <code>.gitlab-ci.yml</code> para construir una imagen y desplegar con Helm:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">stages:
  - build
  - deploy

build:
  stage: build
  script:
    - docker build -t registry.example.com/mi-app:$CI_COMMIT_SHA .
    - docker push registry.example.com/mi-app:$CI_COMMIT_SHA

deploy:
  stage: deploy
  script:
    - helm upgrade --install mi-app ./chart --set image.tag=$CI_COMMIT_SHA
  only:
    - main</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_pipeline_con_github_actions">Ejemplo de pipeline con GitHub Actions</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">name: CI/CD

on:
  push:
    branches: [ "main" ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Docker image
        run: |
          docker build -t registry.example.com/mi-app:${{ github.sha }} .
          docker push registry.example.com/mi-app:${{ github.sha }}
      - name: Set up Kubeconfig
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.27.0'
      - name: Deploy with Helm
        run: |
          helm upgrade --install mi-app ./chart --set image.tag=${{ github.sha }}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gitops_despliegue_continuo_basado_en_git">GitOps: despliegue continuo basado en Git</h4>
<div class="paragraph">
<p>Con herramientas como <strong>ArgoCD</strong> o <strong>Flux</strong>, el estado deseado del clúster se define en un repositorio Git. Los cambios en el repositorio (manifiestos YAML, charts de Helm, etc.) son detectados y aplicados automáticamente al clúster.</p>
</div>
<div class="ulist">
<div class="title">Ventajas de GitOps:</div>
<ul>
<li>
<p>Auditoría y trazabilidad total de los cambios.</p>
</li>
<li>
<p>Rollbacks sencillos mediante revert en Git.</p>
</li>
<li>
<p>Sincronización automática entre Git y el clúster.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_30">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Aquí algunos consejos para integrar CI/CD con Kubernetes:</div>
<ul>
<li>
<p>Versiona todos los manifiestos y charts en el repositorio.</p>
</li>
<li>
<p>Usa entornos separados (dev, staging, prod) y pipelines independientes.</p>
</li>
<li>
<p>Automatiza pruebas antes del despliegue (lint, tests, validaciones de manifiestos).</p>
</li>
<li>
<p>Protege los secretos y credenciales usando herramientas como Sealed Secrets, HashiCorp Vault o Kubernetes Secrets cifrados.</p>
</li>
<li>
<p>Documenta el flujo de CI/CD y los procedimientos de rollback.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_12_operadores_de_kubernetes">Módulo 12: Operadores de Kubernetes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Los <strong>Operadores</strong> de Kubernetes son extensiones que automatizan la gestión de aplicaciones complejas y recursos personalizados dentro del clúster. Permiten encapsular el conocimiento operativo de un experto humano en software, facilitando tareas como despliegue, actualización, backup, escalado y recuperación de aplicaciones stateful o con lógica avanzada.</p>
</div>
<div class="sect2">
<h3 id="_concepto_de_operadores">Concepto de operadores</h3>
<div class="paragraph">
<p>Un <strong>operador</strong> de Kubernetes es una extensión que automatiza la gestión de aplicaciones complejas y recursos personalizados dentro del clúster. Los operadores encapsulan el conocimiento operativo de un experto humano en software, permitiendo que tareas como despliegue, actualización, backup, escalado y recuperación se realicen de forma automática y declarativa.</p>
</div>
<div class="sect3">
<h4 id="_cómo_funcionan_los_operadores">¿Cómo funcionan los operadores?</h4>
<div class="ulist">
<ul>
<li>
<p>Los operadores se basan en el patrón controlador de Kubernetes: observan el estado de recursos personalizados (CRDs, Custom Resource Definitions) y ejecutan acciones para mantener el estado deseado.</p>
</li>
<li>
<p>Un operador consta de:</p>
</li>
<li>
<p>Una o varias CRDs que definen nuevos tipos de recursos (por ejemplo, <code>PostgresCluster</code>, <code>KafkaTopic</code>).</p>
</li>
<li>
<p>Un controlador (controller) que observa estos recursos y ejecuta lógica personalizada (por ejemplo, crear pods, configurar backups, escalar instancias).</p>
</li>
<li>
<p>El operador compara el estado actual del clúster con el estado deseado definido en los recursos personalizados y realiza los cambios necesarios para reconciliarlos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ventajas_de_usar_operadores">Ventajas de usar operadores</h4>
<div class="ulist">
<ul>
<li>
<p>Automatización de tareas repetitivas y complejas.</p>
</li>
<li>
<p>Gestión declarativa de aplicaciones stateful y servicios avanzados.</p>
</li>
<li>
<p>Reducción de errores humanos y mejora de la consistencia operativa.</p>
</li>
<li>
<p>Integración nativa con el ciclo de vida de Kubernetes (aplicar, actualizar, eliminar).</p>
</li>
<li>
<p>Facilita la adopción de buenas prácticas y la estandarización de despliegues.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_uso_de_un_operador">Ejemplo de uso de un operador</h4>
<div class="paragraph">
<p>Supón que quieres gestionar una base de datos PostgreSQL de forma automatizada. Puedes instalar el <strong>Postgres Operator</strong> y crear un recurso personalizado como este:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: postgres-operator.crunchydata.com/v1beta1
kind: PostgresCluster
metadata:
  name: mi-postgres
spec:
  instances:
    - name: instancia1
      replicas: 2
  backups:
    pgbackrest:
      repos:
        - name: repo1
          volume:
            size: 10Gi</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador se encargará de crear los pods, servicios, backups y restauraciones según lo definido en el recurso <code>PostgresCluster</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_31">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Los operadores son herramientas útiles, pero deben usarse con cuidado:</div>
<ul>
<li>
<p>Usa operadores oficiales o de la comunidad para aplicaciones complejas (bases de datos, colas, sistemas distribuidos).</p>
</li>
<li>
<p>Versiona y documenta los recursos personalizados que definas.</p>
</li>
<li>
<p>Supervisa el estado de los operadores y revisa los logs ante problemas.</p>
</li>
<li>
<p>Limita los permisos de los operadores usando RBAC.</p>
</li>
<li>
<p>Prueba los operadores en entornos de desarrollo antes de usarlos en producción.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_operator_framework">Operator Framework</h3>
<div class="paragraph">
<p>El <strong>Operator Framework</strong> es un conjunto de herramientas y librerías open source diseñado para facilitar la creación, prueba y gestión de operadores en Kubernetes. Proporciona una base estandarizada para desarrollar operadores robustos, escalables y mantenibles, acelerando el ciclo de vida de desarrollo y simplificando la integración con el ecosistema Kubernetes.</p>
</div>
<div class="sect3">
<h4 id="_componentes_principales_del_operator_framework">Componentes principales del Operator Framework</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Operator SDK</strong>: Herramienta CLI y librerías para crear, construir y empaquetar operadores en Go, Ansible o Helm. Permite generar la estructura básica del proyecto, gestionar CRDs y escribir la lógica de reconciliación.</p>
</li>
<li>
<p><strong>Operator Lifecycle Manager (OLM)</strong>: Gestiona la instalación, actualización y ciclo de vida de los operadores en el clúster. Facilita la publicación y el consumo de operadores a través de catálogos.</p>
</li>
<li>
<p><strong>Operator Registry</strong>: Almacena y distribuye catálogos de operadores, permitiendo a OLM descubrir e instalar operadores desde diferentes fuentes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_por_qué_usar_operator_framework">¿Por qué usar Operator Framework?</h4>
<div class="ulist">
<ul>
<li>
<p>Estandariza el desarrollo y despliegue de operadores.</p>
</li>
<li>
<p>Reduce la complejidad al abstraer detalles de bajo nivel.</p>
</li>
<li>
<p>Permite elegir el lenguaje y enfoque más adecuado (Go, Ansible, Helm).</p>
</li>
<li>
<p>Facilita la integración con OLM para la gestión del ciclo de vida y dependencias.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_creación_de_un_operador_con_operator_sdk">Ejemplo de creación de un operador con Operator SDK</h4>
<div class="listingblock">
<div class="title">1. Instala Operator SDK:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">brew install operator-sdk
# o descarga desde https://github.com/operator-framework/operator-sdk</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">2. Crea un nuevo proyecto de operador en Go:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">operator-sdk init --domain=miempresa.com --repo=github.com/miempresa/mi-operator
operator-sdk create api --group=apps --version=v1alpha1 --kind=DemoApp --resource --controller</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">4. Genera y aplica la CRD:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">make install</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">5. Despliega el operador en el clúster:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">make deploy</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">6. Crea un recurso personalizado para probar el operador:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps.miempresa.com/v1alpha1
kind: DemoApp
metadata:
  name: demoapp-ejemplo
spec:
  replicas: 2</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_operator_lifecycle_manager_olm">Operator Lifecycle Manager (OLM)</h4>
<div class="paragraph">
<p>OLM facilita la instalación, actualización y gestión de operadores y sus dependencias en el clúster. Permite publicar operadores en catálogos y gestionar su ciclo de vida de forma declarativa.</p>
</div>
<div class="listingblock">
<div class="title">Para instalar OLM:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -f https://github.com/operator-framework/operator-lifecycle-manager/releases/latest/download/install.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>Luego puedes instalar operadores desde catálogos públicos (como OperatorHub.io) o privados.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_32">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Las siguientes recomendaciones te ayudarán a crear y gestionar operadores de forma efectiva:</div>
<ul>
<li>
<p>Usa Operator SDK para acelerar el desarrollo y seguir las mejores prácticas.</p>
</li>
<li>
<p>Documenta las CRDs y la lógica de reconciliación.</p>
</li>
<li>
<p>Prueba los operadores en entornos de staging antes de producción.</p>
</li>
<li>
<p>Usa OLM para gestionar el ciclo de vida y actualizaciones de los operadores.</p>
</li>
<li>
<p>Limita los permisos de los operadores mediante RBAC.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_casos_de_uso_y_ejemplos_comunes">Casos de uso y ejemplos comunes</h3>
<div class="paragraph">
<p>Los operadores de Kubernetes se utilizan para automatizar la gestión de aplicaciones y recursos complejos que requieren lógica operativa avanzada. A continuación se presentan algunos de los casos de uso más habituales y ejemplos prácticos:</p>
</div>
<div class="sect3">
<h4 id="_1_gestión_automatizada_de_bases_de_datos">1. Gestión automatizada de bases de datos</h4>
<div class="paragraph">
<p>Operadores como el <strong>Postgres Operator</strong>, <strong>MongoDB Operator</strong> o <strong>MySQL Operator</strong> permiten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Desplegar instancias de bases de datos de forma declarativa.</p>
</li>
<li>
<p>Gestionar backups automáticos y restauraciones.</p>
</li>
<li>
<p>Realizar actualizaciones y escalado sin intervención manual.</p>
</li>
<li>
<p>Configurar alta disponibilidad y replicación.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de recurso personalizado para PostgreSQL:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: postgres-operator.crunchydata.com/v1beta1
kind: PostgresCluster
metadata:
  name: mi-postgres
spec:
  instances:
    - name: instancia1
      replicas: 2
  backups:
    pgbackrest:
      repos:
        - name: repo1
          volume:
            size: 10Gi</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_2_automatización_de_sistemas_de_mensajería_y_colas">2. Automatización de sistemas de mensajería y colas</h4>
<div class="paragraph">
<p>Operadores como <strong>Kafka Operator</strong> o <strong>RabbitMQ Cluster Operator</strong> permiten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Crear y escalar clústeres de mensajería.</p>
</li>
<li>
<p>Gestionar topics, usuarios y políticas de acceso.</p>
</li>
<li>
<p>Automatizar actualizaciones y recuperación ante fallos.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de recurso para Kafka:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: kafka.strimzi.io/v1beta2
kind: Kafka
metadata:
  name: mi-kafka
spec:
  kafka:
    replicas: 3
    listeners:
      - name: plain
        port: 9092
        type: internal
        tls: false
  zookeeper:
    replicas: 3
  entityOperator:
    topicOperator: {}
    userOperator: {}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_3_aplicaciones_stateful_y_almacenamiento">3. Aplicaciones stateful y almacenamiento</h4>
<div class="paragraph">
<p>Operadores como <strong>Cassandra Operator</strong>, <strong>Elasticsearch Operator</strong> o <strong>Redis Operator</strong> facilitan:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Despliegue y escalado de clústeres stateful.</p>
</li>
<li>
<p>Gestión de nodos, sharding y replicación.</p>
</li>
<li>
<p>Automatización de backups y restauraciones.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_4_automatización_de_certificados_y_seguridad">4. Automatización de certificados y seguridad</h4>
<div class="paragraph">
<p>El <strong>cert-manager</strong> Operator automatiza la provisión y renovación de certificados TLS usando ACME (Let&#8217;s Encrypt) u otros proveedores.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de recurso Certificate:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: mi-certificado
spec:
  secretName: mi-cert-tls
  dnsNames:
    - miapp.ejemplo.com
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_5_integración_con_servicios_cloud_y_saas">5. Integración con servicios cloud y SaaS</h4>
<div class="paragraph">
<p>Operadores como <strong>AWS Service Operator</strong> o <strong>Azure Service Operator</strong> permiten gestionar recursos cloud (RDS, S3, CosmosDB, etc.) directamente desde Kubernetes, usando manifiestos YAML.</p>
</div>
</div>
<div class="sect3">
<h4 id="_6_ejemplo_básico_operador_personalizado_para_reinicio_de_pods">6. Ejemplo básico: operador personalizado para reinicio de pods</h4>
<div class="paragraph">
<p>Un operador sencillo puede observar un recurso personalizado (por ejemplo, <code>RestartPod</code>) y reiniciar un pod cuando se crea dicho recurso.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de CRD:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: myorg.com/v1
kind: RestartPod
metadata:
  name: reiniciar-mi-pod
spec:
  podName: mi-pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador implementa la lógica para detectar este recurso y ejecutar <code>kubectl delete pod mi-pod</code> automáticamente.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_33">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Para trabajar con operadores de forma efectiva, considera las siguientes recomendaciones:</div>
<ul>
<li>
<p>Usa operadores oficiales o de la comunidad para aplicaciones críticas.</p>
</li>
<li>
<p>Versiona y documenta los recursos personalizados y su uso.</p>
</li>
<li>
<p>Supervisa el estado y logs de los operadores.</p>
</li>
<li>
<p>Limita los permisos de los operadores mediante RBAC.</p>
</li>
<li>
<p>Prueba los operadores en entornos de desarrollo antes de producción.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creación_de_operadores_básicos">Creación de operadores básicos</h3>
<div class="paragraph">
<p>Crear un operador básico en Kubernetes implica definir un recurso personalizado (CRD) y un controlador que observe y gestione ese recurso. Los operadores pueden desarrollarse en varios lenguajes y frameworks, pero el Operator SDK es la opción más popular y sencilla para empezar.</p>
</div>
<div class="sect3">
<h4 id="_pasos_para_crear_un_operador_básico_con_operator_sdk">Pasos para crear un operador básico con Operator SDK</h4>
<div class="listingblock">
<div class="title">1. Instala Operator SDK:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">brew install operator-sdk
# o descarga desde https://github.com/operator-framework/operator-sdk</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">2. Inicializa un nuevo proyecto de operador (en Go, Ansible o Helm; aquí usamos Go):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">operator-sdk init --domain=miempresa.com --repo=github.com/miempresa/mi-operator</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">3. Crea una API y un controlador para tu recurso personalizado:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">operator-sdk create api --group=apps --version=v1alpha1 --kind=DemoApp --resource --controller</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto genera la definición de la CRD y la estructura del controlador.</p>
</div>
<div class="listingblock">
<div class="title">5. Genera y aplica la CRD en el clúster:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">make install</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">6. Despliega el operador en el clúster:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">make deploy</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">7. Crea un recurso personalizado para probar el operador:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apps.miempresa.com/v1alpha1
kind: DemoApp
metadata:
  name: demoapp-ejemplo
spec:
  replicas: 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador observará este recurso y ejecutará la lógica definida (por ejemplo, crear un Deployment con 2 réplicas).</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_mínimo_de_crd_y_lógica_de_reconciliación">Ejemplo mínimo de CRD y lógica de reconciliación</h4>
<div class="listingblock">
<div class="title">CRD (<code>config/crd/bases/apps.miempresa.com_demoapps.yaml</code>):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: demoapps.apps.miempresa.com
spec:
  group: apps.miempresa.com
  versions:
    - name: v1alpha1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                replicas:
                  type: integer
  scope: Namespaced
  names:
    plural: demoapps
    singular: demoapp
    kind: DemoApp
    shortNames:
      - da</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Lógica de reconciliación (Go, fragmento simplificado):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-go hljs" data-lang="go">// controllers/demoapp_controller.go
func (r *DemoAppReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
    var demoApp appsv1alpha1.DemoApp
    if err := r.Get(ctx, req.NamespacedName, &amp;demoApp); err != nil {
        return ctrl.Result{}, client.IgnoreNotFound(err)
    }
    // Crear o actualizar un Deployment según el spec.replicas
    // ...
    return ctrl.Result{}, nil
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_34">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Si quieres crear un operador básico, considera las siguientes recomendaciones:</div>
<ul>
<li>
<p>Empieza con un operador sencillo y ve añadiendo lógica según las necesidades.</p>
</li>
<li>
<p>Documenta la CRD y el comportamiento esperado del operador.</p>
</li>
<li>
<p>Usa pruebas unitarias y de integración para validar la lógica.</p>
</li>
<li>
<p>Limita los permisos del operador mediante RBAC.</p>
</li>
<li>
<p>Supervisa los logs y el estado del operador en el clúster.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_automatización_de_tareas_complejas">Automatización de tareas complejas</h3>
<div class="paragraph">
<p>Los operadores de Kubernetes permiten automatizar tareas operativas avanzadas que tradicionalmente requerían intervención manual o scripts externos. Gracias a su capacidad para observar el estado del clúster y ejecutar lógica personalizada, los operadores pueden gestionar procesos complejos de forma declarativa y repetible.</p>
</div>
<div class="sect3">
<h4 id="_ejemplos_de_automatización_con_operadores">Ejemplos de automatización con operadores</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Backups y restauraciones automáticas</strong>: Operadores de bases de datos (Postgres, MongoDB, MySQL) pueden programar y ejecutar backups periódicos, así como restauraciones automáticas ante fallos.</p>
</li>
<li>
<p><strong>Actualizaciones y migraciones sin downtime</strong>: Operadores pueden gestionar actualizaciones de versiones de aplicaciones o bases de datos, aplicando migraciones de esquema y validando el estado antes y después del cambio.</p>
</li>
<li>
<p><strong>Escalado avanzado y auto-recuperación</strong>: Operadores pueden implementar lógica de escalado basada en métricas personalizadas, o reiniciar/reemplazar recursos ante fallos detectados.</p>
</li>
<li>
<p><strong>Rotación y provisión de certificados</strong>: Operadores como cert-manager automatizan la solicitud, renovación y distribución de certificados TLS para aplicaciones y servicios.</p>
</li>
<li>
<p><strong>Gestión de dependencias entre recursos</strong>: Operadores pueden orquestar la creación y configuración de recursos dependientes (por ejemplo, crear un PVC antes de desplegar una base de datos, o esperar a que un servicio esté disponible antes de lanzar una aplicación).</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_backup_automático_con_un_operador_de_base_de_datos">Ejemplo: backup automático con un operador de base de datos</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: postgres-operator.crunchydata.com/v1beta1
kind: PostgresCluster
metadata:
  name: mi-postgres
spec:
  backups:
    pgbackrest:
      repos:
        - name: repo1
          schedule: "0 2 * * *" # Backup diario a las 2 AM
          volume:
            size: 10Gi</code></pre>
</div>
</div>
<div class="paragraph">
<p>El operador se encarga de ejecutar el backup según la programación definida y gestionar la retención y restauración de los datos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_rotación_automática_de_certificados_con_cert_manager">Ejemplo: rotación automática de certificados con cert-manager</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: mi-certificado
spec:
  secretName: mi-cert-tls
  dnsNames:
    - miapp.ejemplo.com
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer</code></pre>
</div>
</div>
<div class="paragraph">
<p>cert-manager solicitará, renovará y almacenará automáticamente el certificado TLS en el Secret especificado.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_35">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Las siguientes recomendaciones te ayudarán a automatizar tareas complejas con operadores de forma efectiva:</div>
<ul>
<li>
<p>Define claramente los flujos de automatización y documenta los recursos personalizados utilizados.</p>
</li>
<li>
<p>Supervisa el estado y los logs de los operadores para detectar errores o comportamientos inesperados.</p>
</li>
<li>
<p>Limita los permisos de los operadores mediante RBAC para reducir riesgos de seguridad.</p>
</li>
<li>
<p>Prueba exhaustivamente la lógica de automatización en entornos de desarrollo antes de aplicarla en producción.</p>
</li>
<li>
<p>Mantén los operadores y sus dependencias actualizados para aprovechar mejoras y parches de seguridad.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_13_cicd_con_kubernetes">Módulo 13: CI/CD con Kubernetes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La integración de CI/CD (Integración Continua y Despliegue Continuo) con Kubernetes es esencial para automatizar el ciclo de vida de las aplicaciones, garantizar despliegues repetibles y acelerar la entrega de valor. Este módulo aborda las mejores prácticas, herramientas y patrones para implementar pipelines de CI/CD modernos sobre Kubernetes.</p>
</div>
<div class="sect2">
<h3 id="_pipelines_de_cicd_para_kubernetes">Pipelines de CI/CD para Kubernetes</h3>
<div class="paragraph">
<p>Los pipelines de CI/CD (Integración Continua y Despliegue Continuo) son fundamentales para automatizar la construcción, prueba y despliegue de aplicaciones en Kubernetes. Permiten entregar cambios de forma rápida, segura y repetible, reduciendo errores humanos y acelerando la entrega de valor.</p>
</div>
<div class="sect3">
<h4 id="_cómo_funciona_un_pipeline_de_cicd_para_kubernetes">¿Cómo funciona un pipeline de CI/CD para Kubernetes?</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Build</strong>: El código fuente se construye y se empaqueta en una imagen de contenedor.</p>
</li>
<li>
<p><strong>Test</strong>: Se ejecutan pruebas unitarias, de integración y de seguridad sobre la imagen.</p>
</li>
<li>
<p><strong>Push</strong>: La imagen se sube a un registro de contenedores (Docker Hub, GitLab Registry, ECR, etc.).</p>
</li>
<li>
<p><strong>Deploy</strong>: Se actualizan los manifiestos YAML o charts de Helm y se despliega la nueva versión en el clúster Kubernetes.</p>
</li>
<li>
<p><strong>Validación</strong>: Se realizan pruebas post-despliegue y validaciones automáticas.</p>
</li>
<li>
<p><strong>Rollback</strong>: Si se detectan errores, el pipeline puede revertir automáticamente a la versión anterior.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_herramientas_populares_para_pipelines_de_cicd_en_kubernetes">Herramientas populares para pipelines de CI/CD en Kubernetes</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Jenkins</strong>: Con plugins para Kubernetes y Helm.</p>
</li>
<li>
<p><strong>GitLab CI/CD</strong>: Integración nativa con clústeres Kubernetes y despliegue automático.</p>
</li>
<li>
<p><strong>GitHub Actions</strong>: Workflows YAML para construir y desplegar en Kubernetes.</p>
</li>
<li>
<p><strong>Tekton</strong>: Framework nativo de Kubernetes para pipelines declarativas.</p>
</li>
<li>
<p><strong>Argo Workflows</strong>: Pipelines nativos para Kubernetes, ideales para flujos complejos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_básico_de_pipeline_con_gitlab_ci">Ejemplo básico de pipeline con GitLab CI</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">stages:
  - build
  - deploy

build:
  stage: build
  script:
    - docker build -t registry.example.com/mi-app:$CI_COMMIT_SHA .
    - docker push registry.example.com/mi-app:$CI_COMMIT_SHA

deploy:
  stage: deploy
  script:
    - helm upgrade --install mi-app ./chart --set image.tag=$CI_COMMIT_SHA
  only:
    - main</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_básico_de_pipeline_con_github_actions">Ejemplo básico de pipeline con GitHub Actions</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">name: CI/CD

on:
  push:
    branches: [ "main" ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build Docker image
        run: |
          docker build -t registry.example.com/mi-app:${{ github.sha }} .
          docker push registry.example.com/mi-app:${{ github.sha }}
      - name: Set up Kubeconfig
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.27.0'
      - name: Deploy with Helm
        run: |
          helm upgrade --install mi-app ./chart --set image.tag=${{ github.sha }}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_36">Buenas prácticas</h4>
<div class="paragraph">
<p>En la implementación de pipelines de CI/CD para Kubernetes, considera las siguientes recomendaciones:
.Mejores prácticas para CI/CD:
- Versiona todos los manifiestos y charts en el repositorio.
- Usa pipelines independientes para cada entorno (dev, staging, prod).
- Automatiza pruebas antes del despliegue (lint, tests, validaciones de manifiestos).
- Protege los secretos y credenciales usando herramientas como Sealed Secrets, HashiCorp Vault o Kubernetes Secrets cifrados.
- Documenta el flujo de CI/CD y los procedimientos de rollback.
- Supervisa y audita los despliegues y cambios aplicados.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gitops_con_argocdflux">GitOps con ArgoCD/Flux</h3>
<div class="paragraph">
<p><strong>GitOps</strong> es un enfoque de gestión de infraestructura y aplicaciones donde el estado deseado del clúster se define y versiona en un repositorio Git. Herramientas como <strong>ArgoCD</strong> y <strong>Flux</strong> sincronizan automáticamente los cambios en el repositorio con el clúster Kubernetes, permitiendo despliegues automáticos, auditables y reversibles.</p>
</div>
<div class="sect3">
<h4 id="_cómo_funciona_gitops">¿Cómo funciona GitOps?</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>El estado deseado (manifiestos YAML, charts de Helm, Kustomize, etc.) se almacena en un repositorio Git.</p>
</li>
<li>
<p>ArgoCD o Flux monitorizan el repositorio y aplican los cambios detectados al clúster.</p>
</li>
<li>
<p>Si el estado real del clúster difiere del definido en Git, la herramienta lo reconcilia automáticamente.</p>
</li>
<li>
<p>Los rollbacks se realizan simplemente revirtiendo cambios en Git.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_ventajas_de_gitops">Ventajas de GitOps</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Auditoría y trazabilidad total</strong>: Todo cambio queda registrado en el historial de Git.</p>
</li>
<li>
<p><strong>Despliegues automáticos y consistentes</strong>: El clúster siempre refleja el estado definido en Git.</p>
</li>
<li>
<p><strong>Rollbacks sencillos</strong>: Basta con revertir un commit para volver a un estado anterior.</p>
</li>
<li>
<p><strong>Separación de responsabilidades</strong>: Los equipos de desarrollo y operaciones pueden colaborar usando flujos de trabajo Git estándar.</p>
</li>
<li>
<p><strong>Automatización y seguridad</strong>: Menos intervención manual y mejor control de cambios.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_flujo_gitops_con_argocd">Ejemplo de flujo GitOps con ArgoCD</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Instala ArgoCD en el clúster:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml</code></pre>
</div>
</div>
</li>
<li>
<p>Accede a la interfaz web de ArgoCD:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl port-forward svc/argocd-server -n argocd 8080:443
# Luego abre http://localhost:8080</code></pre>
</div>
</div>
</li>
<li>
<p>Crea una aplicación ArgoCD que apunte a tu repositorio Git:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: mi-app
  namespace: argocd
spec:
  project: default
  source:
    repoURL: 'https://github.com/mi-org/mi-repo-k8s'
    targetRevision: main
    path: charts/mi-app
  destination:
    server: 'https://kubernetes.default.svc'
    namespace: produccion
  syncPolicy:
    automated:
      prune: true
      selfHeal: true</code></pre>
</div>
</div>
</li>
<li>
<p>ArgoCD sincroniza automáticamente el estado del clúster con el repositorio Git.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_flujo_gitops_con_flux">Ejemplo de flujo GitOps con Flux</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Instala Flux usando el CLI:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">curl -s https://fluxcd.io/install.sh | sudo bash
flux install</code></pre>
</div>
</div>
</li>
<li>
<p>Conecta Flux a tu repositorio Git:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">flux create source git mi-repo \
  --url=https://github.com/mi-org/mi-repo-k8s \
  --branch=main</code></pre>
</div>
</div>
</li>
<li>
<p>Aplica los recursos definidos en el repositorio:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">flux create kustomization mi-app \
  --source=mi-repo \
  --path="./k8s/mi-app" \
  --prune=true \
  --interval=1m</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_37">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Para implementar GitOps de forma efectiva, considera las siguientes recomendaciones:</div>
<ul>
<li>
<p>Versiona todos los manifiestos y charts en Git.</p>
</li>
<li>
<p>Usa ramas y pull requests para gestionar cambios y revisiones.</p>
</li>
<li>
<p>Protege el acceso al repositorio y usa revisiones de código.</p>
</li>
<li>
<p>Documenta el flujo de trabajo GitOps y los procedimientos de rollback.</p>
</li>
<li>
<p>Supervisa el estado de sincronización y los logs de ArgoCD/Flux.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estrategias_de_despliegue_bluegreen_canary">Estrategias de despliegue (blue/green, canary)</h3>
<div class="paragraph">
<p>Las estrategias de despliegue avanzadas permiten minimizar riesgos y validar nuevas versiones de aplicaciones en Kubernetes de forma progresiva y controlada. Las más comunes son <strong>blue/green</strong> y <strong>canary</strong>, y pueden implementarse combinando Deployments, Services, Ingress y, en escenarios avanzados, Service Mesh.</p>
</div>
<div class="sect3">
<h4 id="_bluegreen_deployment_2">Blue/Green Deployment</h4>
<div class="paragraph">
<p>Consiste en tener dos entornos idénticos: uno activo (blue) y otro inactivo (green). El entorno green se actualiza con la nueva versión y, tras las pruebas, el tráfico se redirige completamente del entorno blue al green.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de implementación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Deployment Blue (versión actual)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-blue
spec:
  replicas: 3
  selector:
    matchLabels:
      app: webapp
      version: blue
  template:
    metadata:
      labels:
        app: webapp
        version: blue
    spec:
      containers:
        - name: webapp
          image: mi-app:v1</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Deployment Green (nueva versión)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-green
spec:
  replicas: 3
  selector:
    matchLabels:
      app: webapp
      version: green
  template:
    metadata:
      labels:
        app: webapp
        version: green
    spec:
      containers:
        - name: webapp
          image: mi-app:v2</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Service apuntando a la versión activa
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
spec:
  selector:
    app: webapp
    version: blue # Cambia a 'green' para hacer el switch
  ports:
    - port: 80
      targetPort: 80</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_canary_deployment_2">Canary Deployment</h4>
<div class="paragraph">
<div class="title">Para cambiar el tráfico a la nueva versión, solo actualiza el selector del Service a <code>version: green</code>.</div>
<p>Permite liberar la nueva versión a un pequeño porcentaje de usuarios/pods y, si no hay problemas, aumentar progresivamente el tráfico.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de implementación:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Deployment estable (90% del tráfico)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-stable
spec:
  replicas: 9
  selector:
    matchLabels:
      app: webapp
      track: stable
  template:
    metadata:
      labels:
        app: webapp
        track: stable
    spec:
      containers:
        - name: webapp
          image: mi-app:v1</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Deployment canary (10% del tráfico)
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-canary
spec:
  replicas: 1
  selector:
    matchLabels:
      app: webapp
      track: canary
  template:
    metadata:
      labels:
        app: webapp
        track: canary
    spec:
      containers:
        - name: webapp
          image: mi-app:v2</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml"># Service balanceando entre ambas versiones
apiVersion: v1
kind: Service
metadata:
  name: webapp-service
spec:
  selector:
    app: webapp
  ports:
    - port: 80
      targetPort: 80</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ab_testing_2">A/B Testing</h4>
<div class="paragraph">
<div class="title">Para un control más granular (por ejemplo, por porcentaje real de tráfico HTTP), utiliza un Ingress Controller avanzado (NGINX, Traefik) o un Service Mesh como Istio.</div>
<p>Similar al canary, pero el enrutamiento se basa en características del usuario, cabeceras HTTP, cookies, etc. Requiere un Ingress Controller avanzado o Service Mesh.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de regla de Ingress para A/B Testing con NGINX:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ab-ingress
  annotations:
    nginx.ingress.kubernetes.io/canary: "true"
    nginx.ingress.kubernetes.io/canary-by-header: "X-User-Type"
    nginx.ingress.kubernetes.io/canary-by-header-value: "beta"
spec:
  rules:
    - host: miapp.ejemplo.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: webapp-canary
                port:
                  number: 80</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_38">Buenas prácticas</h4>
<div class="paragraph">
<div class="title">Los usuarios que envíen la cabecera <code>X-User-Type: beta</code> serán dirigidos a la versión canary.</div>
<p>Con las estrategias de despliegue, considera las siguientes recomendaciones:
.Recomendaciones para estrategias:
- Automatiza los despliegues y cambios de tráfico usando herramientas de CI/CD.
- Supervisa métricas y logs durante el despliegue para detectar problemas rápidamente.
- Define criterios claros de rollback y monitorea la experiencia del usuario.
- Documenta cada estrategia y los pasos para revertir cambios si es necesario.</p>
</div>
</div>
<div class="sect3">
<h4 id="_resumen_gráfico_7">Resumen gráfico</h4>
<div class="imageblock">
<div class="content">
<img src="advanced-deploy-strategies.png" alt="advanced deploy strategies" width="222" height="404">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_integración_con_herramientas_populares">Integración con herramientas populares</h3>
<div class="paragraph">
<p>Kubernetes y sus pipelines de CI/CD se integran fácilmente con una amplia variedad de herramientas del ecosistema cloud-native, permitiendo automatizar, asegurar y optimizar todo el ciclo de vida de las aplicaciones.</p>
</div>
<div class="sect3">
<h4 id="_herramientas_de_integración_más_utilizadas">Herramientas de integración más utilizadas</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Helm</strong>: Para empaquetar, versionar y desplegar aplicaciones complejas mediante charts reutilizables.</p>
</li>
<li>
<p><strong>Kustomize</strong>: Para gestionar overlays y personalizaciones de manifiestos YAML sin duplicar archivos.</p>
</li>
<li>
<p><strong>Prometheus &amp; Grafana</strong>: Monitorización y visualización de métricas del clúster y las aplicaciones.</p>
</li>
<li>
<p><strong>EFK/ELK (Elasticsearch, Fluentd, Kibana)</strong>: Logging centralizado y análisis de logs.</p>
</li>
<li>
<p><strong>Jaeger/Zipkin</strong>: Trazabilidad distribuida para microservicios.</p>
</li>
<li>
<p><strong>SonarQube</strong>: Análisis de calidad y seguridad del código en pipelines de CI.</p>
</li>
<li>
<p><strong>Trivy, Snyk, Grype</strong>: Escaneo de vulnerabilidades en imágenes de contenedor.</p>
</li>
<li>
<p><strong>Sealed Secrets, HashiCorp Vault</strong>: Gestión segura de secretos y credenciales en pipelines y clústeres.</p>
</li>
<li>
<p><strong>ArgoCD, Flux</strong>: GitOps para despliegue continuo y sincronización automática desde Git.</p>
</li>
<li>
<p><strong>Tekton, Argo Workflows</strong>: Pipelines nativos y flujos de trabajo declarativos en Kubernetes.</p>
</li>
<li>
<p><strong>Service Mesh (Istio, Linkerd)</strong>: Gestión avanzada del tráfico, seguridad y observabilidad entre microservicios.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_integración_en_un_pipeline_de_cicd">Ejemplo de integración en un pipeline de CI/CD</h4>
<div class="ulist">
<div class="title">Un pipeline típico puede incluir:</div>
<ul>
<li>
<p>Build y push de imagen Docker.</p>
</li>
<li>
<p>Escaneo de vulnerabilidades con Trivy.</p>
</li>
<li>
<p>Análisis de código con SonarQube.</p>
</li>
<li>
<p>Despliegue con Helm o Kustomize.</p>
</li>
<li>
<p>Sincronización GitOps con ArgoCD o Flux.</p>
</li>
<li>
<p>Notificaciones a Slack o email en caso de éxito o fallo.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de pasos en un pipeline (GitLab CI):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">stages:
  - build
  - scan
  - test
  - deploy

build:
  stage: build
  script:
    - docker build -t registry.example.com/mi-app:$CI_COMMIT_SHA .
    - docker push registry.example.com/mi-app:$CI_COMMIT_SHA

scan:
  stage: scan
  image: aquasec/trivy:latest
  script:
    - trivy image registry.example.com/mi-app:$CI_COMMIT_SHA

test:
  stage: test
  script:
    - sonar-scanner

deploy:
  stage: deploy
  script:
    - helm upgrade --install mi-app ./chart --set image.tag=$CI_COMMIT_SHA</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_39">Buenas prácticas</h4>
<div class="paragraph">
<p>Para integrar herramientas en tus pipelines de CI/CD, considera las siguientes recomendaciones:
.Integración de herramientas:
- Integra herramientas de análisis y seguridad en todas las etapas del pipeline.
- Usa Helm o Kustomize para gestionar la configuración y el despliegue.
- Centraliza logs y métricas para facilitar el troubleshooting.
- Protege los secretos y credenciales usando soluciones especializadas.
- Automatiza notificaciones y alertas para mantener informado al equipo.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_automatización_de_pruebas_y_despliegues">Automatización de pruebas y despliegues</h3>
<div class="paragraph">
<p>La automatización de pruebas y despliegues es un pilar fundamental en la entrega continua de aplicaciones sobre Kubernetes. Permite validar cambios de forma temprana, reducir errores humanos y acelerar la entrega de nuevas funcionalidades a producción.</p>
</div>
<div class="sect3">
<h4 id="_fases_típicas_de_automatización">Fases típicas de automatización</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Construcción de la imagen</strong>: El código fuente se construye y empaqueta en una imagen de contenedor.</p>
</li>
<li>
<p><strong>Pruebas automáticas</strong>: Se ejecutan pruebas unitarias, de integración, de seguridad y de calidad de código.</p>
</li>
<li>
<p><strong>Escaneo de vulnerabilidades</strong>: Se analiza la imagen con herramientas como Trivy o Snyk.</p>
</li>
<li>
<p><strong>Despliegue automatizado</strong>: Se actualizan los manifiestos o charts de Helm y se despliega la nueva versión en el clúster.</p>
</li>
<li>
<p><strong>Pruebas post-despliegue</strong>: Se validan endpoints, health checks y se ejecutan pruebas end-to-end.</p>
</li>
<li>
<p><strong>Rollback automático</strong>: Si se detectan fallos, el pipeline revierte a la versión anterior.</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_pipeline_automatizado_gitlab_ci">Ejemplo de pipeline automatizado (GitLab CI)</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">stages:
  - build
  - test
  - scan
  - deploy
  - post-deploy

build:
  stage: build
  script:
    - docker build -t registry.example.com/mi-app:$CI_COMMIT_SHA .
    - docker push registry.example.com/mi-app:$CI_COMMIT_SHA

test:
  stage: test
  script:
    - pytest tests/

scan:
  stage: scan
  image: aquasec/trivy:latest
  script:
    - trivy image registry.example.com/mi-app:$CI_COMMIT_SHA

deploy:
  stage: deploy
  script:
    - helm upgrade --install mi-app ./chart --set image.tag=$CI_COMMIT_SHA

post-deploy:
  stage: post-deploy
  script:
    - curl --fail http://mi-app.svc.cluster.local/health
    - pytest tests_e2e/</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_herramientas_recomendadas">Herramientas recomendadas</h4>
<div class="ulist">
<ul>
<li>
<p><strong>pytest, JUnit, Mocha</strong>: Para pruebas unitarias e integración.</p>
</li>
<li>
<p><strong>Trivy, Snyk, Grype</strong>: Para escaneo de vulnerabilidades en imágenes.</p>
</li>
<li>
<p><strong>Helm, Kustomize</strong>: Para despliegue automatizado.</p>
</li>
<li>
<p><strong>Argo Rollouts, Flagger</strong>: Para despliegues progresivos y validación automática.</p>
</li>
<li>
<p><strong>SonarQube</strong>: Para análisis de calidad de código.</p>
</li>
<li>
<p><strong>K6, Locust</strong>: Para pruebas de carga y rendimiento.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_40">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Automatización efectiva:</div>
<ul>
<li>
<p>Automatiza todas las pruebas posibles antes y después del despliegue.</p>
</li>
<li>
<p>Falla el pipeline si se detectan vulnerabilidades críticas o pruebas fallidas.</p>
</li>
<li>
<p>Usa entornos efímeros (review apps) para validar cambios antes de fusionar a main.</p>
</li>
<li>
<p>Versiona y documenta los scripts y manifiestos de pruebas y despliegue.</p>
</li>
<li>
<p>Integra notificaciones automáticas para informar al equipo de los resultados.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_14_kubernetes_en_producción">Módulo 14: Kubernetes en Producción</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Este módulo aborda cómo desplegar, gestionar y mantener aplicaciones en entornos de Kubernetes de producción, incluyendo buenas prácticas, configuraciones recomendadas y estrategias para la administración eficiente de clústeres.</p>
</div>
<div class="sect2">
<h3 id="_arquitecturas_multi_cluster">Arquitecturas multi-cluster</h3>
<div class="paragraph">
<p>Las arquitecturas multi-cluster son una estrategia avanzada en la administración de contenedores y orquestadores como Kubernetes. Permiten desplegar y gestionar múltiples clústeres de forma coordinada, lo que aporta ventajas en términos de alta disponibilidad, resiliencia, escalabilidad y cumplimiento de normativas.</p>
</div>
<div class="sect3">
<h4 id="_qué_es_un_clúster">¿Qué es un clúster?</h4>
<div class="paragraph">
<p>Un clúster es un conjunto de nodos (máquinas físicas o virtuales) que trabajan juntos para ejecutar aplicaciones y servicios de manera orquestada. En Kubernetes, un clúster está compuesto por un nodo maestro (control plane) y varios nodos de trabajo (workers).</p>
</div>
</div>
<div class="sect3">
<h4 id="_por_qué_usar_una_arquitectura_multi_cluster">¿Por qué usar una arquitectura multi-cluster?</h4>
<div class="paragraph">
<p>Las arquitecturas multi-cluster se utilizan para:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mejorar la disponibilidad y tolerancia a fallos, distribuyendo cargas entre diferentes clústeres.</p>
</li>
<li>
<p>Cumplir requisitos legales o de soberanía de datos, desplegando clústeres en distintas regiones o países.</p>
</li>
<li>
<p>Facilitar la migración y actualización de aplicaciones sin afectar la disponibilidad.</p>
</li>
<li>
<p>Optimizar el uso de recursos y la escalabilidad horizontal.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_escenarios_multi_cluster">Ejemplo de escenarios multi-cluster</h4>
<div class="paragraph">
<p><strong>Alta disponibilidad geográfica</strong>: Empresas globales pueden desplegar clústeres en diferentes regiones (por ejemplo, Europa y América) para asegurar que los usuarios accedan al clúster más cercano.</p>
</div>
<div class="paragraph">
<p><strong>Entornos de desarrollo y producción aislados</strong>: Se pueden tener clústeres separados para desarrollo, pruebas y producción, evitando interferencias y mejorando la seguridad.</p>
</div>
</div>
<div class="sect3">
<h4 id="_herramientas_para_gestionar_arquitecturas_multi_cluster">Herramientas para gestionar arquitecturas multi-cluster</h4>
<div class="ulist">
<ul>
<li>
<p><code>kubefed</code>: Permite federar múltiples clústeres de Kubernetes, gestionando recursos de manera centralizada.</p>
</li>
<li>
<p><code>Rancher</code>: Plataforma de gestión de múltiples clústeres Kubernetes con interfaz gráfica.</p>
</li>
<li>
<p><code>Google Anthos</code>, <code>Azure Arc</code>, <code>Amazon EKS Anywhere</code>: Soluciones de nube híbrida para administrar clústeres en diferentes entornos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_configuración_multi_cluster_con_kubeconfig">Ejemplo de configuración multi-cluster con kubeconfig</h4>
<div class="paragraph">
<p>Para interactuar con varios clústeres desde la misma máquina, se puede configurar el archivo <code>~/.kube/config</code> con múltiples contextos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Config
clusters:
- name: cluster-europa
  cluster:
    server: https://europa.example.com
    certificate-authority: /path/to/ca.crt
- name: cluster-america
  cluster:
    server: https://america.example.com
    certificate-authority: /path/to/ca.crt
users:
- name: usuario-europa
  user:
    client-certificate: /path/to/europa.crt
    client-key: /path/to/europa.key
- name: usuario-america
  user:
    client-certificate: /path/to/america.crt
    client-key: /path/to/america.key
contexts:
- name: europa-context
  context:
    cluster: cluster-europa
    user: usuario-europa
- name: america-context
  context:
    cluster: cluster-america
    user: usuario-america
current-context: europa-context</code></pre>
</div>
</div>
<div class="paragraph">
<p>Con este archivo, puedes cambiar de clúster fácilmente usando el comando:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl config use-context america-context</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_despliegue_federado_con_kubefed">Ejemplo de despliegue federado con KubeFed</h4>
<div class="paragraph">
<p>KubeFed permite desplegar recursos en varios clústeres federados. Un ejemplo de manifiesto federado sería:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: types.kubefed.io/v1beta1
kind: FederatedDeployment
metadata:
  name: nginx
  namespace: default
spec:
  template:
    spec:
      replicas: 2
      selector:
        matchLabels:
          app: nginx
      template:
        metadata:
          labels:
            app: nginx
        spec:
          containers:
          - name: nginx
            image: nginx:latest</code></pre>
</div>
</div>
<div class="paragraph">
<p>Este recurso se replicará en todos los clústeres federados.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ventajas_y_retos_de_las_arquitecturas_multi_cluster">Ventajas y retos de las arquitecturas multi-cluster</h4>
<div class="ulist">
<div class="title"><strong>Ventajas</strong>:</div>
<ul>
<li>
<p>Alta disponibilidad y tolerancia a fallos.</p>
</li>
<li>
<p>Cumplimiento de normativas y soberanía de datos.</p>
</li>
<li>
<p>Escalabilidad global.</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title"><strong>Retos</strong>:</div>
<ul>
<li>
<p>Complejidad en la gestión y monitoreo.</p>
</li>
<li>
<p>Sincronización de configuraciones y políticas.</p>
</li>
<li>
<p>Seguridad y control de acceso entre clústeres.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_gestión_de_certificados_y_tls">Gestión de certificados y TLS</h3>
<div class="paragraph">
<p>La gestión de certificados y TLS (Transport Layer Security) es fundamental para garantizar la seguridad en la comunicación entre servicios, usuarios y aplicaciones dentro de entornos de contenedores y orquestadores como Kubernetes o Docker. TLS proporciona confidencialidad, integridad y autenticación en las conexiones de red.</p>
</div>
<div class="sect3">
<h4 id="_conceptos_básicos_de_tls_y_certificados">Conceptos básicos de TLS y certificados</h4>
<div class="paragraph">
<p>TLS es un protocolo criptográfico que protege los datos transmitidos entre dos puntos. Para establecer una conexión segura, se utilizan certificados digitales, que son archivos que contienen una clave pública y la identidad del propietario, firmados por una Autoridad Certificadora (CA).</p>
</div>
<div class="ulist">
<div class="title">Un certificado típico incluye:</div>
<ul>
<li>
<p>Clave pública</p>
</li>
<li>
<p>Información del propietario (CN, organización, etc.)</p>
</li>
<li>
<p>Firma digital de la CA</p>
</li>
<li>
<p>Fecha de validez</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_generación_de_certificados_autofirmados">Generación de certificados autofirmados</h4>
<div class="paragraph">
<p>Para entornos de desarrollo o pruebas, es común generar certificados autofirmados. Esto se puede hacer con <code>openssl</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  -keyout mi_certificado.key -out mi_certificado.crt \
  -subj "/CN=miapp.local/O=MiEmpresa"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto genera un certificado (<code>mi_certificado.crt</code>) y una clave privada (<code>mi_certificado.key</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="_uso_de_certificados_en_docker">Uso de certificados en Docker</h4>
<div class="paragraph">
<p>Docker permite proteger el daemon y las conexiones entre clientes y servidores usando TLS. Para habilitar TLS en Docker, se deben proporcionar los certificados al iniciar el daemon:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">dockerd --tlsverify \
  --tlscacert=ca.pem \
  --tlscert=server-cert.pem \
  --tlskey=server-key.pem \
  -H=0.0.0.0:2376</code></pre>
</div>
</div>
<div class="paragraph">
<p>El cliente Docker también debe usar los certificados para conectarse de forma segura:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker --tlsverify \
  --tlscacert=ca.pem \
  --tlscert=cert.pem \
  --tlskey=key.pem \
  -H=hostname:2376 info</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_de_certificados_en_kubernetes_con_cert_manager">Gestión de certificados en Kubernetes con cert-manager</h4>
<div class="paragraph">
<p>En Kubernetes, la gestión de certificados puede automatizarse usando <code>cert-manager</code>, un controlador que emite y renueva certificados automáticamente, integrándose con ACME (Let&#8217;s Encrypt) u otras CAs.</p>
</div>
<div class="paragraph">
<p>Ejemplo de manifiesto para instalar cert-manager usando Helm:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm repo add jetstack https://charts.jetstack.io
helm repo update
helm install cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --set installCRDs=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ejemplo de recurso <code>Certificate</code> para solicitar un certificado TLS:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: mi-certificado-tls
  namespace: default
spec:
  secretName: mi-certificado-tls
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer
  commonName: miapp.example.com
  dnsNames:
    - miapp.example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>El certificado generado se almacena como un secreto de Kubernetes (<code>mi-certificado-tls</code>), que puede ser usado en un Ingress para habilitar HTTPS:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: miapp-ingress
  annotations:
    kubernetes.io/ingress.class: nginx
spec:
  tls:
    - hosts:
        - miapp.example.com
      secretName: mi-certificado-tls
  rules:
    - host: miapp.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: miapp-service
                port:
                  number: 80</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_renovación_y_revocación_de_certificados">Renovación y revocación de certificados</h4>
<div class="paragraph">
<p>La renovación automática es esencial para evitar interrupciones. <code>cert-manager</code> gestiona la renovación antes de que caduquen los certificados. Para revocar un certificado, se debe notificar a la CA y actualizar los recursos afectados.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_en_la_gestión_de_certificados">Buenas prácticas en la gestión de certificados</h4>
<div class="ulist">
<div class="title">Gestión segura de certificados:</div>
<ul>
<li>
<p>Usar certificados de una CA confiable en producción.</p>
</li>
<li>
<p>Proteger las claves privadas y restringir su acceso.</p>
</li>
<li>
<p>Automatizar la emisión y renovación de certificados.</p>
</li>
<li>
<p>Monitorizar la caducidad de los certificados.</p>
</li>
<li>
<p>Rotar certificados y claves periódicamente.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_estrategias_de_backups_y_recuperación">Estrategias de backups y recuperación</h3>
<div class="paragraph">
<p>La protección de los datos y la capacidad de restaurarlos ante fallos, errores humanos o ataques es esencial en cualquier infraestructura moderna, especialmente en entornos de contenedores y orquestadores como Docker y Kubernetes. Las estrategias de backup y recuperación permiten garantizar la continuidad del negocio y minimizar la pérdida de información.</p>
</div>
<div class="sect3">
<h4 id="_principios_básicos_de_backup_y_recuperación">Principios básicos de backup y recuperación</h4>
<div class="paragraph">
<p>Un backup es una copia de los datos o configuraciones críticas que se almacena en un lugar seguro para poder restaurarla en caso de pérdida o corrupción. La recuperación (restore) es el proceso de devolver los datos a su estado original a partir de una copia de seguridad.</p>
</div>
<div class="ulist">
<div class="title">Consideraciones estratégicas:</div>
<ul>
<li>
<p>Qué datos respaldar (volúmenes, bases de datos, configuraciones, manifiestos).</p>
</li>
<li>
<p>Frecuencia de los backups (diaria, semanal, incremental, diferencial).</p>
</li>
<li>
<p>Dónde almacenar los backups (local, remoto, nube).</p>
</li>
<li>
<p>Cómo automatizar y verificar los backups.</p>
</li>
<li>
<p>Procedimientos claros de restauración y pruebas periódicas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_estrategias_de_backup_en_docker">Estrategias de backup en Docker</h4>
<div class="paragraph">
<p>En Docker, los datos suelen almacenarse en volúmenes. Para respaldar un volumen, se puede usar el comando <code>docker cp</code> o crear un contenedor temporal que acceda al volumen y copie los datos.</p>
</div>
<div class="paragraph">
<p>Ejemplo de backup de un volumen llamado <code>mi_volumen</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker run --rm \
  -v mi_volumen:/datos \
  -v $(pwd):/backup \
  busybox \
  tar czf /backup/backup_mi_volumen.tar.gz -C /datos .</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para restaurar el backup:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker run --rm \
  -v mi_volumen:/datos \
  -v $(pwd):/backup \
  busybox \
  tar xzf /backup/backup_mi_volumen.tar.gz -C /datos</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_estrategias_de_backup_en_kubernetes">Estrategias de backup en Kubernetes</h4>
<div class="paragraph">
<p>En Kubernetes, además de los volúmenes persistentes (PV/PVC), es importante respaldar los recursos del clúster (manifiestos, secretos, configuraciones).</p>
</div>
<div class="paragraph">
<p>Herramientas populares:
.Herramientas recomendadas para backup:
- <code>Velero</code>: Solución open source para backup y recuperación de clústeres Kubernetes.
- <code>Kasten K10</code>, <code>Stash</code>, <code>TrilioVault</code>: Otras soluciones comerciales y open source.</p>
</div>
<div class="paragraph">
<p>Ejemplo de backup de recursos del clúster con Velero:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">velero install --provider aws --bucket mi-bucket-backup --secret-file ./credentials-velero
velero backup create backup-diario --include-namespaces mi-namespace</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para restaurar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">velero restore create --from-backup backup-diario</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ejemplo de backup de un volumen persistente con Velero:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">velero backup create backup-volumen --include-resources persistentvolumes,persistentvolumeclaims</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_backup_de_bases_de_datos_en_contenedores">Backup de bases de datos en contenedores</h4>
<div class="paragraph">
<p>Las bases de datos requieren estrategias específicas, ya que suelen estar en uso constante. Es recomendable usar herramientas propias de cada base de datos para realizar backups consistentes.</p>
</div>
<div class="paragraph">
<p>Ejemplo de backup de una base de datos MySQL en un contenedor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker exec mi-mysql-container \
  mysqldump -u usuario -pcontraseña basededatos &gt; backup_basededatos.sql</code></pre>
</div>
</div>
<div class="paragraph">
<p>Para restaurar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker exec -i mi-mysql-container \
  mysql -u usuario -pcontraseña basededatos &lt; backup_basededatos.sql</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_automatización_y_almacenamiento_seguro">Automatización y almacenamiento seguro</h4>
<div class="paragraph">
<p>Automatizar los backups es fundamental. Se pueden usar cron jobs en el host o dentro de contenedores para ejecutar los comandos de backup periódicamente.</p>
</div>
<div class="paragraph">
<p>Ejemplo de cron job en Linux para backup diario:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-cron hljs" data-lang="cron">0 2 * * * docker run --rm -v mi_volumen:/datos -v /backups:/backup busybox tar czf /backup/backup_$(date +\%F).tar.gz -C /datos .</code></pre>
</div>
</div>
<div class="paragraph">
<p>Almacenar los backups en ubicaciones seguras y redundantes (por ejemplo, en la nube usando S3, Azure Blob o Google Cloud Storage) es una buena práctica para evitar pérdidas por fallos locales.</p>
</div>
</div>
<div class="sect3">
<h4 id="_pruebas_de_recuperación">Pruebas de recuperación</h4>
<div class="paragraph">
<p>No basta con hacer backups; es imprescindible probar periódicamente la restauración para asegurar que los datos pueden recuperarse correctamente y que los procedimientos funcionan.</p>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_41">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Implementación efectiva:</div>
<ul>
<li>
<p>Documentar los procedimientos de backup y recuperación.</p>
</li>
<li>
<p>Automatizar y monitorizar los procesos.</p>
</li>
<li>
<p>Proteger los backups con cifrado y control de acceso.</p>
</li>
<li>
<p>Realizar pruebas de restauración regularmente.</p>
</li>
<li>
<p>Mantener varias copias y versiones de los backups.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_optimización_de_recursos_y_costes">Optimización de recursos y costes</h3>
<div class="paragraph">
<p>La optimización de recursos y costes es un aspecto clave en la administración de infraestructuras basadas en contenedores y orquestadores como Docker y Kubernetes. Una gestión eficiente permite reducir gastos operativos, mejorar el rendimiento y aprovechar al máximo la capacidad disponible, evitando el desperdicio de recursos y el sobredimensionamiento.</p>
</div>
<div class="sect3">
<h4 id="_principios_de_optimización">Principios de optimización</h4>
<div class="paragraph">
<p>Optimizar recursos implica ajustar el uso de CPU, memoria, almacenamiento y red para que las aplicaciones funcionen correctamente sin consumir más de lo necesario. Esto se traduce en menores costes de infraestructura, especialmente en entornos cloud donde se paga por uso.</p>
</div>
<div class="ulist">
<div class="title">Los principios básicos incluyen:</div>
<ul>
<li>
<p>Dimensionar correctamente los recursos asignados a cada servicio o contenedor.</p>
</li>
<li>
<p>Escalar dinámicamente según la demanda.</p>
</li>
<li>
<p>Automatizar la gestión de recursos.</p>
</li>
<li>
<p>Monitorizar y analizar el uso real para detectar ineficiencias.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_optimización_en_docker">Optimización en Docker</h4>
<div class="paragraph">
<p>En Docker, se pueden limitar los recursos que consume cada contenedor usando opciones al ejecutar los contenedores:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker run --name miapp \
  --memory="512m" \
  --cpus="1.0" \
  miimagen:latest</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto limita el contenedor a 512 MB de RAM y 1 CPU. Así se evita que un contenedor consuma todos los recursos del host.</p>
</div>
<div class="paragraph">
<p>Para ver el uso de recursos de los contenedores en tiempo real:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker stats</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_optimización_en_kubernetes">Optimización en Kubernetes</h4>
<div class="paragraph">
<p>Kubernetes ofrece mecanismos avanzados para gestionar y optimizar recursos a nivel de clúster.</p>
</div>
<div class="sect4">
<h5 id="_requests_y_limits">Requests y Limits</h5>
<div class="listingblock">
<div class="title">En los manifiestos de pods y deployments, se pueden definir requests (recursos mínimos garantizados) y limits (máximos permitidos):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
kind: Pod
metadata:
  name: miapp
spec:
  containers:
    - name: miapp
      image: miimagen:latest
      resources:
        requests:
          memory: "256Mi"
          cpu: "250m"
        limits:
          memory: "512Mi"
          cpu: "500m"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto ayuda a que el scheduler de Kubernetes distribuya los pods de manera eficiente y evita el sobreconsumo.</p>
</div>
</div>
<div class="sect4">
<h5 id="_autoscaling">Autoscaling</h5>
<div class="listingblock">
<div class="title">Kubernetes permite escalar automáticamente los pods según la carga, usando el Horizontal Pod Autoscaler (HPA):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl autoscale deployment miapp --cpu-percent=50 --min=2 --max=10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto ajusta el número de réplicas de acuerdo al uso de CPU.</p>
</div>
</div>
<div class="sect4">
<h5 id="_node_autoscaling">Node Autoscaling</h5>
<div class="paragraph">
<p>En entornos cloud, se puede habilitar el escalado automático de nodos (Cluster Autoscaler), que añade o elimina nodos según la demanda, optimizando costes.</p>
</div>
</div>
<div class="sect4">
<h5 id="_monitorización_y_análisis">Monitorización y análisis</h5>
<div class="paragraph">
<p>Herramientas como Prometheus, Grafana y Kubernetes Metrics Server permiten monitorizar el uso de recursos y detectar cuellos de botella o recursos infrautilizados.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de consulta PromQL para ver el uso de CPU por pod:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-promql hljs" data-lang="promql">sum(rate(container_cpu_usage_seconds_total{image!=""}[5m])) by (pod)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_optimización_de_almacenamiento">Optimización de almacenamiento</h4>
<div class="ulist">
<div class="title">Algunas recomendaciones para optimizar el uso de almacenamiento en Kubernetes son:</div>
<ul>
<li>
<p>Usar volúmenes persistentes adecuados al perfil de uso (rápidos para bases de datos, económicos para backups).</p>
</li>
<li>
<p>Eliminar volúmenes y datos huérfanos.</p>
</li>
<li>
<p>Comprimir y deduplicar datos cuando sea posible.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_optimización_de_red">Optimización de red</h4>
<div class="ulist">
<div class="title">Los siguientes consejos te ayudarán a optimizar el uso de red en Kubernetes:</div>
<ul>
<li>
<p>Configurar políticas de red para evitar tráfico innecesario.</p>
</li>
<li>
<p>Usar servicios internos (ClusterIP) en lugar de exponer servicios externos si no es necesario.</p>
</li>
<li>
<p>Monitorizar el tráfico para detectar anomalías o sobrecostes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_optimización_de_costes_en_la_nube">Optimización de costes en la nube</h4>
<div class="ulist">
<div class="title">Para optimizar costes en entornos cloud, considera:</div>
<ul>
<li>
<p>Elegir instancias adecuadas al perfil de carga.</p>
</li>
<li>
<p>Usar instancias reservadas o spot/preemptibles para cargas no críticas.</p>
</li>
<li>
<p>Apagar entornos de desarrollo fuera del horario laboral.</p>
</li>
<li>
<p>Automatizar el escalado y la eliminación de recursos no utilizados.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_42">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Para optimizar recursos y costes, considera las siguientes recomendaciones:</div>
<ul>
<li>
<p>Revisar periódicamente el uso de recursos y ajustar configuraciones.</p>
</li>
<li>
<p>Automatizar el escalado y la limpieza de recursos.</p>
</li>
<li>
<p>Monitorizar y alertar sobre consumos anómalos.</p>
</li>
<li>
<p>Fomentar la cultura de eficiencia entre los equipos de desarrollo y operaciones.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_troubleshooting_y_resolución_de_problemas">Troubleshooting y resolución de problemas</h3>
<div class="paragraph">
<p>El troubleshooting o resolución de problemas es una habilidad esencial para mantener la estabilidad y disponibilidad de aplicaciones y servicios en entornos de contenedores como Docker y Kubernetes. Consiste en identificar, diagnosticar y solucionar incidencias que afectan al funcionamiento esperado de los sistemas.</p>
</div>
<div class="sect3">
<h4 id="_principios_del_troubleshooting">Principios del troubleshooting</h4>
<div class="ulist">
<div class="title">Un enfoque sistemático ayuda a resolver problemas de manera eficiente:</div>
<ul>
<li>
<p>Recopilar información relevante (logs, métricas, eventos).</p>
</li>
<li>
<p>Reproducir el problema si es posible.</p>
</li>
<li>
<p>Aislar el alcance (afecta a un contenedor, pod, nodo, red, almacenamiento, etc.).</p>
</li>
<li>
<p>Formular hipótesis y probar soluciones.</p>
</li>
<li>
<p>Documentar el proceso y la solución aplicada.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_troubleshooting_en_docker">Troubleshooting en Docker</h4>
<div class="sect4">
<h5 id="_inspección_de_contenedores">Inspección de contenedores</h5>
<div class="listingblock">
<div class="title">Para obtener información detallada sobre un contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker inspect mi_contenedor</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_visualización_de_logs">Visualización de logs</h5>
<div class="listingblock">
<div class="title">Para ver los logs de un contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker logs mi_contenedor</code></pre>
</div>
</div>
<div class="paragraph">
<p>Agregar <code>-f</code> para seguir los logs en tiempo real.</p>
</div>
</div>
<div class="sect4">
<h5 id="_estado_de_los_contenedores">Estado de los contenedores</h5>
<div class="listingblock">
<div class="title">Para ver el estado de todos los contenedores:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker ps -a</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_acceso_a_un_contenedor_en_ejecución">Acceso a un contenedor en ejecución</h5>
<div class="listingblock">
<div class="title">Para abrir una shell dentro de un contenedor:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker exec -it mi_contenedor /bin/sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto permite inspeccionar archivos, procesos y configuraciones desde dentro.</p>
</div>
</div>
<div class="sect4">
<h5 id="_ejemplo_de_troubleshooting">Ejemplo de troubleshooting</h5>
<div class="listingblock">
<div class="title">Si un contenedor se detiene inesperadamente, puedes ver el motivo con:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker inspect --format='{{.State.ExitCode}}' mi_contenedor
docker logs mi_contenedor</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_troubleshooting_en_kubernetes">Troubleshooting en Kubernetes</h4>
<div class="sect4">
<h5 id="_estado_de_los_pods">Estado de los pods</h5>
<div class="listingblock">
<div class="title">Para ver el estado de los pods en un namespace:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get pods -n mi-namespace</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para obtener detalles de un pod específico:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl describe pod mi-pod -n mi-namespace</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto muestra eventos, razones de fallos y condiciones del pod.</p>
</div>
</div>
<div class="sect4">
<h5 id="_logs_de_pods">Logs de pods</h5>
<div class="listingblock">
<div class="title">Para ver los logs de un pod:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl logs mi-pod -n mi-namespace</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Si el pod tiene varios contenedores:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl logs mi-pod -c nombre-contenedor -n mi-namespace</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_acceso_interactivo_a_un_pod">Acceso interactivo a un pod</h5>
<div class="listingblock">
<div class="title">Para abrir una shell dentro de un contenedor en un pod:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl exec -it mi-pod -- /bin/sh</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_eventos_del_clúster">Eventos del clúster</h5>
<div class="listingblock">
<div class="title">Para ver eventos recientes que pueden indicar problemas:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get events -n mi-namespace --sort-by=.metadata.creationTimestamp</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_ejemplo_de_troubleshooting_2">Ejemplo de troubleshooting</h5>
<div class="listingblock">
<div class="title">Si un pod está en estado <code>CrashLoopBackOff</code>, puedes investigar con:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl describe pod mi-pod
kubectl logs mi-pod</code></pre>
</div>
</div>
<div class="paragraph">
<p>Busca errores de configuración, variables de entorno faltantes o problemas de conectividad.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_troubleshooting_de_red">Troubleshooting de red</h4>
<div class="ulist">
<div class="title">Para problemas de red en Kubernetes:</div>
<ul>
<li>
<p>Verifica la conectividad entre pods usando herramientas como <code>ping</code> o <code>curl</code> desde dentro de los contenedores.</p>
</li>
<li>
<p>Revisa las políticas de red (<code>NetworkPolicy</code>) que puedan estar bloqueando el tráfico.</p>
</li>
<li>
<p>Usa utilidades como <code>kubectl port-forward</code> para exponer servicios temporalmente y probar accesos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_troubleshooting_de_almacenamiento">Troubleshooting de almacenamiento</h4>
<div class="ulist">
<div class="title">Para problemas de almacenamiento:</div>
<ul>
<li>
<p>Verifica el estado de los volúmenes persistentes (PV/PVC) con <code>kubectl get pv,pvc</code>.</p>
</li>
<li>
<p>Revisa los eventos y logs relacionados con el almacenamiento.</p>
</li>
<li>
<p>Asegúrate de que los permisos y rutas de montaje sean correctos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_herramientas_útiles">Herramientas útiles</h4>
<div class="ulist">
<div class="title">Para facilitar el troubleshooting, considera usar herramientas como:</div>
<ul>
<li>
<p><code>docker-compose logs</code> para aplicaciones multi-contenedor.</p>
</li>
<li>
<p><code>stern</code> o <code>kubetail</code> para ver logs de múltiples pods en Kubernetes.</p>
</li>
<li>
<p><code>kubectl top</code> para monitorizar recursos en tiempo real.</p>
</li>
<li>
<p>Dashboards como Grafana y Kibana para análisis de métricas y logs.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_43">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Las siguientes recomendaciones te ayudarán a mejorar el proceso de troubleshooting:</div>
<ul>
<li>
<p>Automatizar la recolección de logs y métricas.</p>
</li>
<li>
<p>Documentar los problemas y soluciones encontradas.</p>
</li>
<li>
<p>Mantener procedimientos de troubleshooting actualizados.</p>
</li>
<li>
<p>Capacitar al equipo en el uso de herramientas de diagnóstico.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_15_extensiones_y_ecosistema">Módulo 15: Extensiones y Ecosistema</h2>
<div class="sectionbody">
<div class="paragraph">
<p>El ecosistema de contenedores y orquestadores como Docker y Kubernetes se ha expandido enormemente gracias a la comunidad y a la disponibilidad de extensiones, plugins y herramientas complementarias. Estas extensiones permiten ampliar funcionalidades, integrar nuevas capacidades y facilitar la administración, seguridad, monitorización y automatización de los entornos de contenedores.</p>
</div>
<div class="sect2">
<h3 id="_custom_resource_definitions_crds">Custom Resource Definitions (CRDs)</h3>
<div class="paragraph">
<p>Las Custom Resource Definitions (CRDs) son una de las principales formas de extender la funcionalidad nativa de Kubernetes, permitiendo a los usuarios definir y gestionar recursos personalizados que se comportan como los recursos estándar del clúster (Pods, Services, Deployments, etc.).</p>
</div>
<div class="sect3">
<h4 id="_qué_es_una_crd">¿Qué es una CRD?</h4>
<div class="paragraph">
<p>Una CRD es un recurso de Kubernetes que permite registrar un nuevo tipo de objeto en la API del clúster. Una vez creada, los usuarios pueden crear, leer, actualizar y eliminar instancias de ese recurso personalizado usando las mismas herramientas y flujos que para los recursos nativos.</p>
</div>
<div class="paragraph">
<p>Esto habilita la creación de operadores y controladores que gestionan el ciclo de vida de aplicaciones complejas o integraciones específicas.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_básico_de_crd">Ejemplo básico de CRD</h4>
<div class="listingblock">
<div class="title">A continuación, se muestra un ejemplo de definición de una CRD llamada <code>CronTab</code>, que permite crear recursos personalizados para programar tareas:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  name: crontabs.stable.example.com
spec:
  group: stable.example.com
  versions:
    - name: v1
      served: true
      storage: true
      schema:
        openAPIV3Schema:
          type: object
          properties:
            spec:
              type: object
              properties:
                cronSpec:
                  type: string
                image:
                  type: string
                replicas:
                  type: integer
  scope: Namespaced
  names:
    plural: crontabs
    singular: crontab
    kind: CronTab
    shortNames:
      - ct</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Una vez aplicada esta CRD, puedes crear recursos del tipo <code>CronTab</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: stable.example.com/v1
kind: CronTab
metadata:
  name: ejemplo-crontab
spec:
  cronSpec: "* * * * */5"
  image: my-cron-image
  replicas: 1</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ventajas_de_usar_crds">Ventajas de usar CRDs</h4>
<div class="ulist">
<div class="title">Las CRDs ofrecen varias ventajas:</div>
<ul>
<li>
<p>Permiten modelar recursos y flujos de trabajo específicos de la organización.</p>
</li>
<li>
<p>Facilitan la automatización avanzada mediante operadores.</p>
</li>
<li>
<p>Integran recursos personalizados en el ciclo de vida y la API de Kubernetes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_operadores_y_crds">Operadores y CRDs</h4>
<div class="paragraph">
<p>Los operadores son controladores que gestionan recursos personalizados definidos por CRDs. Por ejemplo, un operador puede observar instancias de <code>CronTab</code> y crear o eliminar pods según la programación definida.</p>
</div>
<div class="paragraph">
<p>Herramientas como Operator SDK y Kubebuilder facilitan la creación de operadores y CRDs.</p>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_y_actualización_de_crds">Gestión y actualización de CRDs</h4>
<div class="paragraph">
<p>Las CRDs pueden evolucionar con nuevas versiones de la API. Es importante definir correctamente los esquemas y validar los datos para evitar inconsistencias.</p>
</div>
<div class="listingblock">
<div class="title">Para listar todas las CRDs instaladas en un clúster:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get crds</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Para eliminar una CRD (y todos sus recursos asociados):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl delete crd crontabs.stable.example.com</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_44">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Al trabajar con CRDs, considera las siguientes recomendaciones:</div>
<ul>
<li>
<p>Definir esquemas claros y validar los datos con OpenAPI v3.</p>
</li>
<li>
<p>Versionar las CRDs para facilitar la evolución y compatibilidad.</p>
</li>
<li>
<p>Documentar el uso y los campos de los recursos personalizados.</p>
</li>
<li>
<p>Proteger el acceso a los recursos personalizados mediante RBAC.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_api_aggregation">API Aggregation</h3>
<div class="paragraph">
<p>La API Aggregation es una característica avanzada de Kubernetes que permite extender la API nativa del clúster integrando APIs externas como si fueran parte del propio servidor de Kubernetes. Esto facilita la incorporación de nuevos servicios y recursos personalizados sin modificar el código fuente del API server principal.</p>
</div>
<div class="sect3">
<h4 id="_qué_es_api_aggregation">¿Qué es API Aggregation?</h4>
<div class="paragraph">
<p>API Aggregation consiste en desplegar un servidor de API externo (llamado Aggregated API Server) que implementa nuevos recursos o funcionalidades. Este servidor se registra en el API server principal de Kubernetes, que actúa como proxy y enruta las solicitudes a la API agregada. Así, los usuarios pueden interactuar con los nuevos recursos usando las mismas herramientas (<code>kubectl</code>, API REST) y mecanismos de autenticación/autorización que para los recursos nativos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_diferencias_entre_crds_y_api_aggregation">Diferencias entre CRDs y API Aggregation</h4>
<div class="ulist">
<ul>
<li>
<p><strong>CRDs</strong>: Permiten definir nuevos tipos de recursos directamente en el API server principal, gestionados por el propio clúster.</p>
</li>
<li>
<p><strong>API Aggregation</strong>: Permite añadir APIs completas y lógicas de negocio externas, útiles cuando se requiere lógica de validación, mutación o procesamiento avanzado que no es posible solo con CRDs.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_arquitectura_de_api_aggregation">Arquitectura de API Aggregation</h4>
<div class="imageblock">
<div class="content">
<img src="api-aggregation.svg" alt="api aggregation" width="505" height="314">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_uso_metrics_server">Ejemplo de uso: Metrics Server</h4>
<div class="paragraph">
<p>Un ejemplo común de API Aggregation es el Metrics Server, que expone métricas de recursos (CPU, memoria) a través de la API <code>/apis/metrics.k8s.io/v1beta1</code>. El Metrics Server se registra como API agregada y Kubernetes enruta las solicitudes a este servicio.</p>
</div>
<div class="paragraph">
<p>Para ver las APIs agregadas en tu clúster:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get apiservices</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto mostrará recursos como <code>v1beta1.metrics.k8s.io</code> gestionados por servidores externos.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_manifiesto_de_apiservice">Ejemplo de manifiesto de APIService</h4>
<div class="paragraph">
<p>Para registrar una API agregada, se crea un recurso <code>APIService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: apiregistration.k8s.io/v1
kind: APIService
metadata:
  name: v1alpha1.ejemplo.miempresa.com
spec:
  service:
    name: mi-api-aggregated
    namespace: default
  group: ejemplo.miempresa.com
  version: v1alpha1
  insecureSkipTLSVerify: true
  groupPriorityMinimum: 1000
  versionPriority: 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>Esto indica al API server que enrute las solicitudes para el grupo y versión especificados al servicio <code>mi-api-aggregated</code> en el namespace <code>default</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_ventajas_y_casos_de_uso_2">Ventajas y casos de uso</h4>
<div class="ulist">
<div class="title">API Aggregation ofrece varias ventajas:</div>
<ul>
<li>
<p>Permite implementar lógica avanzada de validación, mutación y procesamiento.</p>
</li>
<li>
<p>Facilita la integración de servicios externos o APIs de terceros.</p>
</li>
<li>
<p>Útil para exponer recursos complejos o APIs que requieren control total sobre el backend.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_consideraciones_de_seguridad">Consideraciones de seguridad</h4>
<div class="ulist">
<div class="title">Al implementar API Aggregation, es importante considerar la seguridad:</div>
<ul>
<li>
<p>Es recomendable usar TLS y autenticación mutua entre el API server y los servidores agregados.</p>
</li>
<li>
<p>Controlar el acceso a las APIs agregadas mediante RBAC.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_45">Buenas prácticas</h4>
<div class="ulist">
<div class="title">Las siguientes recomendaciones te ayudarán a implementar API Aggregation de forma efectiva:</div>
<ul>
<li>
<p>Documentar claramente los recursos y endpoints expuestos por la API agregada.</p>
</li>
<li>
<p>Monitorizar el rendimiento y la disponibilidad del servidor de API agregado.</p>
</li>
<li>
<p>Versionar las APIs agregadas para facilitar la evolución y compatibilidad.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_servicios_en_la_nube_basados_en_kubernetes">Servicios en la nube basados en Kubernetes</h3>
<div class="paragraph">
<p>El auge de Kubernetes como estándar de orquestación de contenedores ha impulsado a los principales proveedores de nube a ofrecer servicios gestionados que simplifican el despliegue, administración y escalado de clústeres. Estos servicios permiten a las organizaciones centrarse en el desarrollo y operación de aplicaciones, delegando la gestión de la infraestructura subyacente al proveedor.</p>
</div>
<div class="sect3">
<h4 id="_qué_es_un_servicio_gestionado_de_kubernetes">¿Qué es un servicio gestionado de Kubernetes?</h4>
<div class="paragraph">
<p>Un servicio gestionado de Kubernetes es una oferta en la nube donde el proveedor se encarga de instalar, actualizar, escalar y mantener el plano de control (control plane) y, en muchos casos, los nodos de trabajo (worker nodes). El usuario puede crear y administrar clústeres de Kubernetes sin preocuparse por la complejidad de la instalación, la alta disponibilidad o los parches de seguridad.</p>
</div>
</div>
<div class="sect3">
<h4 id="_principales_servicios_en_la_nube">Principales servicios en la nube</h4>
<div class="sect4">
<h5 id="_google_kubernetes_engine_gke">Google Kubernetes Engine (GKE)</h5>
<div class="ulist">
<ul>
<li>
<p>Proveedor: Google Cloud Platform</p>
</li>
<li>
<p>Características:</p>
</li>
<li>
<p>Gestión automática del control plane y nodos.</p>
</li>
<li>
<p>Integración con servicios de Google (IAM, Stackdriver, Cloud Build).</p>
</li>
<li>
<p>Escalado automático de nodos y pods.</p>
</li>
<li>
<p>Actualizaciones automáticas y opciones de seguridad avanzadas.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de creación de clúster con <code>gcloud</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">gcloud container clusters create mi-cluster \
  --zone us-central1-a \
  --num-nodes 3</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_amazon_elastic_kubernetes_service_eks">Amazon Elastic Kubernetes Service (EKS)</h5>
<div class="ulist">
<ul>
<li>
<p>Proveedor: Amazon Web Services</p>
</li>
<li>
<p>Características:</p>
</li>
<li>
<p>Control plane gestionado y escalable.</p>
</li>
<li>
<p>Integración con IAM, CloudWatch, ALB, ECR.</p>
</li>
<li>
<p>Soporte para nodos EC2, Fargate (serverless) y nodos autogestionados.</p>
</li>
<li>
<p>Seguridad y cumplimiento con políticas de AWS.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de creación de clúster con <code>eksctl</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">eksctl create cluster --name mi-cluster --region us-west-2 --nodes 3</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_azure_kubernetes_service_aks">Azure Kubernetes Service (AKS)</h5>
<div class="ulist">
<ul>
<li>
<p>Proveedor: Microsoft Azure</p>
</li>
<li>
<p>Características:</p>
</li>
<li>
<p>Control plane gratuito y gestionado.</p>
</li>
<li>
<p>Integración con Azure Active Directory, Monitor, DevOps.</p>
</li>
<li>
<p>Escalado automático, actualizaciones y soporte para nodos spot.</p>
</li>
<li>
<p>Seguridad reforzada y opciones de red avanzadas.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Ejemplo de creación de clúster con <code>az</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">az aks create --resource-group mi-grupo --name mi-cluster --node-count 3 --generate-ssh-keys</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ventajas_de_los_servicios_gestionados">Ventajas de los servicios gestionados</h4>
<div class="ulist">
<div class="title">Los servicios gestionados de Kubernetes ofrecen varias ventajas:</div>
<ul>
<li>
<p><strong>Simplicidad</strong>: Eliminan la necesidad de instalar y mantener manualmente Kubernetes.</p>
</li>
<li>
<p><strong>Escalabilidad</strong>: Permiten escalar nodos y recursos de forma automática y bajo demanda.</p>
</li>
<li>
<p><strong>Seguridad</strong>: Aplican parches y actualizaciones de seguridad de manera proactiva.</p>
</li>
<li>
<p><strong>Integración</strong>: Se integran con otros servicios de la nube (almacenamiento, redes, monitorización, CI/CD).</p>
</li>
<li>
<p><strong>Alta disponibilidad</strong>: Ofrecen opciones de despliegue multi-zona y recuperación ante fallos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_consideraciones_y_buenas_prácticas">Consideraciones y buenas prácticas</h4>
<div class="ulist">
<div class="title">Al usar servicios gestionados de Kubernetes, es importante considerar:</div>
<ul>
<li>
<p><strong>Costes</strong>: Analizar el modelo de precios, ya que se paga por los recursos consumidos y, en algunos casos, por el control plane.</p>
</li>
<li>
<p><strong>Seguridad</strong>: Configurar roles y políticas de acceso (RBAC, IAM) y proteger los endpoints de la API.</p>
</li>
<li>
<p><strong>Backup y recuperación</strong>: Utilizar herramientas compatibles (Velero, snapshots de volúmenes) para proteger los datos y la configuración.</p>
</li>
<li>
<p><strong>Monitorización</strong>: Integrar con las soluciones de logging y métricas del proveedor para detectar incidencias y optimizar recursos.</p>
</li>
<li>
<p><strong>Actualizaciones</strong>: Planificar las actualizaciones de versión y probar la compatibilidad de las aplicaciones.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_archivo_de_configuración_kubeconfig">Ejemplo de archivo de configuración kubeconfig</h4>
<div class="listingblock">
<div class="title">Los servicios gestionados proporcionan un archivo <code>kubeconfig</code> para interactuar con el clúster desde <code>kubectl</code>:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: v1
clusters:
- cluster:
    certificate-authority-data: &lt;CA_DATA&gt;
    server: https://&lt;CLUSTER_ENDPOINT&gt;
  name: cloud-cluster
contexts:
- context:
    cluster: cloud-cluster
    user: cloud-user
  name: cloud-context
current-context: cloud-context
users:
- name: cloud-user
  user:
    token: &lt;ACCESS_TOKEN&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_otros_servicios_y_ecosistema">Otros servicios y ecosistema</h4>
<div class="paragraph">
<p>El ecosistema de Kubernetes en la nube es amplio y diverso, con múltiples proveedores y herramientas que complementan y amplían las capacidades de los servicios gestionados. Además de los principales servicios de Google, Amazon y Azure, existen otras opciones relevantes y soluciones especializadas que pueden adaptarse a diferentes necesidades empresariales y técnicas.</p>
</div>
<div class="sect4">
<h5 id="_ibm_cloud_kubernetes_service_iks">IBM Cloud Kubernetes Service (IKS)</h5>
<div class="ulist">
<ul>
<li>
<p>Proveedor: IBM Cloud</p>
</li>
<li>
<p>Características:</p>
</li>
<li>
<p>Control plane gestionado y nodos desplegados en la infraestructura de IBM.</p>
</li>
<li>
<p>Integración con servicios de IA, Watson, y herramientas de seguridad de IBM.</p>
</li>
<li>
<p>Opciones de despliegue multizona y soporte para bare metal.</p>
</li>
<li>
<p>Integración con Red Hat OpenShift y soporte empresarial.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_oracle_container_engine_for_kubernetes_oke">Oracle Container Engine for Kubernetes (OKE)</h5>
<div class="ulist">
<ul>
<li>
<p>Proveedor: Oracle Cloud Infrastructure (OCI)</p>
</li>
<li>
<p>Características:</p>
</li>
<li>
<p>Control plane gratuito y gestionado.</p>
</li>
<li>
<p>Integración con servicios de base de datos y almacenamiento de Oracle.</p>
</li>
<li>
<p>Opciones de nodos flexibles y soporte para redes avanzadas.</p>
</li>
<li>
<p>Seguridad reforzada y cumplimiento normativo.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_digitalocean_kubernetes_doks">DigitalOcean Kubernetes (DOKS)</h5>
<div class="ulist">
<ul>
<li>
<p>Proveedor: DigitalOcean</p>
</li>
<li>
<p>Características:</p>
</li>
<li>
<p>Sencillez y rapidez en la creación de clústeres.</p>
</li>
<li>
<p>Facturación simple y transparente.</p>
</li>
<li>
<p>Integración con block storage, load balancers y espacios de DigitalOcean.</p>
</li>
<li>
<p>Ideal para startups, proyectos pequeños y entornos de desarrollo.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_alibaba_cloud_container_service_for_kubernetes_ack">Alibaba Cloud Container Service for Kubernetes (ACK)</h5>
<div class="ulist">
<ul>
<li>
<p>Proveedor: Alibaba Cloud</p>
</li>
<li>
<p>Características:</p>
</li>
<li>
<p>Integración con el ecosistema de Alibaba (bases de datos, almacenamiento, red).</p>
</li>
<li>
<p>Opciones de escalado automático y despliegue multirregión.</p>
</li>
<li>
<p>Soporte para workloads híbridos y edge computing.</p>
</li>
<li>
<p>Seguridad y cumplimiento para el mercado asiático.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_red_hat_openshift_rosa_aro_openshift_dedicated">Red Hat OpenShift (ROSA, ARO, OpenShift Dedicated)</h5>
<div class="ulist">
<ul>
<li>
<p>Proveedor: Red Hat (disponible como servicio gestionado en AWS, Azure y en la nube de IBM)</p>
</li>
<li>
<p>Características:</p>
</li>
<li>
<p>Basado en Kubernetes, pero con herramientas adicionales para desarrolladores y operaciones.</p>
</li>
<li>
<p>Gestión avanzada de ciclo de vida, CI/CD integrado, y catálogo de aplicaciones.</p>
</li>
<li>
<p>Seguridad reforzada, soporte empresarial y cumplimiento.</p>
</li>
<li>
<p>Opciones de despliegue híbrido y multicloud.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_herramientas_y_servicios_complementarios">Herramientas y servicios complementarios</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Rancher</strong>: Plataforma de gestión multi-cluster y multi-cloud para Kubernetes, con interfaz gráfica y control centralizado.</p>
</li>
<li>
<p><strong>Portainer</strong>: Interfaz web para la gestión de clústeres Docker y Kubernetes.</p>
</li>
<li>
<p><strong>Lens</strong>: IDE para Kubernetes que facilita la visualización y administración de recursos.</p>
</li>
<li>
<p><strong>Velero</strong>: Solución de backup y recuperación de clústeres Kubernetes, compatible con la mayoría de servicios gestionados.</p>
</li>
<li>
<p><strong>ArgoCD y Flux</strong>: Herramientas de GitOps para despliegue continuo y gestión declarativa de aplicaciones en Kubernetes.</p>
</li>
<li>
<p><strong>Prometheus y Grafana</strong>: Monitorización y visualización de métricas en clústeres Kubernetes.</p>
</li>
<li>
<p><strong>Istio, Linkerd</strong>: Service Mesh para gestión avanzada de tráfico, seguridad y observabilidad.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_consideraciones_para_elegir_un_servicio">Consideraciones para elegir un servicio</h5>
<div class="ulist">
<ul>
<li>
<p><strong>Ubicación geográfica y cumplimiento</strong>: Elegir proveedores que ofrezcan regiones y certificaciones adecuadas a los requisitos legales y de negocio.</p>
</li>
<li>
<p><strong>Integración con otros servicios</strong>: Analizar la compatibilidad con bases de datos, almacenamiento, redes y herramientas de CI/CD.</p>
</li>
<li>
<p><strong>Soporte y comunidad</strong>: Valorar el soporte técnico, la documentación y la comunidad activa alrededor del servicio.</p>
</li>
<li>
<p><strong>Coste y escalabilidad</strong>: Comparar modelos de precios, opciones de escalado y flexibilidad de recursos.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_integraciones_con_proveedores_cloud_aws_gcp_azure">Integraciones con proveedores cloud (AWS, GCP, Azure)</h3>
<div class="paragraph">
<p>La integración de Kubernetes con los principales proveedores cloud —Amazon Web Services (AWS), Google Cloud Platform (GCP) y Microsoft Azure— permite aprovechar servicios nativos de cada plataforma, automatizar operaciones y mejorar la seguridad, el almacenamiento y la conectividad de los clústeres. Estas integraciones son clave para sacar el máximo partido a los servicios gestionados y a la infraestructura cloud.</p>
</div>
<div class="sect3">
<h4 id="_integración_con_aws">Integración con AWS</h4>
<div class="paragraph">
<p>AWS ofrece Amazon Elastic Kubernetes Service (EKS), pero además existen integraciones profundas con otros servicios:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Almacenamiento</strong>: Uso de volúmenes EBS como Persistent Volumes (PV) mediante el EBS CSI Driver.</p>
</li>
<li>
<p><strong>Balanceadores de carga</strong>: Integración automática con Elastic Load Balancer (ELB) para exponer servicios de Kubernetes.</p>
</li>
<li>
<p><strong>IAM Roles for Service Accounts (IRSA)</strong>: Permite que los pods asuman roles de IAM para acceder de forma segura a servicios de AWS (S3, DynamoDB, etc.).</p>
</li>
<li>
<p><strong>Autoscaling</strong>: Cluster Autoscaler y soporte para nodos EC2 y Fargate.</p>
</li>
<li>
<p><strong>Monitorización y logs</strong>: Integración con CloudWatch para métricas y logs de aplicaciones y clúster.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ejemplo de StorageClass para EBS:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: ebs-sc
provisioner: ebs.csi.aws.com
parameters:
  type: gp3</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_integración_con_gcp">Integración con GCP</h4>
<div class="paragraph">
<p>Google Cloud Platform proporciona Google Kubernetes Engine (GKE) y una integración nativa con sus servicios:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Almacenamiento</strong>: Uso de Persistent Disks como volúmenes persistentes.</p>
</li>
<li>
<p><strong>Balanceadores de carga</strong>: Integración con Google Cloud Load Balancer para exponer servicios.</p>
</li>
<li>
<p><strong>IAM y Workload Identity</strong>: Permite a los pods autenticarse con servicios de GCP usando identidades de Google.</p>
</li>
<li>
<p><strong>Autoscaling</strong>: Node Autoscaler y Horizontal Pod Autoscaler gestionados.</p>
</li>
<li>
<p><strong>Monitorización y logs</strong>: Stackdriver (ahora Cloud Operations) para métricas, logs y alertas.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ejemplo de StorageClass para Persistent Disk:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: pd-standard
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-standard</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_integración_con_azure">Integración con Azure</h4>
<div class="paragraph">
<p>Azure Kubernetes Service (AKS) facilita la integración con servicios de Azure:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Almacenamiento</strong>: Uso de Azure Disks y Azure Files como volúmenes persistentes.</p>
</li>
<li>
<p><strong>Balanceadores de carga</strong>: Integración con Azure Load Balancer y Application Gateway.</p>
</li>
<li>
<p><strong>Managed Identities</strong>: Permite a los pods acceder de forma segura a servicios de Azure (Blob Storage, Key Vault, etc.).</p>
</li>
<li>
<p><strong>Autoscaling</strong>: Cluster Autoscaler y Virtual Node para escalar con Azure Container Instances.</p>
</li>
<li>
<p><strong>Monitorización y logs</strong>: Azure Monitor y Log Analytics para observabilidad y alertas.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Ejemplo de StorageClass para Azure Disk:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: azure-disk
provisioner: disk.csi.azure.com
parameters:
  skuName: Standard_LRS</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_de_integración">Buenas prácticas de integración</h4>
<div class="ulist">
<ul>
<li>
<p>Utilizar controladores CSI (Container Storage Interface) oficiales para almacenamiento.</p>
</li>
<li>
<p>Configurar roles y permisos mínimos necesarios para los pods (principio de menor privilegio).</p>
</li>
<li>
<p>Aprovechar las herramientas de monitorización y logging nativas del proveedor.</p>
</li>
<li>
<p>Automatizar la provisión de recursos cloud mediante controladores y operadores.</p>
</li>
<li>
<p>Mantener actualizados los controladores y plugins de integración.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_herramientas_complementarias">Herramientas complementarias</h3>
<div class="paragraph">
<p>El ecosistema de Kubernetes y Docker se enriquece con una amplia variedad de herramientas complementarias que facilitan la gestión, automatización, monitorización, seguridad y despliegue de aplicaciones en entornos de contenedores. Estas herramientas ayudan a cubrir necesidades específicas y a mejorar la eficiencia operativa.</p>
</div>
<div class="sect3">
<h4 id="_monitorización_y_observabilidad">Monitorización y observabilidad</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Prometheus</strong>: Sistema de monitorización y alerta ampliamente adoptado en Kubernetes. Permite recolectar métricas de clústeres, nodos, pods y aplicaciones.</p>
</li>
<li>
<p><strong>Grafana</strong>: Plataforma de visualización de métricas que se integra con Prometheus y otras fuentes de datos para crear dashboards interactivos.</p>
</li>
<li>
<p><strong>Kube-state-metrics</strong>: Exporta métricas sobre el estado de los recursos de Kubernetes, útil para monitorización avanzada.</p>
</li>
<li>
<p><strong>ELK Stack (Elasticsearch, Logstash, Kibana)</strong>: Solución para la gestión y visualización de logs de aplicaciones y clústeres.</p>
</li>
<li>
<p><strong>Loki</strong>: Sistema de logs diseñado para integrarse con Grafana y Kubernetes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_seguridad_y_cumplimiento">Seguridad y cumplimiento</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Kube-bench</strong>: Evalúa la seguridad del clúster según las recomendaciones de CIS Kubernetes Benchmark.</p>
</li>
<li>
<p><strong>Kube-hunter</strong>: Herramienta de auditoría que detecta vulnerabilidades en clústeres Kubernetes.</p>
</li>
<li>
<p><strong>Trivy</strong>: Escáner de vulnerabilidades para imágenes de contenedor y recursos de Kubernetes.</p>
</li>
<li>
<p><strong>OPA (Open Policy Agent)</strong>: Motor de políticas para controlar el acceso y la configuración de recursos en Kubernetes.</p>
</li>
<li>
<p><strong>Kyverno</strong>: Herramienta de políticas nativa de Kubernetes para validar, mutar y generar recursos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_y_automatización">Gestión y automatización</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Helm</strong>: Gestor de paquetes para Kubernetes que facilita el despliegue y la actualización de aplicaciones mediante charts.</p>
</li>
<li>
<p><strong>Kustomize</strong>: Permite personalizar manifiestos de Kubernetes sin duplicar archivos.</p>
</li>
<li>
<p><strong>ArgoCD</strong> y <strong>Flux</strong>: Herramientas de GitOps para despliegue continuo y gestión declarativa de aplicaciones.</p>
</li>
<li>
<p><strong>Velero</strong>: Solución para backup y recuperación de clústeres y volúmenes persistentes.</p>
</li>
<li>
<p><strong>Rancher</strong>: Plataforma de gestión multi-cluster y multi-cloud con interfaz gráfica.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_service_mesh_y_networking">Service Mesh y networking</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Istio</strong>: Service Mesh que proporciona control avanzado de tráfico, seguridad, observabilidad y gestión de servicios.</p>
</li>
<li>
<p><strong>Linkerd</strong>: Service Mesh ligero y fácil de instalar, enfocado en la simplicidad y el rendimiento.</p>
</li>
<li>
<p><strong>Cilium</strong>: Solución de networking y seguridad basada en eBPF para Kubernetes.</p>
</li>
<li>
<p><strong>MetalLB</strong>: Proporciona soporte de LoadBalancer en clústeres on-premises.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_desarrollo_y_productividad">Desarrollo y productividad</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Skaffold</strong>: Automatiza el ciclo de desarrollo local a clúster, facilitando el build, push y deploy de aplicaciones.</p>
</li>
<li>
<p><strong>Tilt</strong>: Herramienta para desarrollo local de aplicaciones en Kubernetes con feedback rápido.</p>
</li>
<li>
<p><strong>Telepresence</strong>: Permite el desarrollo y depuración remota de servicios en clústeres Kubernetes desde el entorno local.</p>
</li>
<li>
<p><strong>Lens</strong>: IDE gráfico para la administración y visualización de clústeres Kubernetes.</p>
</li>
<li>
<p><strong>Portainer</strong>: Interfaz web para la gestión de contenedores Docker y clústeres Kubernetes.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_integración_helm">Ejemplo de integración: Helm</h4>
<div class="paragraph">
<p>Desplegar una aplicación con Helm:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">helm repo add bitnami https://charts.bitnami.com/bitnami
helm install mi-mysql bitnami/mysql</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_buenas_prácticas_46">Buenas prácticas</h4>
<div class="ulist">
<ul>
<li>
<p>Seleccionar herramientas que se integren bien con el stack tecnológico y los flujos de trabajo existentes.</p>
</li>
<li>
<p>Mantener las herramientas actualizadas y monitorizar su seguridad.</p>
</li>
<li>
<p>Automatizar tareas repetitivas y documentar los procesos.</p>
</li>
<li>
<p>Evaluar el impacto de cada herramienta en la seguridad y el rendimiento del clúster.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_recursos_adicionales">Recursos Adicionales</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_documentación_oficial_y_cncf">Documentación oficial y CNCF</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://kubernetes.io/es/docs/">Documentación oficial de Kubernetes</a>: La fuente principal y más actualizada sobre todos los conceptos, recursos y comandos de Kubernetes.</p>
</li>
<li>
<p><a href="https://github.com/kubernetes/kubernetes">Repositorio oficial de Kubernetes en GitHub</a>: Para explorar el código fuente, reportar issues y contribuir.</p>
</li>
<li>
<p><a href="https://www.cncf.io/">Cloud Native Computing Foundation (CNCF)</a>: Organización que impulsa Kubernetes y otros proyectos cloud-native. Ofrece recursos, webinars y eventos.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_certificaciones_disponibles_cka_ckad_cks">Certificaciones disponibles (CKA, CKAD, CKS)</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Certified Kubernetes Administrator (CKA)</strong>: Certificación orientada a la administración y operación de clústeres Kubernetes.</p>
</li>
<li>
<p><strong>Certified Kubernetes Application Developer (CKAD)</strong>: Certificación enfocada en el desarrollo y despliegue de aplicaciones sobre Kubernetes.</p>
</li>
<li>
<p><strong>Certified Kubernetes Security Specialist (CKS)</strong>: Certificación avanzada sobre seguridad en entornos Kubernetes.</p>
</li>
<li>
<p>Más información y registro: <a href="https://training.linuxfoundation.org/certification/" class="bare">https://training.linuxfoundation.org/certification/</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_comunidad_y_eventos">Comunidad y eventos</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://discuss.kubernetes.io/">Foro oficial de Kubernetes</a>: Espacio para resolver dudas y compartir experiencias.</p>
</li>
<li>
<p><a href="https://slack.k8s.io/">Slack de Kubernetes</a>: Comunidad activa con canales temáticos.</p>
</li>
<li>
<p><a href="https://www.meetup.com/topics/kubernetes/">Meetups de Kubernetes</a>: Encuentra eventos y grupos locales para networking y aprendizaje.</p>
</li>
<li>
<p><a href="https://www.cncf.io/events/">Eventos CNCF</a>: KubeCon, CloudNativeCon y otros eventos internacionales.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_recursos_de_aprendizaje_continuo">Recursos de aprendizaje continuo</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://katacoda.com/courses/kubernetes">Katacoda</a>: Laboratorios interactivos gratuitos para practicar Kubernetes.</p>
</li>
<li>
<p><a href="https://play.instruqt.com/public/topics/kubernetes">Instruqt</a>: Escenarios prácticos y retos de Kubernetes.</p>
</li>
<li>
<p><a href="https://www.udemy.com/topic/kubernetes/">Cursos en Udemy</a>: Amplia oferta de cursos en español e inglés.</p>
</li>
<li>
<p><a href="https://www.edx.org/learn/kubernetes">edX</a>: Cursos oficiales de la CNCF y Linux Foundation.</p>
</li>
<li>
<p><a href="https://www.youtube.com/c/KubernetesCommunity">YouTube Kubernetes Community</a>: Charlas, tutoriales y grabaciones de eventos.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_tendencias_futuras_en_el_ecosistema_de_kubernetes">Tendencias futuras en el ecosistema de Kubernetes</h3>
<div class="ulist">
<ul>
<li>
<p><strong>Serverless sobre Kubernetes</strong>: Uso de frameworks como Knative para ejecutar funciones sin gestionar la infraestructura.</p>
</li>
<li>
<p><strong>GitOps</strong>: Automatización de despliegues y gestión de clústeres basada en Git (ArgoCD, Flux).</p>
</li>
<li>
<p><strong>Service Mesh</strong>: Adopción creciente de Istio, Linkerd y otros para observabilidad, seguridad y control de tráfico.</p>
</li>
<li>
<p><strong>Edge Computing</strong>: Kubernetes ligero (K3s, MicroK8s) para IoT y entornos distribuidos.</p>
</li>
<li>
<p><strong>Inteligencia Artificial y ML Ops</strong>: Integración de flujos de trabajo de machine learning sobre Kubernetes.</p>
</li>
<li>
<p><strong>Seguridad avanzada</strong>: Políticas de seguridad, escaneo de imágenes y Zero Trust en el ciclo de vida de aplicaciones.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_módulo_16_terraform">Módulo 16: Terraform</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introducción_a_infrastructure_as_code_iac">Introducción a Infrastructure as Code (IaC)</h3>
<div class="paragraph">
<p><strong>Infrastructure as Code (IaC)</strong> es una práctica que permite gestionar y aprovisionar infraestructura mediante código declarativo o programático en lugar de procesos manuales. Esta metodología ofrece múltiples ventajas como versionado, automatización, reproducibilidad y colaboración en equipo.</p>
</div>
<div class="sect3">
<h4 id="_beneficios_de_iac">Beneficios de IaC</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Automatización</strong>: Eliminación de tareas manuales repetitivas y propensas a errores.</p>
</li>
<li>
<p><strong>Versionado</strong>: Control de versiones de la infraestructura igual que el código de aplicaciones.</p>
</li>
<li>
<p><strong>Reproducibilidad</strong>: Capacidad de crear entornos idénticos de forma consistente.</p>
</li>
<li>
<p><strong>Documentación viva</strong>: El código sirve como documentación actualizada de la infraestructura.</p>
</li>
<li>
<p><strong>Colaboración</strong>: Múltiples equipos pueden trabajar sobre la misma infraestructura.</p>
</li>
<li>
<p><strong>Reutilización</strong>: Módulos y componentes reutilizables en diferentes proyectos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_enfoques_de_iac">Enfoques de IaC</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Declarativo</strong>: Se define el estado deseado de la infraestructura (ejemplo: Terraform, Kubernetes manifiestos).</p>
</li>
<li>
<p><strong>Imperativo</strong>: Se definen los pasos para alcanzar el estado deseado (ejemplo: scripts de shell, Ansible).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_qué_es_terraform">¿Qué es Terraform?</h3>
<div class="paragraph">
<p><strong>Terraform</strong> es una herramienta open-source de HashiCorp para construir, cambiar y versionar infraestructura de forma segura y eficiente. Utiliza un lenguaje declarativo propio llamado HCL (HashiCorp Configuration Language) y soporta múltiples proveedores cloud y on-premises.</p>
</div>
<div class="sect3">
<h4 id="_características_principales">Características principales</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Multi-cloud</strong>: Soporta AWS, Azure, GCP, VMware, OpenStack y más de 1000 proveedores.</p>
</li>
<li>
<p><strong>Declarativo</strong>: Defines el estado deseado, Terraform calcula los cambios necesarios.</p>
</li>
<li>
<p><strong>Plan de ejecución</strong>: Muestra qué cambios se realizarán antes de aplicarlos.</p>
</li>
<li>
<p><strong>Grafo de recursos</strong>: Construye un grafo de dependencias para paralelizar operaciones.</p>
</li>
<li>
<p><strong>State management</strong>: Mantiene el estado actual de la infraestructura.</p>
</li>
<li>
<p><strong>Módulos reutilizables</strong>: Organiza y comparte configuraciones de infraestructura.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_casos_de_uso">Casos de uso</h4>
<div class="ulist">
<ul>
<li>
<p>Aprovisionamiento de infraestructura cloud (VMs, redes, almacenamiento).</p>
</li>
<li>
<p>Gestión de clústeres Kubernetes y sus recursos.</p>
</li>
<li>
<p>Configuración de servicios de red (load balancers, DNS, firewalls).</p>
</li>
<li>
<p>Despliegue multi-cloud y multi-región.</p>
</li>
<li>
<p>Creación de entornos de desarrollo, staging y producción idénticos.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_instalación_de_terraform">Instalación de Terraform</h3>
<div class="sect3">
<h4 id="_linux_ubuntudebian">Linux (Ubuntu/Debian)</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Añadir la clave GPG de HashiCorp
wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg

# Añadir el repositorio
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list

# Actualizar e instalar
sudo apt update &amp;&amp; sudo apt install terraform

# Verificar instalación
terraform version</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_instalación_con_gestor_de_paquetes">Instalación con gestor de paquetes</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Homebrew (macOS/Linux)
brew tap hashicorp/tap
brew install hashicorp/tap/terraform

# Chocolatey (Windows)
choco install terraform

# Verificar instalación
terraform version</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_instalación_manual">Instalación manual</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Descargar binario desde https://www.terraform.io/downloads
wget https://releases.hashicorp.com/terraform/1.7.0/terraform_1.7.0_linux_amd64.zip
unzip terraform_1.7.0_linux_amd64.zip
sudo mv terraform /usr/local/bin/
terraform version</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_conceptos_fundamentales_de_terraform">Conceptos fundamentales de Terraform</h3>
<div class="sect3">
<h4 id="_providers">Providers</h4>
<div class="paragraph">
<p>Los <strong>providers</strong> son plugins que permiten a Terraform interactuar con APIs de proveedores cloud, SaaS y otros servicios.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de configuración de provider AWS:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~&gt; 5.0"
    }
  }
  required_version = "&gt;= 1.5.0"
}

provider "aws" {
  region = "us-east-1"

  default_tags {
    tags = {
      Environment = "Production"
      ManagedBy   = "Terraform"
    }
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo con múltiples providers:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">provider "aws" {
  region = "us-east-1"
  alias  = "east"
}

provider "aws" {
  region = "us-west-2"
  alias  = "west"
}

# Usar provider específico
resource "aws_instance" "east_server" {
  provider      = aws.east
  ami           = "ami-12345678"
  instance_type = "t3.micro"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resources">Resources</h4>
<div class="paragraph">
<p>Los <strong>resources</strong> son los bloques fundamentales de Terraform y representan componentes de infraestructura (VMs, redes, etc.).</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de recurso AWS EC2:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">resource "aws_instance" "web_server" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.micro"

  tags = {
    Name        = "WebServer"
    Environment = "Production"
  }

  root_block_device {
    volume_size = 20
    volume_type = "gp3"
  }

  user_data = &lt;&lt;-EOF
              #!/bin/bash
              apt-get update
              apt-get install -y nginx
              systemctl start nginx
              EOF
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ejemplo de recurso Kubernetes:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">resource "kubernetes_deployment" "nginx" {
  metadata {
    name      = "nginx-deployment"
    namespace = "default"

    labels = {
      app = "nginx"
    }
  }

  spec {
    replicas = 3

    selector {
      match_labels = {
        app = "nginx"
      }
    }

    template {
      metadata {
        labels = {
          app = "nginx"
        }
      }

      spec {
        container {
          name  = "nginx"
          image = "nginx:1.25"

          port {
            container_port = 80
          }

          resources {
            requests = {
              cpu    = "100m"
              memory = "128Mi"
            }
            limits = {
              cpu    = "200m"
              memory = "256Mi"
            }
          }
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_data_sources">Data Sources</h4>
<div class="paragraph">
<p>Los <strong>data sources</strong> permiten obtener información de recursos existentes fuera de Terraform para usarla en la configuración.</p>
</div>
<div class="listingblock">
<div class="title">Ejemplo de data source:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl"># Obtener información de una VPC existente
data "aws_vpc" "existing" {
  id = "vpc-12345678"
}

# Usar el data source en un recurso
resource "aws_subnet" "public" {
  vpc_id     = data.aws_vpc.existing.id
  cidr_block = "10.0.1.0/24"
}

# Obtener AMI más reciente de Ubuntu
data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"] # Canonical

  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
  }
}

resource "aws_instance" "server" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = "t3.micro"
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_variables">Variables</h4>
<div class="paragraph">
<p>Las <strong>variables</strong> permiten parametrizar la configuración de Terraform para hacerla reutilizable.</p>
</div>
<div class="listingblock">
<div class="title">Definición de variables (variables.tf):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">variable "region" {
  description = "AWS region donde desplegar recursos"
  type        = string
  default     = "us-east-1"
}

variable "instance_type" {
  description = "Tipo de instancia EC2"
  type        = string
  default     = "t3.micro"

  validation {
    condition     = contains(["t3.micro", "t3.small", "t3.medium"], var.instance_type)
    error_message = "El tipo de instancia debe ser t3.micro, t3.small o t3.medium."
  }
}

variable "environment" {
  description = "Entorno de despliegue"
  type        = string
}

variable "instance_count" {
  description = "Número de instancias a crear"
  type        = number
  default     = 1
}

variable "enable_monitoring" {
  description = "Habilitar monitorización detallada"
  type        = bool
  default     = false
}

variable "tags" {
  description = "Tags comunes para todos los recursos"
  type        = map(string)
  default     = {}
}

variable "subnet_ids" {
  description = "Lista de IDs de subnets"
  type        = list(string)
  default     = []
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Uso de variables:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">resource "aws_instance" "server" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = var.instance_type
  count         = var.instance_count

  monitoring = var.enable_monitoring

  tags = merge(
    var.tags,
    {
      Name        = "Server-${count.index + 1}"
      Environment = var.environment
    }
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Archivo de valores (terraform.tfvars):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">region           = "eu-west-1"
instance_type    = "t3.small"
environment      = "production"
instance_count   = 3
enable_monitoring = true

tags = {
  Project   = "MyApp"
  ManagedBy = "Terraform"
  Owner     = "DevOps Team"
}

subnet_ids = ["subnet-abc123", "subnet-def456", "subnet-ghi789"]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_outputs">Outputs</h4>
<div class="paragraph">
<p>Los <strong>outputs</strong> exponen valores de los recursos creados para su uso posterior o consulta.</p>
</div>
<div class="listingblock">
<div class="title">Definición de outputs (outputs.tf):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">output "instance_ids" {
  description = "IDs de las instancias EC2 creadas"
  value       = aws_instance.server[*].id
}

output "instance_public_ips" {
  description = "IPs públicas de las instancias"
  value       = aws_instance.server[*].public_ip
}

output "instance_private_ips" {
  description = "IPs privadas de las instancias"
  value       = aws_instance.server[*].private_ip
  sensitive   = false
}

output "vpc_id" {
  description = "ID de la VPC utilizada"
  value       = data.aws_vpc.existing.id
}

output "deployment_info" {
  description = "Información completa del despliegue"
  value = {
    region      = var.region
    environment = var.environment
    instances   = length(aws_instance.server)
    timestamp   = timestamp()
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Consultar outputs después del apply:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver todos los outputs
terraform output

# Ver un output específico
terraform output instance_public_ips

# Obtener output en formato JSON
terraform output -json</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_state_estado">State (Estado)</h4>
<div class="paragraph">
<p>El <strong>state</strong> es un archivo que Terraform usa para mapear recursos del mundo real con tu configuración y rastrear metadatos.</p>
</div>
<div class="ulist">
<div class="title">Características del state:</div>
<ul>
<li>
<p>Por defecto se almacena localmente en <code>terraform.tfstate</code>.</p>
</li>
<li>
<p>Contiene información sensible (contraseñas, claves privadas).</p>
</li>
<li>
<p>Permite a Terraform saber qué recursos gestiona.</p>
</li>
<li>
<p>Se puede almacenar remotamente (S3, Terraform Cloud, etc.).</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Configuración de backend remoto (S3):</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">terraform {
  backend "s3" {
    bucket         = "mi-terraform-state"
    key            = "production/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true
    dynamodb_table = "terraform-locks"
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Comandos útiles para gestionar el state:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Ver el state actual
terraform show

# Listar recursos en el state
terraform state list

# Ver detalles de un recurso específico
terraform state show aws_instance.web_server

# Mover un recurso en el state
terraform state mv aws_instance.old aws_instance.new

# Eliminar un recurso del state (sin destruirlo)
terraform state rm aws_instance.web_server

# Pull del state remoto
terraform state pull

# Push del state local al remoto
terraform state push</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_comandos_básicos_de_terraform">Comandos básicos de Terraform</h3>
<div class="sect3">
<h4 id="_terraform_init">terraform init</h4>
<div class="paragraph">
<p>Inicializa un directorio de trabajo de Terraform. Descarga providers, módulos y configura el backend.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Inicializar directorio
terraform init

# Reinicializar con upgrade de providers
terraform init -upgrade

# Inicializar solo backend
terraform init -backend=true -backend-config="bucket=my-bucket"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_terraform_plan">terraform plan</h4>
<div class="paragraph">
<p>Crea un plan de ejecución mostrando qué cambios se realizarán.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Crear plan
terraform plan

# Guardar plan en un archivo
terraform plan -out=plan.tfplan

# Plan con archivo de variables específico
terraform plan -var-file="production.tfvars"

# Plan para destruir recursos
terraform plan -destroy</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_terraform_apply">terraform apply</h4>
<div class="paragraph">
<p>Aplica los cambios necesarios para alcanzar el estado deseado.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Aplicar cambios (solicita confirmación)
terraform apply

# Aplicar cambios automáticamente
terraform apply -auto-approve

# Aplicar un plan guardado
terraform apply plan.tfplan

# Aplicar con variables
terraform apply -var="region=us-west-2" -var="instance_count=3"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_terraform_destroy">terraform destroy</h4>
<div class="paragraph">
<p>Destruye todos los recursos gestionados por Terraform.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Destruir todos los recursos (solicita confirmación)
terraform destroy

# Destruir automáticamente
terraform destroy -auto-approve

# Destruir recursos específicos
terraform destroy -target=aws_instance.web_server</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_otros_comandos_útiles">Otros comandos útiles</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Validar sintaxis de los archivos
terraform validate

# Formatear código siguiendo estándares
terraform fmt

# Formatear recursivamente
terraform fmt -recursive

# Ver el grafo de dependencias
terraform graph | dot -Tpng &gt; graph.png

# Mostrar información del workspace actual
terraform workspace show

# Listar workspaces
terraform workspace list

# Crear nuevo workspace
terraform workspace new staging

# Cambiar de workspace
terraform workspace select production

# Actualizar state con cambios externos
terraform refresh

# Importar recurso existente a Terraform
terraform import aws_instance.web_server i-1234567890abcdef0</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_módulos_de_terraform">Módulos de Terraform</h3>
<div class="paragraph">
<p>Los <strong>módulos</strong> son contenedores de múltiples recursos que se usan juntos. Permiten organizar, encapsular y reutilizar configuración.</p>
</div>
<div class="sect3">
<h4 id="_estructura_de_un_módulo">Estructura de un módulo</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">modules/
└── webserver/
    ├── main.tf        # Recursos principales
    ├── variables.tf   # Variables de entrada
    ├── outputs.tf     # Valores de salida
    └── README.md      # Documentación</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_de_módulo_webserver">Ejemplo de módulo (webserver)</h4>
<div class="listingblock">
<div class="title">modules/webserver/main.tf:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">resource "aws_security_group" "web" {
  name_prefix = "${var.name_prefix}-web-"
  description = "Security group for web server"
  vpc_id      = var.vpc_id

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = var.tags
}

resource "aws_instance" "web" {
  ami           = var.ami_id
  instance_type = var.instance_type
  subnet_id     = var.subnet_id

  vpc_security_group_ids = [aws_security_group.web.id]

  user_data = var.user_data

  tags = merge(
    var.tags,
    {
      Name = "${var.name_prefix}-web-server"
    }
  )
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">modules/webserver/variables.tf:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">variable "name_prefix" {
  description = "Prefijo para nombrar recursos"
  type        = string
}

variable "vpc_id" {
  description = "ID de la VPC"
  type        = string
}

variable "subnet_id" {
  description = "ID de la subnet"
  type        = string
}

variable "ami_id" {
  description = "ID de la AMI"
  type        = string
}

variable "instance_type" {
  description = "Tipo de instancia EC2"
  type        = string
  default     = "t3.micro"
}

variable "user_data" {
  description = "Script de user data"
  type        = string
  default     = ""
}

variable "tags" {
  description = "Tags para los recursos"
  type        = map(string)
  default     = {}
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">modules/webserver/outputs.tf:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">output "instance_id" {
  description = "ID de la instancia EC2"
  value       = aws_instance.web.id
}

output "public_ip" {
  description = "IP pública de la instancia"
  value       = aws_instance.web.public_ip
}

output "security_group_id" {
  description = "ID del security group"
  value       = aws_security_group.web.id
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_uso_del_módulo">Uso del módulo</h4>
<div class="listingblock">
<div class="title">main.tf:</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">module "production_webserver" {
  source = "./modules/webserver"

  name_prefix   = "prod"
  vpc_id        = "vpc-12345678"
  subnet_id     = "subnet-abc123"
  ami_id        = data.aws_ami.ubuntu.id
  instance_type = "t3.small"

  user_data = file("${path.module}/scripts/install_nginx.sh")

  tags = {
    Environment = "Production"
    Project     = "WebApp"
  }
}

module "staging_webserver" {
  source = "./modules/webserver"

  name_prefix   = "staging"
  vpc_id        = "vpc-87654321"
  subnet_id     = "subnet-def456"
  ami_id        = data.aws_ami.ubuntu.id
  instance_type = "t3.micro"

  tags = {
    Environment = "Staging"
    Project     = "WebApp"
  }
}

output "production_server_ip" {
  value = module.production_webserver.public_ip
}

output "staging_server_ip" {
  value = module.staging_webserver.public_ip
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_módulos_públicos_del_registry">Módulos públicos del Registry</h4>
<div class="paragraph">
<p>Terraform Registry contiene miles de módulos públicos listos para usar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl"># Módulo de VPC de AWS
module "vpc" {
  source  = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"

  name = "my-vpc"
  cidr = "10.0.0.0/16"

  azs             = ["us-east-1a", "us-east-1b", "us-east-1c"]
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24", "10.0.3.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24", "10.0.103.0/24"]

  enable_nat_gateway = true
  enable_vpn_gateway = true

  tags = {
    Terraform   = "true"
    Environment = "production"
  }
}

# Módulo de cluster EKS
module "eks" {
  source  = "terraform-aws-modules/eks/aws"
  version = "19.0.0"

  cluster_name    = "my-eks-cluster"
  cluster_version = "1.28"

  vpc_id     = module.vpc.vpc_id
  subnet_ids = module.vpc.private_subnets

  eks_managed_node_groups = {
    general = {
      desired_size = 2
      min_size     = 1
      max_size     = 3

      instance_types = ["t3.medium"]
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_terraform_con_kubernetes">Terraform con Kubernetes</h3>
<div class="paragraph">
<p>Terraform puede gestionar recursos de Kubernetes directamente usando el provider oficial.</p>
</div>
<div class="sect3">
<h4 id="_configuración_del_provider_kubernetes">Configuración del provider Kubernetes</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl">terraform {
  required_providers {
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = "~&gt; 2.24"
    }
  }
}

# Configuración usando kubeconfig
provider "kubernetes" {
  config_path    = "~/.kube/config"
  config_context = "minikube"
}

# O configuración directa
provider "kubernetes" {
  host                   = "https://cluster-api.example.com"
  client_certificate     = file("~/.kube/client-cert.pem")
  client_key             = file("~/.kube/client-key.pem")
  cluster_ca_certificate = file("~/.kube/cluster-ca-cert.pem")
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ejemplo_desplegar_aplicación_completa_en_kubernetes">Ejemplo: Desplegar aplicación completa en Kubernetes</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-hcl hljs" data-lang="hcl"># Namespace
resource "kubernetes_namespace" "app" {
  metadata {
    name = "my-app"

    labels = {
      environment = "production"
    }
  }
}

# ConfigMap
resource "kubernetes_config_map" "app_config" {
  metadata {
    name      = "app-config"
    namespace = kubernetes_namespace.app.metadata[0].name
  }

  data = {
    "app.properties" = &lt;&lt;-EOF
      server.port=8080
      db.host=postgres-service
      db.port=5432
    EOF
  }
}

# Secret
resource "kubernetes_secret" "db_credentials" {
  metadata {
    name      = "db-credentials"
    namespace = kubernetes_namespace.app.metadata[0].name
  }

  type = "Opaque"

  data = {
    username = base64encode("dbuser")
    password = base64encode("secure-password")
  }
}

# Deployment
resource "kubernetes_deployment" "app" {
  metadata {
    name      = "my-app"
    namespace = kubernetes_namespace.app.metadata[0].name

    labels = {
      app = "my-app"
    }
  }

  spec {
    replicas = 3

    selector {
      match_labels = {
        app = "my-app"
      }
    }

    template {
      metadata {
        labels = {
          app = "my-app"
        }
      }

      spec {
        container {
          name  = "app"
          image = "myapp:1.0.0"

          port {
            container_port = 8080
          }

          env {
            name = "DB_USER"
            value_from {
              secret_key_ref {
                name = kubernetes_secret.db_credentials.metadata[0].name
                key  = "username"
              }
            }
          }

          env {
            name = "DB_PASSWORD"
            value_from {
              secret_key_ref {
                name = kubernetes_secret.db_credentials.metadata[0].name
                key  = "password"
              }
            }
          }

          volume_mount {
            name       = "config"
            mount_path = "/etc/config"
          }

          resources {
            requests = {
              cpu    = "100m"
              memory = "128Mi"
            }
            limits = {
              cpu    = "500m"
              memory = "512Mi"
            }
          }

          liveness_probe {
            http_get {
              path = "/health"
              port = 8080
            }
            initial_delay_seconds = 30
            period_seconds        = 10
          }

          readiness_probe {
            http_get {
              path = "/ready"
              port = 8080
            }
            initial_delay_seconds = 5
            period_seconds        = 5
          }
        }

        volume {
          name = "config"
          config_map {
            name = kubernetes_config_map.app_config.metadata[0].name
          }
        }
      }
    }
  }
}

# Service
resource "kubernetes_service" "app" {
  metadata {
    name      = "my-app-service"
    namespace = kubernetes_namespace.app.metadata[0].name
  }

  spec {
    selector = {
      app = "my-app"
    }

    port {
      name        = "http"
      port        = 80
      target_port = 8080
    }

    type = "LoadBalancer"
  }
}

# Ingress
resource "kubernetes_ingress_v1" "app" {
  metadata {
    name      = "my-app-ingress"
    namespace = kubernetes_namespace.app.metadata[0].name

    annotations = {
      "kubernetes.io/ingress.class"                = "nginx"
      "cert-manager.io/cluster-issuer"             = "letsencrypt-prod"
      "nginx.ingress.kubernetes.io/rewrite-target" = "/"
    }
  }

  spec {
    tls {
      hosts       = ["myapp.example.com"]
      secret_name = "myapp-tls"
    }

    rule {
      host = "myapp.example.com"

      http {
        path {
          path      = "/"
          path_type = "Prefix"

          backend {
            service {
              name = kubernetes_service.app.metadata[0].name
              port {
                number = 80
              }
            }
          }
        }
      }
    }
  }
}

# HorizontalPodAutoscaler
resource "kubernetes_horizontal_pod_autoscaler_v2" "app" {
  metadata {
    name      = "my-app-hpa"
    namespace = kubernetes_namespace.app.metadata[0].name
  }

  spec {
    scale_target_ref {
      api_version = "apps/v1"
      kind        = "Deployment"
      name        = kubernetes_deployment.app.metadata[0].name
    }

    min_replicas = 2
    max_replicas = 10

    metric {
      type = "Resource"
      resource {
        name = "cpu"
        target {
          type                = "Utilization"
          average_utilization = 70
        }
      }
    }

    metric {
      type = "Resource"
      resource {
        name = "memory"
        target {
          type                = "Utilization"
          average_utilization = 80
        }
      }
    }
  }
}

# Outputs
output "namespace" {
  value = kubernetes_namespace.app.metadata[0].name
}

output "service_load_balancer_ip" {
  value = kubernetes_service.app.status[0].load_balancer[0].ingress[0].ip
}

output "ingress_hostname" {
  value = "myapp.example.com"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_buenas_prácticas_con_terraform">Buenas prácticas con Terraform</h3>
<div class="sect3">
<h4 id="_organización_del_código">Organización del código</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Separar por entornos</strong>: Usa directorios o workspaces para dev, staging, production.</p>
</li>
<li>
<p><strong>Modularizar</strong>: Divide la infraestructura en módulos reutilizables.</p>
</li>
<li>
<p><strong>Nombrado consistente</strong>: Usa convenciones claras para recursos, variables y archivos.</p>
</li>
<li>
<p><strong>Documentación</strong>: Incluye README.md en cada módulo con ejemplos de uso.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_gestión_del_state">Gestión del state</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Backend remoto</strong>: Usa S3, Azure Blob, Terraform Cloud o similar.</p>
</li>
<li>
<p><strong>State locking</strong>: Habilita bloqueo para evitar cambios concurrentes (DynamoDB con S3).</p>
</li>
<li>
<p><strong>Cifrado</strong>: Activa cifrado del state en reposo y en tránsito.</p>
</li>
<li>
<p><strong>Backups</strong>: Configura versionado y backups del state.</p>
</li>
<li>
<p><strong>Separación</strong>: No compartas state entre entornos críticos.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_seguridad">Seguridad</h4>
<div class="ulist">
<ul>
<li>
<p><strong>No hardcodear secretos</strong>: Usa variables de entorno, vaults o servicios de secrets.</p>
</li>
<li>
<p><strong>Sensitive data</strong>: Marca outputs sensibles con <code>sensitive = true</code>.</p>
</li>
<li>
<p><strong>Permisos mínimos</strong>: Usa roles de IAM con permisos justos y necesarios.</p>
</li>
<li>
<p><strong>Versionado</strong>: Fija versiones de providers y módulos en producción.</p>
</li>
<li>
<p><strong>Scanning</strong>: Usa herramientas como tfsec, checkov para detectar vulnerabilidades.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_desarrollo_y_testing">Desarrollo y testing</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Validación</strong>: Ejecuta <code>terraform validate</code> y <code>terraform fmt</code> antes de commits.</p>
</li>
<li>
<p><strong>Pre-commit hooks</strong>: Automatiza validación y formateo.</p>
</li>
<li>
<p><strong>Plan siempre</strong>: Revisa <code>terraform plan</code> antes de aplicar cambios.</p>
</li>
<li>
<p><strong>Testing</strong>: Usa herramientas como Terratest para testing automatizado.</p>
</li>
<li>
<p><strong>Entornos temporales</strong>: Crea entornos efímeros para pruebas.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_cicd">CI/CD</h4>
<div class="ulist">
<ul>
<li>
<p><strong>Automatización</strong>: Integra Terraform en pipelines CI/CD.</p>
</li>
<li>
<p><strong>Plan en PRs</strong>: Muestra el plan en pull requests para revisión.</p>
</li>
<li>
<p><strong>Apply automático</strong>: Solo en ramas protegidas tras aprobación.</p>
</li>
<li>
<p><strong>Rollback</strong>: Mantén versiones anteriores del state para rollback.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_comandos_de_ejemplo_en_cicd">Comandos de ejemplo en CI/CD</h4>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash"># Pipeline CI/CD básico
terraform init -backend-config="key=prod/terraform.tfstate"
terraform validate
terraform fmt -check -recursive
terraform plan -out=plan.tfplan
terraform apply -auto-approve plan.tfplan</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_herramientas_complementarias_2">Herramientas complementarias</h3>
<div class="ulist">
<ul>
<li>
<p><strong>tfsec</strong>: Escaneo de seguridad para código Terraform.</p>
</li>
<li>
<p><strong>Checkov</strong>: Análisis estático de IaC para detectar misconfigurations.</p>
</li>
<li>
<p><strong>Terraform Docs</strong>: Generación automática de documentación.</p>
</li>
<li>
<p><strong>Terragrunt</strong>: Wrapper para gestionar configuraciones complejas y DRY.</p>
</li>
<li>
<p><strong>Atlantis</strong>: Automatización de Terraform via pull requests.</p>
</li>
<li>
<p><strong>Infracost</strong>: Estimación de costos de infraestructura.</p>
</li>
<li>
<p><strong>TFLint</strong>: Linter para Terraform con reglas específicas por provider.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_recursos_adicionales_2">Recursos adicionales</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.terraform.io/docs">Documentación oficial de Terraform</a></p>
</li>
<li>
<p><a href="https://registry.terraform.io/">Terraform Registry</a> - Módulos y providers públicos</p>
</li>
<li>
<p><a href="https://learn.hashicorp.com/terraform">HashiCorp Learn</a> - Tutoriales oficiales</p>
</li>
<li>
<p><a href="https://github.com/hashicorp/terraform">Repositorio de Terraform en GitHub</a></p>
</li>
<li>
<p><a href="https://www.terraform.io/cdktf">Terraform CDK</a> - Define infraestructura con lenguajes de programación</p>
</li>
<li>
<p><a href="https://www.youtube.com/c/HashiCorp">Canal de YouTube de HashiCorp</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2025-10-31 08:57:19 +0100
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>